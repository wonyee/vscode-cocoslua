{
    "global": {
        "2": "OpenUrl",
        "3": "SetSearchPath",
        "4": "_VERSION",
        "5": "assert",
        "6": "ccDrawCircle",
        "7": "ccDrawCircleScale",
        "8": "ccDrawColor4B",
        "9": "ccDrawColor4f",
        "10": "ccDrawCubicBezier",
        "11": "ccDrawFree",
        "12": "ccDrawInit",
        "13": "ccDrawLine",
        "14": "ccDrawPoint",
        "15": "ccDrawPoints",
        "16": "ccDrawPoly",
        "17": "ccDrawQuadBezier",
        "18": "ccDrawRect",
        "19": "ccDrawSolidCircle",
        "20": "ccDrawSolidPoly",
        "21": "ccDrawSolidRect",
        "22": "ccPointSize",
        "23": "checkbool",
        "24": "checkint",
        "25": "checknumber",
        "26": "checktable",
        "27": "class",
        "28": "clone",
        "29": "collectgarbage",
        "30": "compress",
        "31": "createDirectory",
        "32": "createSocket",
        "33": "dispatchTouchEvent",
        "34": "dofile",
        "35": "dump",
        "36": "error",
        "37": "gcinfo",
        "38": "getPreciseTime",
        "39": "getfenv",
        "40": "getjsons",
        "41": "getmetatable",
        "42": "handler",
        "43": "import",
        "44": "ipairs",
        "45": "iskindof",
        "46": "isset",
        "47": "kmGLLoadMatrix",
        "48": "kmGLPopMatrix",
        "49": "kmGLPushMatrix",
        "50": "kmGLTranslatef",
        "51": "load",
        "52": "loadfile",
        "53": "loadstring",
        "54": "mat4_createRotation",
        "55": "mat4_createRotationZ",
        "56": "mat4_createTranslation",
        "57": "mat4_decompose",
        "58": "mat4_getInversed",
        "59": "mat4_multiply",
        "60": "mat4_setIdentity",
        "61": "mat4_transformVector",
        "62": "mat4_translate",
        "63": "module",
        "64": "newproxy",
        "65": "next",
        "66": "pairs",
        "67": "pcall",
        "68": "performWithDelay",
        "69": "preMSG",
        "70": "print",
        "71": "printError",
        "72": "printInfo",
        "73": "printLog",
        "74": "printf",
        "75": "rawequal",
        "76": "rawget",
        "77": "rawset",
        "78": "release_print",
        "79": "require",
        "80": "schedule",
        "81": "select",
        "82": "setfenv",
        "83": "setmetatable",
        "84": "setmetatableindex",
        "85": "tonumber",
        "86": "tostring",
        "87": "type",
        "88": "uncompress",
        "89": "unpack",
        "90": "vec3_cross",
        "91": "xpcall",
        "92": "zipuncompress",
        "coroutine": [
            "create",
            "resume",
            "running",
            "status",
            "wrap",
            "yield"
        ],
        "gl": [
            "ACTIVE_ATTRIBUTES",
            "ACTIVE_ATTRIBUTE_MAX_LENGTH",
            "ACTIVE_PROGRAM_EXT",
            "ACTIVE_TEXTURE",
            "ACTIVE_UNIFORMS",
            "ACTIVE_UNIFORM_MAX_LENGTH",
            "ALIASED_LINE_WIDTH_RANGE",
            "ALIASED_POINT_SIZE_RANGE",
            "ALL_COMPLETED_NV",
            "ALL_SHADER_BITS_EXT",
            "ALPHA",
            "ALPHA16F_EXT",
            "ALPHA32F_EXT",
            "ALPHA8_EXT",
            "ALPHA8_OES",
            "ALPHA_BITS",
            "ALPHA_TEST_FUNC_QCOM",
            "ALPHA_TEST_QCOM",
            "ALPHA_TEST_REF_QCOM",
            "ALREADY_SIGNALED_APPLE",
            "ALWAYS",
            "AMD_compressed_3DC_texture",
            "AMD_compressed_ATC_texture",
            "AMD_performance_monitor",
            "AMD_program_binary_Z400",
            "ANGLE_depth_texture",
            "ANGLE_framebuffer_blit",
            "ANGLE_framebuffer_multisample",
            "ANGLE_instanced_arrays",
            "ANGLE_pack_reverse_row_order",
            "ANGLE_program_binary",
            "ANGLE_texture_compression_dxt3",
            "ANGLE_texture_compression_dxt5",
            "ANGLE_texture_usage",
            "ANGLE_translated_shader_source",
            "ANY_SAMPLES_PASSED_CONSERVATIVE_EXT",
            "ANY_SAMPLES_PASSED_EXT",
            "APPLE_copy_texture_levels",
            "APPLE_framebuffer_multisample",
            "APPLE_rgb_422",
            "APPLE_sync",
            "APPLE_texture_format_BGRA8888",
            "APPLE_texture_max_level",
            "ARM_mali_program_binary",
            "ARM_mali_shader_binary",
            "ARM_rgba8",
            "ARRAY_BUFFER",
            "ARRAY_BUFFER_BINDING",
            "ATC_RGBA_EXPLICIT_ALPHA_AMD",
            "ATC_RGBA_INTERPOLATED_ALPHA_AMD",
            "ATC_RGB_AMD",
            "ATTACHED_SHADERS",
            "BACK",
            "BGRA8_EXT",
            "BGRA_EXT",
            "BGRA_IMG",
            "BINNING_CONTROL_HINT_QCOM",
            "BLEND",
            "BLEND_COLOR",
            "BLEND_DST_ALPHA",
            "BLEND_DST_RGB",
            "BLEND_EQUATION",
            "BLEND_EQUATION_ALPHA",
            "BLEND_EQUATION_RGB",
            "BLEND_SRC_ALPHA",
            "BLEND_SRC_RGB",
            "BLUE_BITS",
            "BOOL",
            "BOOL_VEC2",
            "BOOL_VEC3",
            "BOOL_VEC4",
            "BUFFER",
            "BUFFER_ACCESS_OES",
            "BUFFER_MAPPED_OES",
            "BUFFER_MAP_POINTER_OES",
            "BUFFER_OBJECT_EXT",
            "BUFFER_SIZE",
            "BUFFER_USAGE",
            "BYTE",
            "CCW",
            "CLAMP_TO_BORDER_NV",
            "CLAMP_TO_EDGE",
            "COLOR_ATTACHMENT0",
            "COLOR_ATTACHMENT0_NV",
            "COLOR_ATTACHMENT10_NV",
            "COLOR_ATTACHMENT11_NV",
            "COLOR_ATTACHMENT12_NV",
            "COLOR_ATTACHMENT13_NV",
            "COLOR_ATTACHMENT14_NV",
            "COLOR_ATTACHMENT15_NV",
            "COLOR_ATTACHMENT1_NV",
            "COLOR_ATTACHMENT2_NV",
            "COLOR_ATTACHMENT3_NV",
            "COLOR_ATTACHMENT4_NV",
            "COLOR_ATTACHMENT5_NV",
            "COLOR_ATTACHMENT6_NV",
            "COLOR_ATTACHMENT7_NV",
            "COLOR_ATTACHMENT8_NV",
            "COLOR_ATTACHMENT9_NV",
            "COLOR_ATTACHMENT_EXT",
            "COLOR_BUFFER_BIT",
            "COLOR_BUFFER_BIT0_QCOM",
            "COLOR_BUFFER_BIT1_QCOM",
            "COLOR_BUFFER_BIT2_QCOM",
            "COLOR_BUFFER_BIT3_QCOM",
            "COLOR_BUFFER_BIT4_QCOM",
            "COLOR_BUFFER_BIT5_QCOM",
            "COLOR_BUFFER_BIT6_QCOM",
            "COLOR_BUFFER_BIT7_QCOM",
            "COLOR_CLEAR_VALUE",
            "COLOR_EXT",
            "COLOR_WRITEMASK",
            "COMPARE_REF_TO_TEXTURE_EXT",
            "COMPILE_STATUS",
            "COMPRESSED_RGBA_ASTC_10x10_KHR",
            "COMPRESSED_RGBA_ASTC_10x5_KHR",
            "COMPRESSED_RGBA_ASTC_10x6_KHR",
            "COMPRESSED_RGBA_ASTC_10x8_KHR",
            "COMPRESSED_RGBA_ASTC_12x10_KHR",
            "COMPRESSED_RGBA_ASTC_12x12_KHR",
            "COMPRESSED_RGBA_ASTC_4x4_KHR",
            "COMPRESSED_RGBA_ASTC_5x4_KHR",
            "COMPRESSED_RGBA_ASTC_5x5_KHR",
            "COMPRESSED_RGBA_ASTC_6x5_KHR",
            "COMPRESSED_RGBA_ASTC_6x6_KHR",
            "COMPRESSED_RGBA_ASTC_8x5_KHR",
            "COMPRESSED_RGBA_ASTC_8x6_KHR",
            "COMPRESSED_RGBA_ASTC_8x8_KHR",
            "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
            "COMPRESSED_RGBA_PVRTC_2BPPV2_IMG",
            "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
            "COMPRESSED_RGBA_PVRTC_4BPPV2_IMG",
            "COMPRESSED_RGBA_S3TC_DXT1_EXT",
            "COMPRESSED_RGBA_S3TC_DXT3_ANGLE",
            "COMPRESSED_RGBA_S3TC_DXT5_ANGLE",
            "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
            "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
            "COMPRESSED_RGB_S3TC_DXT1_EXT",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",
            "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",
            "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV",
            "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV",
            "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV",
            "COMPRESSED_SRGB_S3TC_DXT1_NV",
            "COMPRESSED_TEXTURE_FORMATS",
            "CONDITION_SATISFIED_APPLE",
            "CONSTANT_ALPHA",
            "CONSTANT_COLOR",
            "CONTEXT_FLAG_DEBUG_BIT",
            "CONTEXT_ROBUST_ACCESS_EXT",
            "COUNTER_RANGE_AMD",
            "COUNTER_TYPE_AMD",
            "COVERAGE_ALL_FRAGMENTS_NV",
            "COVERAGE_ATTACHMENT_NV",
            "COVERAGE_AUTOMATIC_NV",
            "COVERAGE_BUFFERS_NV",
            "COVERAGE_BUFFER_BIT_NV",
            "COVERAGE_COMPONENT4_NV",
            "COVERAGE_COMPONENT_NV",
            "COVERAGE_EDGE_FRAGMENTS_NV",
            "COVERAGE_SAMPLES_NV",
            "CPU_OPTIMIZED_QCOM",
            "CULL_FACE",
            "CULL_FACE_MODE",
            "CURRENT_PROGRAM",
            "CURRENT_QUERY_EXT",
            "CURRENT_VERTEX_ATTRIB",
            "CW",
            "DEBUG_CALLBACK_FUNCTION",
            "DEBUG_CALLBACK_USER_PARAM",
            "DEBUG_GROUP_STACK_DEPTH",
            "DEBUG_LOGGED_MESSAGES",
            "DEBUG_NEXT_LOGGED_MESSAGE_LENGTH",
            "DEBUG_OUTPUT",
            "DEBUG_OUTPUT_SYNCHRONOUS",
            "DEBUG_SEVERITY_HIGH",
            "DEBUG_SEVERITY_LOW",
            "DEBUG_SEVERITY_MEDIUM",
            "DEBUG_SEVERITY_NOTIFICATION",
            "DEBUG_SOURCE_API",
            "DEBUG_SOURCE_APPLICATION",
            "DEBUG_SOURCE_OTHER",
            "DEBUG_SOURCE_SHADER_COMPILER",
            "DEBUG_SOURCE_THIRD_PARTY",
            "DEBUG_SOURCE_WINDOW_SYSTEM",
            "DEBUG_TYPE_DEPRECATED_BEHAVIOR",
            "DEBUG_TYPE_ERROR",
            "DEBUG_TYPE_MARKER",
            "DEBUG_TYPE_OTHER",
            "DEBUG_TYPE_PERFORMANCE",
            "DEBUG_TYPE_POP_GROUP",
            "DEBUG_TYPE_PORTABILITY",
            "DEBUG_TYPE_PUSH_GROUP",
            "DEBUG_TYPE_UNDEFINED_BEHAVIOR",
            "DECR",
            "DECR_WRAP",
            "DELETE_STATUS",
            "DEPTH24_STENCIL8_OES",
            "DEPTH_ATTACHMENT",
            "DEPTH_BITS",
            "DEPTH_BUFFER_BIT",
            "DEPTH_BUFFER_BIT0_QCOM",
            "DEPTH_BUFFER_BIT1_QCOM",
            "DEPTH_BUFFER_BIT2_QCOM",
            "DEPTH_BUFFER_BIT3_QCOM",
            "DEPTH_BUFFER_BIT4_QCOM",
            "DEPTH_BUFFER_BIT5_QCOM",
            "DEPTH_BUFFER_BIT6_QCOM",
            "DEPTH_BUFFER_BIT7_QCOM",
            "DEPTH_CLEAR_VALUE",
            "DEPTH_COMPONENT",
            "DEPTH_COMPONENT16",
            "DEPTH_COMPONENT16_NONLINEAR_NV",
            "DEPTH_COMPONENT16_OES",
            "DEPTH_COMPONENT24_OES",
            "DEPTH_COMPONENT32_OES",
            "DEPTH_EXT",
            "DEPTH_FUNC",
            "DEPTH_RANGE",
            "DEPTH_STENCIL_OES",
            "DEPTH_TEST",
            "DEPTH_WRITEMASK",
            "DITHER",
            "DMP_shader_binary",
            "DONT_CARE",
            "DRAW_BUFFER0_NV",
            "DRAW_BUFFER10_NV",
            "DRAW_BUFFER11_NV",
            "DRAW_BUFFER12_NV",
            "DRAW_BUFFER13_NV",
            "DRAW_BUFFER14_NV",
            "DRAW_BUFFER15_NV",
            "DRAW_BUFFER1_NV",
            "DRAW_BUFFER2_NV",
            "DRAW_BUFFER3_NV",
            "DRAW_BUFFER4_NV",
            "DRAW_BUFFER5_NV",
            "DRAW_BUFFER6_NV",
            "DRAW_BUFFER7_NV",
            "DRAW_BUFFER8_NV",
            "DRAW_BUFFER9_NV",
            "DRAW_BUFFER_EXT",
            "DRAW_FRAMEBUFFER_ANGLE",
            "DRAW_FRAMEBUFFER_APPLE",
            "DRAW_FRAMEBUFFER_BINDING_ANGLE",
            "DRAW_FRAMEBUFFER_BINDING_APPLE",
            "DRAW_FRAMEBUFFER_BINDING_NV",
            "DRAW_FRAMEBUFFER_NV",
            "DST_ALPHA",
            "DST_COLOR",
            "DYNAMIC_DRAW",
            "ELEMENT_ARRAY_BUFFER",
            "ELEMENT_ARRAY_BUFFER_BINDING",
            "EQUAL",
            "ES_VERSION_2_0",
            "ETC1_RGB8_OES",
            "ETC1_SRGB8_NV",
            "EXTENSIONS",
            "EXT_blend_minmax",
            "EXT_color_buffer_half_float",
            "EXT_debug_label",
            "EXT_debug_marker",
            "EXT_discard_framebuffer",
            "EXT_map_buffer_range",
            "EXT_multi_draw_arrays",
            "EXT_multisampled_render_to_texture",
            "EXT_multiview_draw_buffers",
            "EXT_occlusion_query_boolean",
            "EXT_read_format_bgra",
            "EXT_robustness",
            "EXT_sRGB",
            "EXT_separate_shader_objects",
            "EXT_shader_framebuffer_fetch",
            "EXT_shader_texture_lod",
            "EXT_shadow_samplers",
            "EXT_texture_compression_dxt1",
            "EXT_texture_filter_anisotropic",
            "EXT_texture_format_BGRA8888",
            "EXT_texture_rg",
            "EXT_texture_storage",
            "EXT_texture_type_2_10_10_10_REV",
            "EXT_unpack_subimage",
            "FALSE",
            "FASTEST",
            "FENCE_CONDITION_NV",
            "FENCE_STATUS_NV",
            "FIXED",
            "FJ_shader_binary_GCCSO",
            "FLOAT",
            "FLOAT_MAT2",
            "FLOAT_MAT3",
            "FLOAT_MAT4",
            "FLOAT_VEC2",
            "FLOAT_VEC3",
            "FLOAT_VEC4",
            "FRAGMENT_SHADER",
            "FRAGMENT_SHADER_BIT_EXT",
            "FRAGMENT_SHADER_DERIVATIVE_HINT_OES",
            "FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT",
            "FRAMEBUFFER",
            "FRAMEBUFFER_ATTACHMENT_ANGLE",
            "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT",
            "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT",
            "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
            "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
            "FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES",
            "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
            "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
            "FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT",
            "FRAMEBUFFER_BINDING",
            "FRAMEBUFFER_COMPLETE",
            "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
            "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
            "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
            "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE",
            "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE",
            "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT",
            "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG",
            "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV",
            "FRAMEBUFFER_UNDEFINED_OES",
            "FRAMEBUFFER_UNSUPPORTED",
            "FRONT",
            "FRONT_AND_BACK",
            "FRONT_FACE",
            "FUNC_ADD",
            "FUNC_REVERSE_SUBTRACT",
            "FUNC_SUBTRACT",
            "GCCSO_SHADER_BINARY_FJ",
            "GENERATE_MIPMAP_HINT",
            "GEQUAL",
            "GPU_OPTIMIZED_QCOM",
            "GREATER",
            "GREEN_BITS",
            "GUILTY_CONTEXT_RESET_EXT",
            "HALF_FLOAT_OES",
            "HIGH_FLOAT",
            "HIGH_INT",
            "IMG_multisampled_render_to_texture",
            "IMG_program_binary",
            "IMG_read_format",
            "IMG_shader_binary",
            "IMG_texture_compression_pvrtc",
            "IMG_texture_compression_pvrtc2",
            "IMPLEMENTATION_COLOR_READ_FORMAT",
            "IMPLEMENTATION_COLOR_READ_TYPE",
            "INCR",
            "INCR_WRAP",
            "INFO_LOG_LENGTH",
            "INNOCENT_CONTEXT_RESET_EXT",
            "INT",
            "INT_10_10_10_2_OES",
            "INT_VEC2",
            "INT_VEC3",
            "INT_VEC4",
            "INVALID_ENUM",
            "INVALID_FRAMEBUFFER_OPERATION",
            "INVALID_OPERATION",
            "INVALID_VALUE",
            "INVERT",
            "KEEP",
            "KHR_debug",
            "KHR_texture_compression_astc_ldr",
            "LEQUAL",
            "LESS",
            "LINEAR",
            "LINEAR_MIPMAP_LINEAR",
            "LINEAR_MIPMAP_NEAREST",
            "LINES",
            "LINE_LOOP",
            "LINE_STRIP",
            "LINE_WIDTH",
            "LINK_STATUS",
            "LOSE_CONTEXT_ON_RESET_EXT",
            "LOW_FLOAT",
            "LOW_INT",
            "LUMINANCE",
            "LUMINANCE16F_EXT",
            "LUMINANCE32F_EXT",
            "LUMINANCE4_ALPHA4_OES",
            "LUMINANCE8_ALPHA8_EXT",
            "LUMINANCE8_ALPHA8_OES",
            "LUMINANCE8_EXT",
            "LUMINANCE8_OES",
            "LUMINANCE_ALPHA",
            "LUMINANCE_ALPHA16F_EXT",
            "LUMINANCE_ALPHA32F_EXT",
            "MALI_PROGRAM_BINARY_ARM",
            "MALI_SHADER_BINARY_ARM",
            "MAP_FLUSH_EXPLICIT_BIT_EXT",
            "MAP_INVALIDATE_BUFFER_BIT_EXT",
            "MAP_INVALIDATE_RANGE_BIT_EXT",
            "MAP_READ_BIT_EXT",
            "MAP_UNSYNCHRONIZED_BIT_EXT",
            "MAP_WRITE_BIT_EXT",
            "MAX_3D_TEXTURE_SIZE_OES",
            "MAX_COLOR_ATTACHMENTS_NV",
            "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
            "MAX_CUBE_MAP_TEXTURE_SIZE",
            "MAX_DEBUG_GROUP_STACK_DEPTH",
            "MAX_DEBUG_LOGGED_MESSAGES",
            "MAX_DEBUG_MESSAGE_LENGTH",
            "MAX_DRAW_BUFFERS_NV",
            "MAX_EXT",
            "MAX_FRAGMENT_UNIFORM_VECTORS",
            "MAX_LABEL_LENGTH",
            "MAX_MULTIVIEW_BUFFERS_EXT",
            "MAX_RENDERBUFFER_SIZE",
            "MAX_SAMPLES_ANGLE",
            "MAX_SAMPLES_APPLE",
            "MAX_SAMPLES_EXT",
            "MAX_SAMPLES_IMG",
            "MAX_SAMPLES_NV",
            "MAX_SERVER_WAIT_TIMEOUT_APPLE",
            "MAX_TEXTURE_IMAGE_UNITS",
            "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
            "MAX_TEXTURE_SIZE",
            "MAX_VARYING_VECTORS",
            "MAX_VERTEX_ATTRIBS",
            "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
            "MAX_VERTEX_UNIFORM_VECTORS",
            "MAX_VIEWPORT_DIMS",
            "MEDIUM_FLOAT",
            "MEDIUM_INT",
            "MIN_EXT",
            "MIRRORED_REPEAT",
            "MULTISAMPLE_BUFFER_BIT0_QCOM",
            "MULTISAMPLE_BUFFER_BIT1_QCOM",
            "MULTISAMPLE_BUFFER_BIT2_QCOM",
            "MULTISAMPLE_BUFFER_BIT3_QCOM",
            "MULTISAMPLE_BUFFER_BIT4_QCOM",
            "MULTISAMPLE_BUFFER_BIT5_QCOM",
            "MULTISAMPLE_BUFFER_BIT6_QCOM",
            "MULTISAMPLE_BUFFER_BIT7_QCOM",
            "MULTIVIEW_EXT",
            "NEAREST",
            "NEAREST_MIPMAP_LINEAR",
            "NEAREST_MIPMAP_NEAREST",
            "NEVER",
            "NICEST",
            "NONE",
            "NOTEQUAL",
            "NO_ERROR",
            "NO_RESET_NOTIFICATION_EXT",
            "NUM_COMPRESSED_TEXTURE_FORMATS",
            "NUM_PROGRAM_BINARY_FORMATS_OES",
            "NUM_SHADER_BINARY_FORMATS",
            "NV_coverage_sample",
            "NV_depth_nonlinear",
            "NV_draw_buffers",
            "NV_draw_instanced",
            "NV_fbo_color_attachments",
            "NV_fence",
            "NV_framebuffer_blit",
            "NV_framebuffer_multisample",
            "NV_generate_mipmap_sRGB",
            "NV_instanced_arrays",
            "NV_read_buffer",
            "NV_read_buffer_front",
            "NV_read_depth",
            "NV_read_depth_stencil",
            "NV_read_stencil",
            "NV_sRGB_formats",
            "NV_shadow_samplers_array",
            "NV_shadow_samplers_cube",
            "NV_texture_border_clamp",
            "NV_texture_compression_s3tc_update",
            "NV_texture_npot_2D_mipmap",
            "OBJECT_TYPE_APPLE",
            "OES_EGL_image",
            "OES_EGL_image_external",
            "OES_compressed_ETC1_RGB8_texture",
            "OES_compressed_paletted_texture",
            "OES_depth24",
            "OES_depth32",
            "OES_depth_texture",
            "OES_element_index_uint",
            "OES_fbo_render_mipmap",
            "OES_fragment_precision_high",
            "OES_get_program_binary",
            "OES_mapbuffer",
            "OES_packed_depth_stencil",
            "OES_required_internalformat",
            "OES_rgb8_rgba8",
            "OES_standard_derivatives",
            "OES_stencil1",
            "OES_stencil4",
            "OES_surfaceless_context",
            "OES_texture_3D",
            "OES_texture_float",
            "OES_texture_float_linear",
            "OES_texture_half_float",
            "OES_texture_half_float_linear",
            "OES_texture_npot",
            "OES_vertex_array_object",
            "OES_vertex_half_float",
            "OES_vertex_type_10_10_10_2",
            "ONE",
            "ONE_MINUS_CONSTANT_ALPHA",
            "ONE_MINUS_CONSTANT_COLOR",
            "ONE_MINUS_DST_ALPHA",
            "ONE_MINUS_DST_COLOR",
            "ONE_MINUS_SRC_ALPHA",
            "ONE_MINUS_SRC_COLOR",
            "OUT_OF_MEMORY",
            "PACK_ALIGNMENT",
            "PACK_REVERSE_ROW_ORDER_ANGLE",
            "PALETTE4_R5_G6_B5_OES",
            "PALETTE4_RGB5_A1_OES",
            "PALETTE4_RGB8_OES",
            "PALETTE4_RGBA4_OES",
            "PALETTE4_RGBA8_OES",
            "PALETTE8_R5_G6_B5_OES",
            "PALETTE8_RGB5_A1_OES",
            "PALETTE8_RGB8_OES",
            "PALETTE8_RGBA4_OES",
            "PALETTE8_RGBA8_OES",
            "PERCENTAGE_AMD",
            "PERFMON_GLOBAL_MODE_QCOM",
            "PERFMON_RESULT_AMD",
            "PERFMON_RESULT_AVAILABLE_AMD",
            "PERFMON_RESULT_SIZE_AMD",
            "POINTS",
            "POLYGON_OFFSET_FACTOR",
            "POLYGON_OFFSET_FILL",
            "POLYGON_OFFSET_UNITS",
            "PROGRAM",
            "PROGRAM_BINARY_ANGLE",
            "PROGRAM_BINARY_FORMATS_OES",
            "PROGRAM_BINARY_LENGTH_OES",
            "PROGRAM_OBJECT_EXT",
            "PROGRAM_PIPELINE_BINDING_EXT",
            "PROGRAM_PIPELINE_OBJECT_EXT",
            "PROGRAM_SEPARABLE_EXT",
            "QCOM_alpha_test",
            "QCOM_binning_control",
            "QCOM_driver_control",
            "QCOM_extended_get",
            "QCOM_extended_get2",
            "QCOM_perfmon_global_mode",
            "QCOM_tiled_rendering",
            "QCOM_writeonly_rendering",
            "QUERY",
            "QUERY_OBJECT_EXT",
            "QUERY_RESULT_AVAILABLE_EXT",
            "QUERY_RESULT_EXT",
            "R16F_EXT",
            "R32F_EXT",
            "R8_EXT",
            "READ_BUFFER_EXT",
            "READ_BUFFER_NV",
            "READ_FRAMEBUFFER_ANGLE",
            "READ_FRAMEBUFFER_APPLE",
            "READ_FRAMEBUFFER_BINDING_ANGLE",
            "READ_FRAMEBUFFER_BINDING_APPLE",
            "READ_FRAMEBUFFER_BINDING_NV",
            "READ_FRAMEBUFFER_NV",
            "RED_BITS",
            "RED_EXT",
            "RENDERBUFFER",
            "RENDERBUFFER_ALPHA_SIZE",
            "RENDERBUFFER_BINDING",
            "RENDERBUFFER_BLUE_SIZE",
            "RENDERBUFFER_DEPTH_SIZE",
            "RENDERBUFFER_GREEN_SIZE",
            "RENDERBUFFER_HEIGHT",
            "RENDERBUFFER_INTERNAL_FORMAT",
            "RENDERBUFFER_RED_SIZE",
            "RENDERBUFFER_SAMPLES_ANGLE",
            "RENDERBUFFER_SAMPLES_APPLE",
            "RENDERBUFFER_SAMPLES_EXT",
            "RENDERBUFFER_SAMPLES_IMG",
            "RENDERBUFFER_SAMPLES_NV",
            "RENDERBUFFER_STENCIL_SIZE",
            "RENDERBUFFER_WIDTH",
            "RENDERER",
            "RENDER_DIRECT_TO_FRAMEBUFFER_QCOM",
            "REPEAT",
            "REPLACE",
            "REQUIRED_TEXTURE_IMAGE_UNITS_OES",
            "RESET_NOTIFICATION_STRATEGY_EXT",
            "RG16F_EXT",
            "RG32F_EXT",
            "RG8_EXT",
            "RGB",
            "RGB10_A2_EXT",
            "RGB10_EXT",
            "RGB16F_EXT",
            "RGB32F_EXT",
            "RGB565",
            "RGB565_OES",
            "RGB5_A1",
            "RGB5_A1_OES",
            "RGB8_OES",
            "RGBA",
            "RGBA16F_EXT",
            "RGBA32F_EXT",
            "RGBA4",
            "RGBA4_OES",
            "RGBA8_OES",
            "RGB_422_APPLE",
            "RG_EXT",
            "SAMPLER",
            "SAMPLER_2D",
            "SAMPLER_2D_ARRAY_SHADOW_NV",
            "SAMPLER_2D_SHADOW_EXT",
            "SAMPLER_3D_OES",
            "SAMPLER_CUBE",
            "SAMPLER_CUBE_SHADOW_NV",
            "SAMPLER_EXTERNAL_OES",
            "SAMPLES",
            "SAMPLE_ALPHA_TO_COVERAGE",
            "SAMPLE_BUFFERS",
            "SAMPLE_COVERAGE",
            "SAMPLE_COVERAGE_INVERT",
            "SAMPLE_COVERAGE_VALUE",
            "SCISSOR_BOX",
            "SCISSOR_TEST",
            "SGX_BINARY_IMG",
            "SGX_PROGRAM_BINARY_IMG",
            "SHADER",
            "SHADER_BINARY_DMP",
            "SHADER_BINARY_FORMATS",
            "SHADER_BINARY_VIV",
            "SHADER_COMPILER",
            "SHADER_OBJECT_EXT",
            "SHADER_SOURCE_LENGTH",
            "SHADER_TYPE",
            "SHADING_LANGUAGE_VERSION",
            "SHORT",
            "SIGNALED_APPLE",
            "SLUMINANCE8_ALPHA8_NV",
            "SLUMINANCE8_NV",
            "SLUMINANCE_ALPHA_NV",
            "SLUMINANCE_NV",
            "SRC_ALPHA",
            "SRC_ALPHA_SATURATE",
            "SRC_COLOR",
            "SRGB8_ALPHA8_EXT",
            "SRGB8_NV",
            "SRGB_ALPHA_EXT",
            "SRGB_EXT",
            "STACK_OVERFLOW",
            "STACK_UNDERFLOW",
            "STATE_RESTORE",
            "STATIC_DRAW",
            "STENCIL_ATTACHMENT",
            "STENCIL_BACK_FAIL",
            "STENCIL_BACK_FUNC",
            "STENCIL_BACK_PASS_DEPTH_FAIL",
            "STENCIL_BACK_PASS_DEPTH_PASS",
            "STENCIL_BACK_REF",
            "STENCIL_BACK_VALUE_MASK",
            "STENCIL_BACK_WRITEMASK",
            "STENCIL_BITS",
            "STENCIL_BUFFER_BIT",
            "STENCIL_BUFFER_BIT0_QCOM",
            "STENCIL_BUFFER_BIT1_QCOM",
            "STENCIL_BUFFER_BIT2_QCOM",
            "STENCIL_BUFFER_BIT3_QCOM",
            "STENCIL_BUFFER_BIT4_QCOM",
            "STENCIL_BUFFER_BIT5_QCOM",
            "STENCIL_BUFFER_BIT6_QCOM",
            "STENCIL_BUFFER_BIT7_QCOM",
            "STENCIL_CLEAR_VALUE",
            "STENCIL_EXT",
            "STENCIL_FAIL",
            "STENCIL_FUNC",
            "STENCIL_INDEX1_OES",
            "STENCIL_INDEX4_OES",
            "STENCIL_INDEX8",
            "STENCIL_PASS_DEPTH_FAIL",
            "STENCIL_PASS_DEPTH_PASS",
            "STENCIL_REF",
            "STENCIL_TEST",
            "STENCIL_VALUE_MASK",
            "STENCIL_WRITEMASK",
            "STREAM_DRAW",
            "SUBPIXEL_BITS",
            "SYNC_CONDITION_APPLE",
            "SYNC_FENCE_APPLE",
            "SYNC_FLAGS_APPLE",
            "SYNC_FLUSH_COMMANDS_BIT_APPLE",
            "SYNC_GPU_COMMANDS_COMPLETE_APPLE",
            "SYNC_OBJECT_APPLE",
            "SYNC_STATUS_APPLE",
            "TEXTURE",
            "TEXTURE0",
            "TEXTURE1",
            "TEXTURE10",
            "TEXTURE11",
            "TEXTURE12",
            "TEXTURE13",
            "TEXTURE14",
            "TEXTURE15",
            "TEXTURE16",
            "TEXTURE17",
            "TEXTURE18",
            "TEXTURE19",
            "TEXTURE2",
            "TEXTURE20",
            "TEXTURE21",
            "TEXTURE22",
            "TEXTURE23",
            "TEXTURE24",
            "TEXTURE25",
            "TEXTURE26",
            "TEXTURE27",
            "TEXTURE28",
            "TEXTURE29",
            "TEXTURE3",
            "TEXTURE30",
            "TEXTURE31",
            "TEXTURE4",
            "TEXTURE5",
            "TEXTURE6",
            "TEXTURE7",
            "TEXTURE8",
            "TEXTURE9",
            "TEXTURE_2D",
            "TEXTURE_3D_OES",
            "TEXTURE_BINDING_2D",
            "TEXTURE_BINDING_3D_OES",
            "TEXTURE_BINDING_CUBE_MAP",
            "TEXTURE_BINDING_EXTERNAL_OES",
            "TEXTURE_BORDER_COLOR_NV",
            "TEXTURE_COMPARE_FUNC_EXT",
            "TEXTURE_COMPARE_MODE_EXT",
            "TEXTURE_CUBE_MAP",
            "TEXTURE_CUBE_MAP_NEGATIVE_X",
            "TEXTURE_CUBE_MAP_NEGATIVE_Y",
            "TEXTURE_CUBE_MAP_NEGATIVE_Z",
            "TEXTURE_CUBE_MAP_POSITIVE_X",
            "TEXTURE_CUBE_MAP_POSITIVE_Y",
            "TEXTURE_CUBE_MAP_POSITIVE_Z",
            "TEXTURE_DEPTH_QCOM",
            "TEXTURE_EXTERNAL_OES",
            "TEXTURE_FORMAT_QCOM",
            "TEXTURE_HEIGHT_QCOM",
            "TEXTURE_IMAGE_VALID_QCOM",
            "TEXTURE_IMMUTABLE_FORMAT_EXT",
            "TEXTURE_INTERNAL_FORMAT_QCOM",
            "TEXTURE_MAG_FILTER",
            "TEXTURE_MAX_ANISOTROPY_EXT",
            "TEXTURE_MAX_LEVEL_APPLE",
            "TEXTURE_MIN_FILTER",
            "TEXTURE_NUM_LEVELS_QCOM",
            "TEXTURE_OBJECT_VALID_QCOM",
            "TEXTURE_SAMPLES_IMG",
            "TEXTURE_TARGET_QCOM",
            "TEXTURE_TYPE_QCOM",
            "TEXTURE_USAGE_ANGLE",
            "TEXTURE_WIDTH_QCOM",
            "TEXTURE_WRAP_R_OES",
            "TEXTURE_WRAP_S",
            "TEXTURE_WRAP_T",
            "TIMEOUT_EXPIRED_APPLE",
            "TIMEOUT_IGNORED_APPLE",
            "TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE",
            "TRIANGLES",
            "TRIANGLE_FAN",
            "TRIANGLE_STRIP",
            "TRUE",
            "UNKNOWN_CONTEXT_RESET_EXT",
            "UNPACK_ALIGNMENT",
            "UNPACK_ROW_LENGTH",
            "UNPACK_SKIP_PIXELS",
            "UNPACK_SKIP_ROWS",
            "UNSIGNALED_APPLE",
            "UNSIGNED_BYTE",
            "UNSIGNED_INT",
            "UNSIGNED_INT64_AMD",
            "UNSIGNED_INT_10_10_10_2_OES",
            "UNSIGNED_INT_24_8_OES",
            "UNSIGNED_INT_2_10_10_10_REV_EXT",
            "UNSIGNED_NORMALIZED_EXT",
            "UNSIGNED_SHORT",
            "UNSIGNED_SHORT_1_5_5_5_REV_EXT",
            "UNSIGNED_SHORT_4_4_4_4",
            "UNSIGNED_SHORT_4_4_4_4_REV_EXT",
            "UNSIGNED_SHORT_4_4_4_4_REV_IMG",
            "UNSIGNED_SHORT_5_5_5_1",
            "UNSIGNED_SHORT_5_6_5",
            "UNSIGNED_SHORT_8_8_APPLE",
            "UNSIGNED_SHORT_8_8_REV_APPLE",
            "VALIDATE_STATUS",
            "VENDOR",
            "VERSION",
            "VERTEX_ARRAY_BINDING_OES",
            "VERTEX_ARRAY_OBJECT_EXT",
            "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
            "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE",
            "VERTEX_ATTRIB_ARRAY_DIVISOR_NV",
            "VERTEX_ATTRIB_ARRAY_ENABLED",
            "VERTEX_ATTRIB_ARRAY_NORMALIZED",
            "VERTEX_ATTRIB_ARRAY_POINTER",
            "VERTEX_ATTRIB_ARRAY_SIZE",
            "VERTEX_ATTRIB_ARRAY_STRIDE",
            "VERTEX_ATTRIB_ARRAY_TYPE",
            "VERTEX_ATTRIB_POINTER_COLOR4B",
            "VERTEX_ATTRIB_POINTER_VEC3",
            "VERTEX_SHADER",
            "VERTEX_SHADER_BIT_EXT",
            "VIEWPORT",
            "VIV_shader_binary",
            "WAIT_FAILED_APPLE",
            "WRITEONLY_RENDERING_QCOM",
            "WRITE_ONLY_OES",
            "Z400_BINARY_AMD",
            "ZERO",
            "_3DC_XY_AMD",
            "_3DC_X_AMD",
            "_attachShader",
            "_bindAttribLocation",
            "_bindBuffer",
            "_bindFramebuffer",
            "_bindRenderbuffer",
            "_bindTexture",
            "_compileShader",
            "_createBuffer",
            "_createFramebuffer",
            "_createProgram",
            "_createRenderbuffer",
            "_createShader",
            "_createTexture",
            "_deleteBuffer",
            "_deleteFramebuffer",
            "_deleteProgram",
            "_deleteRenderbuffer",
            "_deleteShader",
            "_deleteTexture",
            "_getActiveAttrib",
            "_getActiveUniform",
            "_getAttachedShaders",
            "_getAttribLocation",
            "_getProgramInfoLog",
            "_getProgramParameter",
            "_getShaderInfoLog",
            "_getShaderParameter",
            "_getShaderSource",
            "_getUniform",
            "_getUniformLocation",
            "_linkProgram",
            "_shaderSource",
            "_texImage2D",
            "_texSubImage2D",
            "_useProgram",
            "_validateProgram",
            "activeTexture",
            "attachShader",
            "bindBuffer",
            "bindFramebuffer",
            "bindRenderBuffer",
            "bindTexture",
            "blendColor",
            "blendEquation",
            "blendEquationSeparate",
            "blendFunc",
            "blendFuncSeparate",
            "bufferData",
            "bufferSubData",
            "checkFramebufferStatus",
            "clear",
            "clearColor",
            "clearDepthf",
            "clearStencil",
            "colorMask",
            "compileShader",
            "compressedTexImage2D",
            "compressedTexSubImage2D",
            "copyTexImage2D",
            "copyTexSubImage2D",
            "createBuffer",
            "createFramebuffer",
            "createProgram",
            "createRenderbuffer",
            "createShader",
            "createTexture",
            "cullFace",
            "deleteBuffer",
            "deleteFramebuffer",
            "deleteProgram",
            "deleteRenderbuffer",
            "deleteShader",
            "deleteTexture",
            "depthFunc",
            "depthMask",
            "depthRangef",
            "detachShader",
            "disable",
            "disableVertexAttribArray",
            "drawArrays",
            "drawElements",
            "enable",
            "enableVertexAttribArray",
            "finish",
            "flush",
            "framebufferRenderbuffer",
            "framebufferTexture2D",
            "frontFace",
            "generateMipmap",
            "getActiveAttrib",
            "getActiveUniform",
            "getAttachedShaders",
            "getAttribLocation",
            "getError",
            "getProgramParameter",
            "getShaderInfoLog",
            "getShaderParameter",
            "getSupportedExtensions",
            "getTexParameter",
            "getUniform",
            "getUniformLocation",
            "glEnableVertexAttribs",
            "glNodeCreate",
            "hint",
            "isBuffer",
            "isEnabled",
            "isFramebuffer",
            "isProgram",
            "isRenderbuffer",
            "isShader",
            "isTexture",
            "lineWidth",
            "linkProgram",
            "pixelStorei",
            "polygonOffset",
            "readPixels",
            "releaseShaderCompiler",
            "renderbufferStorage",
            "sampleCoverage",
            "scissor",
            "shaderSource",
            "stencilFunc",
            "stencilFuncSeparate",
            "stencilMask",
            "stencilMaskSeparate",
            "stencilOp",
            "stencilOpSeparate",
            "texParameterf",
            "texParameteri",
            "uniform1f",
            "uniform1fv",
            "uniform1i",
            "uniform1iv",
            "uniform2f",
            "uniform2fv",
            "uniform2i",
            "uniform2iv",
            "uniform3f",
            "uniform3fv",
            "uniform3i",
            "uniform3iv",
            "uniform4f",
            "uniform4fv",
            "uniform4i",
            "uniform4iv",
            "uniformMatrix2fv",
            "uniformMatrix3fv",
            "uniformMatrix4fv",
            "useProgram",
            "vertexAttrib1f",
            "vertexAttrib1fv",
            "vertexAttrib2f",
            "vertexAttrib2fv",
            "vertexAttrib3f",
            "vertexAttrib3fv",
            "vertexAttrib4f",
            "vertexAttrib4fv",
            "vertexAttribPointer",
            "viewport"
        ],
        "ScriptHandlerMgr": [
            "getInstance",
            "registerScriptHandler",
            "removeObjectAllHandlers",
            "unregisterScriptHandler"
        ],
        "CCString": [
            "boolValue",
            "compare",
            "create",
            "createWithContentsOfFile",
            "createWithData",
            "doubleValue",
            "floatValue",
            "getCString",
            "intValue",
            "isEqual",
            "length",
            "uintValue"
        ],
        "ccs": {
            "ColorFrame": {
                "1": "new",
                "setColor": {
                    "type": "method",
                    "define": "setColor(${1:#color3b_table color})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getColor": {
                    "type": "method",
                    "define": "getColor()"
                }
            },
            "FrameData": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "copy": {
                    "type": "method",
                    "define": "copy(${1:#ccs.BaseData baseData})"
                }
            },
            "InnerActionFrame": {
                "1": "new",
                "getSingleFrameIndex": {
                    "type": "method",
                    "define": "getSingleFrameIndex()"
                },
                "setStartFrameIndex": {
                    "type": "method",
                    "define": "setStartFrameIndex(${1:#int frameIndex})"
                },
                "getEndFrameIndex": {
                    "type": "method",
                    "define": "getEndFrameIndex()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setAnimationName": {
                    "type": "method",
                    "define": "setAnimationName(${1:#string animationNamed})"
                },
                "getInnerActionType": {
                    "type": "method",
                    "define": "getInnerActionType()"
                },
                "setSingleFrameIndex": {
                    "type": "method",
                    "define": "setSingleFrameIndex(${1:#int frameIndex})"
                },
                "setInnerActionType": {
                    "type": "method",
                    "define": "setInnerActionType(${1:#int type})"
                },
                "setEndFrameIndex": {
                    "type": "method",
                    "define": "setEndFrameIndex(${1:#int frameIndex})"
                },
                "setEnterWithName": {
                    "type": "method",
                    "define": "setEnterWithName(${1:#bool isEnterWithName})"
                },
                "getStartFrameIndex": {
                    "type": "method",
                    "define": "getStartFrameIndex()"
                }
            },
            "ActionTimeline": {
                "1": "new",
                "2": "setFrameEventCallFunc",
                "gotoFrameAndPlay": {
                    "type": "method",
                    "define": "gotoFrameAndPlay(${1:#int startIndex},${2:#int endIndex},${3:#int currentFrameIndex},${4:#bool loop})",
                    "detail": "@overload self, int, bool         \n@overload self, int         \n@overload self, int, int, bool         \n@overload self, int, int, int, bool         \n"
                },
                "start": {
                    "type": "method",
                    "define": "start()",
                    "detail": "/ @{/ @name implement Playable Protocol\n"
                },
                "pause": {
                    "type": "method",
                    "define": "pause()",
                    "detail": " Pause the animation. \n"
                },
                "getAnimationInfo": {
                    "type": "method",
                    "define": "getAnimationInfo(${1:#string animationName})"
                },
                "IsAnimationInfoExists": {
                    "type": "method",
                    "define": "IsAnimationInfoExists(${1:#string animationName})"
                },
                "getTimeSpeed": {
                    "type": "method",
                    "define": "getTimeSpeed()",
                    "detail": " Get current animation speed. \n"
                },
                "clearFrameEndCallFuncs": {
                    "type": "method",
                    "define": "clearFrameEndCallFuncs()"
                },
                "removeFrameEndCallFuncs": {
                    "type": "method",
                    "define": "removeFrameEndCallFuncs(${1:#int frameIndex})"
                },
                "addAnimationInfo": {
                    "type": "method",
                    "define": "addAnimationInfo(${1:#ccs.AnimationInfo animationInfo})",
                    "detail": " AnimationInfo\n"
                },
                "clearLastFrameCallFunc": {
                    "type": "method",
                    "define": "clearLastFrameCallFunc()"
                },
                "getTimelines": {
                    "type": "method",
                    "define": "getTimelines()"
                },
                "getEndFrame": {
                    "type": "method",
                    "define": "getEndFrame()",
                    "detail": " End frame of this action.\nWhen action play to this frame, if action is not loop, then it will stop, \nor it will play from start frame again. \n"
                },
                "getStartFrame": {
                    "type": "method",
                    "define": "getStartFrame()",
                    "detail": " Start frame index of this action\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "getDuration": {
                    "type": "method",
                    "define": "getDuration()"
                },
                "removeFrameEndCallFunc": {
                    "type": "method",
                    "define": "removeFrameEndCallFunc(${1:#int frameIndex},${2:#string funcKey})"
                },
                "resume": {
                    "type": "method",
                    "define": "resume()",
                    "detail": " Resume the animation. \n"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "removeTimeline": {
                    "type": "method",
                    "define": "removeTimeline(${1:#ccs.Timeline timeline})"
                },
                "addTimeline": {
                    "type": "method",
                    "define": "addTimeline(${1:#ccs.Timeline timeline})",
                    "detail": " add Timeline to ActionTimeline \n"
                },
                "gotoFrameAndPause": {
                    "type": "method",
                    "define": "gotoFrameAndPause(${1:#int startIndex})",
                    "detail": " Goto the specified frame index, and pause at this index.\nparam startIndex The animation will pause at this index.\n"
                },
                "setLastFrameCallFunc": {
                    "type": "method",
                    "define": "setLastFrameCallFunc(${1:#function listener})",
                    "detail": " Last frame callback will call when arriving last frame \n"
                },
                "setCurrentFrame": {
                    "type": "method",
                    "define": "setCurrentFrame(${1:#int frameIndex})",
                    "detail": " Set current frame index, this will cause action plays to this frame. \n"
                },
                "removeAnimationInfo": {
                    "type": "method",
                    "define": "removeAnimationInfo(${1:#string animationName})"
                },
                "play": {
                    "type": "method",
                    "define": "play(${1:#string animationName},${2:#bool loop})"
                },
                "setTimeSpeed": {
                    "type": "method",
                    "define": "setTimeSpeed(${1:#float speed})",
                    "detail": " Set the animation speed, this will speed up or slow down the speed. \n"
                },
                "setDuration": {
                    "type": "method",
                    "define": "setDuration(${1:#int duration})",
                    "detail": " duration of the whole action\n"
                },
                "isPlaying": {
                    "type": "method",
                    "define": "isPlaying()",
                    "detail": " Whether or not Action is playing. \n"
                },
                "getCurrentFrame": {
                    "type": "method",
                    "define": "getCurrentFrame()",
                    "detail": " Get current frame. \n"
                },
                "addFrameEndCallFunc": {
                    "type": "method",
                    "define": "addFrameEndCallFunc(${1:#int frameIndex},${2:#string funcKey},${3:#function func})",
                    "detail": " add a callback function after played frameIndex\nparam frameIndex the frame index call back after\nparam funcKey for identity the callback function\nparam func the callback function\n"
                },
                "setAnimationEndCallFunc": {
                    "type": "method",
                    "define": "setAnimationEndCallFunc(${1:#string animationName},${2:#function func})",
                    "detail": "add a frame end call back to animation's end frame\nparam animationName  @addFrameEndCallFunc, make the animationName as funcKey\nparam func the callback function\n"
                },
                "clearFrameEventCallFunc": {
                    "type": "method",
                    "define": "clearFrameEventCallFunc()"
                }
            },
            "ComRender": {
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "setNode": {
                    "type": "method",
                    "define": "setNode(${1:#cc.Node node})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node node},${2:#char comName})",
                    "detail": "@overload self, cc.Node, char         \n@overload self         \n"
                },
                "getNode": {
                    "type": "method",
                    "define": "getNode()"
                }
            },
            "1": "registerTriggerClass",
            "TriggerMng": [
                "add",
                "create",
                "ctor",
                "destroyInstance",
                "get",
                "getInstance",
                "getTriggerObj",
                "isEmpty",
                "new",
                "parse",
                "remove",
                "removeAll",
                "removeObjByEvent",
                "removeTriggerObj",
                "triggerMngVersion"
            ],
            "TextureData": {
                "1": "new",
                "addContourData": {
                    "type": "method",
                    "define": "addContourData(${1:#ccs.ContourData contourData})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getContourData": {
                    "type": "method",
                    "define": "getContourData(${1:#int index})"
                }
            },
            "ActionTintFrame": {
                "1": "new",
                "getAction": {
                    "type": "method",
                    "define": "getAction(${1:#float duration})",
                    "detail": "Gets the ActionInterval of ActionFrame.\nparam duration   the duration time of ActionFrame\nreturn ActionInterval\n"
                },
                "getColor": {
                    "type": "method",
                    "define": "getColor()",
                    "detail": "Gets the tint action color.\nreturn the tint action color.\n"
                },
                "setColor": {
                    "type": "method",
                    "define": "setColor(${1:#color3b_table ccolor})",
                    "detail": "Changes the tint action color.\nparam ccolor the tint action color\n"
                }
            },
            "TInfo": [
                "_className",
                "create",
                "ctor",
                "new"
            ],
            "BoneData": {
                "1": "new",
                "addDisplayData": {
                    "type": "method",
                    "define": "addDisplayData(${1:#ccs.DisplayData displayData})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getDisplayData": {
                    "type": "method",
                    "define": "getDisplayData(${1:#int index})"
                }
            },
            "ParticleDisplayData": {
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "1": "new"
            },
            "ComController": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                }
            },
            "BoneNode": {
                "1": "new",
                "getDebugDrawLength": {
                    "type": "method",
                    "define": "getDebugDrawLength()"
                },
                "getRootSkeletonNode": {
                    "type": "method",
                    "define": "getRootSkeletonNode()"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "getSkins": {
                    "type": "method",
                    "define": "getSkins()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#int length})",
                    "detail": "@overload self, int         \n@overload self         \n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                },
                "setDebugDrawLength": {
                    "type": "method",
                    "define": "setDebugDrawLength(${1:#float length})"
                },
                "getDebugDrawWidth": {
                    "type": "method",
                    "define": "getDebugDrawWidth()"
                },
                "getAllSubSkins": {
                    "type": "method",
                    "define": "getAllSubSkins()",
                    "detail": "brief: get all skins in this bone tree\n"
                },
                "getChildBones": {
                    "type": "method",
                    "define": "getChildBones()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "getVisibleSkins": {
                    "type": "method",
                    "define": "getVisibleSkins()"
                },
                "setDebugDrawEnabled": {
                    "type": "method",
                    "define": "setDebugDrawEnabled(${1:#bool isDebugDraw})"
                },
                "getDebugDrawColor": {
                    "type": "method",
                    "define": "getDebugDrawColor()"
                },
                "addSkin": {
                    "type": "method",
                    "define": "addSkin(${1:#cc.Node skin},${2:#bool display},${3:#bool hideOthers})",
                    "detail": "@overload self, cc.Node, bool, bool         \n@overload self, cc.Node, bool         \n"
                },
                "setDebugDrawColor": {
                    "type": "method",
                    "define": "setDebugDrawColor(${1:#color4f_table color})"
                },
                "isDebugDrawEnabled": {
                    "type": "method",
                    "define": "isDebugDrawEnabled()"
                },
                "setDebugDrawWidth": {
                    "type": "method",
                    "define": "setDebugDrawWidth(${1:#float width})"
                },
                "getAllSubBones": {
                    "type": "method",
                    "define": "getAllSubBones()",
                    "detail": "brief: get all bones in this bone tree\n"
                },
                "displaySkin": {
                    "type": "method",
                    "define": "displaySkin(${1:#cc.Node skin},${2:#bool hideOthers})",
                    "detail": "@overload self, string, bool         \n@overload self, cc.Node, bool         \n"
                },
                "getVisibleSkinsRect": {
                    "type": "method",
                    "define": "getVisibleSkinsRect()",
                    "detail": "get displayings rect in self transform\n"
                }
            },
            "ActionRotationFrame": {
                "1": "new",
                "getAction": {
                    "type": "method",
                    "define": "getAction(${1:#float duration},${2:#ccs.ActionFrame srcFrame})",
                    "detail": "@overload self, float, ccs.ActionFrame         \n@overload self, float         \n"
                },
                "setRotation": {
                    "type": "method",
                    "define": "setRotation(${1:#float rotation})",
                    "detail": "Changes rotate action rotation.\nparam rotation rotate action rotation.\n"
                },
                "getRotation": {
                    "type": "method",
                    "define": "getRotation()",
                    "detail": "Gets the rotate action rotation.\nreturn the rotate action rotation.\n"
                }
            },
            "ArmatureDataManager": {
                "1": "addArmatureFileInfoAsync",
                "removeAnimationData": {
                    "type": "method",
                    "define": "removeAnimationData(${1:#string id})",
                    "detail": "brief    remove animation data\nparam     id the id of the animation data\n"
                },
                "addArmatureData": {
                    "type": "method",
                    "define": "addArmatureData(${1:#string id},${2:#ccs.ArmatureData armatureData},${3:#string configFilePath})",
                    "detail": "Add armature data\nparam id The id of the armature data\nparam armatureData ArmatureData *\n"
                },
                "addTextureData": {
                    "type": "method",
                    "define": "addTextureData(${1:#string id},${2:#ccs.TextureData textureData},${3:#string configFilePath})",
                    "detail": "brief    add texture data\nparam     id the id of the texture data\nreturn TextureData *\n"
                },
                "addSpriteFrameFromFile": {
                    "type": "method",
                    "define": "addSpriteFrameFromFile(${1:#string plistPath},${2:#string imagePath},${3:#string configFilePath})",
                    "detail": "brief    Add sprite frame to CCSpriteFrameCache, it will save display name and it's relative image name\n"
                },
                "removeArmatureFileInfo": {
                    "type": "method",
                    "define": "removeArmatureFileInfo(${1:#string configFilePath})"
                },
                "getArmatureDatas": {
                    "type": "method",
                    "define": "getArmatureDatas()"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": "Init ArmatureDataManager\n"
                },
                "addAnimationData": {
                    "type": "method",
                    "define": "addAnimationData(${1:#string id},${2:#ccs.AnimationData animationData},${3:#string configFilePath})",
                    "detail": "brief    add animation data\nparam     id the id of the animation data\nreturn AnimationData *\n"
                },
                "getAnimationDatas": {
                    "type": "method",
                    "define": "getAnimationDatas()"
                },
                "removeTextureData": {
                    "type": "method",
                    "define": "removeTextureData(${1:#string id})",
                    "detail": "brief    remove texture data\nparam     id the id of the texture data you want to get\n"
                },
                "addArmatureFileInfo": {
                    "type": "method",
                    "define": "addArmatureFileInfo(${1:#string imagePath},${2:#string plistPath},${3:#string configFilePath})",
                    "detail": "@overload self, string, string, string         \n@overload self, string         \n"
                },
                "isAutoLoadSpriteFile": {
                    "type": "method",
                    "define": "isAutoLoadSpriteFile()",
                    "detail": "brief    Judge whether or not need auto load sprite file\n"
                },
                "removeArmatureData": {
                    "type": "method",
                    "define": "removeArmatureData(${1:#string id})",
                    "detail": "brief    remove armature data\nparam    id the id of the armature data you want to get\n"
                },
                "getAnimationData": {
                    "type": "method",
                    "define": "getAnimationData(${1:#string id})",
                    "detail": "brief    get animation data from _animationDatas(Dictionary)\nparam     id the id of the animation data you want to get\nreturn AnimationData *\n"
                },
                "getArmatureData": {
                    "type": "method",
                    "define": "getArmatureData(${1:#string id})",
                    "detail": "brief    get armature data\nparam    id the id of the armature data you want to get\nreturn    ArmatureData *\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()"
                },
                "getTextureData": {
                    "type": "method",
                    "define": "getTextureData(${1:#string id})",
                    "detail": "brief    get texture data\nparam     id the id of the texture data you want to get\nreturn TextureData *\n"
                },
                "getTextureDatas": {
                    "type": "method",
                    "define": "getTextureDatas()"
                }
            },
            "SkewFrame": {
                "1": "new",
                "getSkewX": {
                    "type": "method",
                    "define": "getSkewX()"
                },
                "getSkewY": {
                    "type": "method",
                    "define": "getSkewY()"
                },
                "setSkewX": {
                    "type": "method",
                    "define": "setSkewX(${1:#float skewx})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setSkewY": {
                    "type": "method",
                    "define": "setSkewY(${1:#float skewy})"
                }
            },
            "MovementBoneData": {
                "1": "new",
                "getFrameData": {
                    "type": "method",
                    "define": "getFrameData(${1:#int index})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "addFrameData": {
                    "type": "method",
                    "define": "addFrameData(${1:#ccs.FrameData frameData})"
                }
            },
            "DisplayManager": {
                "1": "new",
                "changeDisplayWithName": {
                    "type": "method",
                    "define": "changeDisplayWithName(${1:#string name},${2:#bool force})"
                },
                "removeDisplay": {
                    "type": "method",
                    "define": "removeDisplay(${1:#int index})"
                },
                "changeDisplayWithIndex": {
                    "type": "method",
                    "define": "changeDisplayWithIndex(${1:#int index},${2:#bool force})",
                    "detail": "Change display by index. You can just use this method to change display in the display list.\nThe display list is just used for this bone, and it is the displays you may use in every frame.\nNote : if index is the same with prev index, the method will not effect\nparam index The index of the display you want to change\nparam force If true, then force change display to specified display, or current display will set to  display index edit in the flash every key frame.\n"
                },
                "addDisplay": {
                    "type": "method",
                    "define": "addDisplay(${1:#ccs.DisplayData displayData},${2:#int index})",
                    "detail": "@overload self, cc.Node, int         \n@overload self, ccs.DisplayData, int         \n"
                },
                "isVisible": {
                    "type": "method",
                    "define": "isVisible()",
                    "detail": "Determines if the display is visible\nsee setVisible(bool)\nreturn true if the node is visible, false if the node is hidden.\n"
                },
                "containPoint": {
                    "type": "method",
                    "define": "containPoint(${1:#float x},${2:#float y})",
                    "detail": "@overload self, float, float         \n@overload self, vec2_table         \n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#ccs.Bone bone})"
                },
                "getContentSize": {
                    "type": "method",
                    "define": "getContentSize()"
                },
                "getAnchorPoint": {
                    "type": "method",
                    "define": "getAnchorPoint()"
                },
                "isForceChangeDisplay": {
                    "type": "method",
                    "define": "isForceChangeDisplay()"
                },
                "setVisible": {
                    "type": "method",
                    "define": "setVisible(${1:#bool visible})",
                    "detail": "Sets whether the display is visible\nThe default value is true, a node is default to visible\nparam visible   true if the node is visible, false if the node is hidden.\n"
                },
                "setForceChangeDisplay": {
                    "type": "method",
                    "define": "setForceChangeDisplay(${1:#bool force})"
                },
                "getAnchorPointInPoints": {
                    "type": "method",
                    "define": "getAnchorPointInPoints()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#ccs.Bone bone})"
                },
                "getDecorativeDisplayList": {
                    "type": "method",
                    "define": "getDecorativeDisplayList()"
                },
                "getCurrentDisplayIndex": {
                    "type": "method",
                    "define": "getCurrentDisplayIndex()"
                },
                "getBoundingBox": {
                    "type": "method",
                    "define": "getBoundingBox()"
                },
                "getDisplayRenderNode": {
                    "type": "method",
                    "define": "getDisplayRenderNode()"
                },
                "getDisplayRenderNodeType": {
                    "type": "method",
                    "define": "getDisplayRenderNodeType()"
                }
            },
            "ComAttribute": {
                "getFloat": {
                    "type": "method",
                    "define": "getFloat(${1:#string key},${2:#float def})"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getInt": {
                    "type": "method",
                    "define": "getInt(${1:#string key},${2:#int def})"
                },
                "setInt": {
                    "type": "method",
                    "define": "setInt(${1:#string key},${2:#int value})"
                },
                "getString": {
                    "type": "method",
                    "define": "getString(${1:#string key},${2:#string def})"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string key},${2:#string value})"
                },
                "parse": {
                    "type": "method",
                    "define": "parse(${1:#string jsonFile})"
                },
                "setFloat": {
                    "type": "method",
                    "define": "setFloat(${1:#string key},${2:#float value})"
                },
                "setBool": {
                    "type": "method",
                    "define": "setBool(${1:#string key},${2:#bool value})"
                },
                "getBool": {
                    "type": "method",
                    "define": "getBool(${1:#string key},${2:#bool def})"
                }
            },
            "Bone": {
                "1": "getIgnoreMovementBoneData",
                "2": "new",
                "3": "setIgnoreMovementBoneData",
                "changeDisplayWithName": {
                    "type": "method",
                    "define": "changeDisplayWithName(${1:#string name},${2:#bool force})"
                },
                "setBoneData": {
                    "type": "method",
                    "define": "setBoneData(${1:#ccs.BoneData boneData})"
                },
                "removeFromParent": {
                    "type": "method",
                    "define": "removeFromParent(${1:#bool recursion})",
                    "detail": "Remove itself from its parent.\nparam recursion    whether or not to remove childBone's display\n"
                },
                "changeDisplayWithIndex": {
                    "type": "method",
                    "define": "changeDisplayWithIndex(${1:#int index},${2:#bool force})"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                },
                "getDisplayRenderNode": {
                    "type": "method",
                    "define": "getDisplayRenderNode()"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": "Initializes an empty Bone with nothing init.\n"
                },
                "isIgnoreMovementBoneData": {
                    "type": "method",
                    "define": "isIgnoreMovementBoneData()"
                },
                "getTween": {
                    "type": "method",
                    "define": "getTween()"
                },
                "getDisplayManager": {
                    "type": "method",
                    "define": "getDisplayManager()"
                },
                "isTransformDirty": {
                    "type": "method",
                    "define": "isTransformDirty()"
                },
                "getColliderDetector": {
                    "type": "method",
                    "define": "getColliderDetector()"
                },
                "getTweenData": {
                    "type": "method",
                    "define": "getTweenData()"
                },
                "isBlendDirty": {
                    "type": "method",
                    "define": "isBlendDirty()"
                },
                "removeDisplay": {
                    "type": "method",
                    "define": "removeDisplay(${1:#int index})"
                },
                "removeChildBone": {
                    "type": "method",
                    "define": "removeChildBone(${1:#ccs.Bone bone},${2:#bool recursion})",
                    "detail": "Removes a child Bone\nparam     bone   the bone you want to remove\n"
                },
                "addDisplay": {
                    "type": "method",
                    "define": "addDisplay(${1:#ccs.DisplayData displayData},${2:#int index})",
                    "detail": "@overload self, cc.Node, int         \n@overload self, ccs.DisplayData, int         \n"
                },
                "setArmature": {
                    "type": "method",
                    "define": "setArmature(${1:#ccs.Armature armature})"
                },
                "addChildBone": {
                    "type": "method",
                    "define": "addChildBone(${1:#ccs.Bone child})",
                    "detail": "Add a child to this bone, and it will let this child call setParent(Bone *parent) function to set self to it's parent\nparam     child  the child you want to add\n"
                },
                "updateZOrder": {
                    "type": "method",
                    "define": "updateZOrder()",
                    "detail": " Update zorder\n"
                },
                "updateColor": {
                    "type": "method",
                    "define": "updateColor()",
                    "detail": " Update color to render display\n"
                },
                "getNodeToArmatureTransform": {
                    "type": "method",
                    "define": "getNodeToArmatureTransform()"
                },
                "setChildArmature": {
                    "type": "method",
                    "define": "setChildArmature(${1:#ccs.Armature childArmature})"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "getBoneData": {
                    "type": "method",
                    "define": "getBoneData()"
                },
                "getWorldInfo": {
                    "type": "method",
                    "define": "getWorldInfo()"
                },
                "setTransformDirty": {
                    "type": "method",
                    "define": "setTransformDirty(${1:#bool dirty})"
                },
                "getChildArmature": {
                    "type": "method",
                    "define": "getChildArmature()"
                },
                "getParentBone": {
                    "type": "method",
                    "define": "getParentBone()",
                    "detail": "Get parent bone\nreturn parent bone\n"
                },
                "setBlendDirty": {
                    "type": "method",
                    "define": "setBlendDirty(${1:#bool dirty})"
                },
                "getArmature": {
                    "type": "method",
                    "define": "getArmature()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string name})",
                    "detail": "@overload self, string         \n@overload self         \n"
                },
                "setParentBone": {
                    "type": "method",
                    "define": "setParentBone(${1:#ccs.Bone parent})",
                    "detail": "Set parent bone.\nIf parent is null, then also remove this bone from armature.\nIt will not set the Armature, if you want to add the bone to a Armature, you should use Armature::addBone(Bone *bone, const char* parentName).\nparam parent  the parent bone.\nnullptr : remove this bone from armature\n"
                },
                "getDisplayRenderNodeType": {
                    "type": "method",
                    "define": "getDisplayRenderNodeType()"
                }
            },
            "GUIReader": {
                "getFilePath": {
                    "type": "method",
                    "define": "getFilePath()"
                },
                "widgetFromBinaryFile": {
                    "type": "method",
                    "define": "widgetFromBinaryFile(${1:#char fileName})"
                },
                "getVersionInteger": {
                    "type": "method",
                    "define": "getVersionInteger(${1:#char str})"
                },
                "setFilePath": {
                    "type": "method",
                    "define": "setFilePath(${1:#string strFilePath})"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()"
                },
                "widgetFromJsonFile": {
                    "type": "method",
                    "define": "widgetFromJsonFile(${1:#char fileName})"
                }
            },
            "MovementData": {
                "getMovementBoneData": {
                    "type": "method",
                    "define": "getMovementBoneData(${1:#string boneName})"
                },
                "1": "new",
                "addMovementBoneData": {
                    "type": "method",
                    "define": "addMovementBoneData(${1:#ccs.MovementBoneData movBoneData})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                }
            },
            "Timeline": {
                "stepToFrame": {
                    "type": "method",
                    "define": "stepToFrame(${1:#int frameIndex})"
                },
                "getFrames": {
                    "type": "method",
                    "define": "getFrames()"
                },
                "setActionTag": {
                    "type": "method",
                    "define": "setActionTag(${1:#int tag})"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()"
                },
                "setNode": {
                    "type": "method",
                    "define": "setNode(${1:#cc.Node node})"
                },
                "getNode": {
                    "type": "method",
                    "define": "getNode()"
                },
                "setActionTimeline": {
                    "type": "method",
                    "define": "setActionTimeline(${1:#ccs.ActionTimeline action})"
                },
                "gotoFrame": {
                    "type": "method",
                    "define": "gotoFrame(${1:#int frameIndex})"
                },
                "removeFrame": {
                    "type": "method",
                    "define": "removeFrame(${1:#ccs.Frame frame})"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getActionTimeline": {
                    "type": "method",
                    "define": "getActionTimeline()"
                },
                "insertFrame": {
                    "type": "method",
                    "define": "insertFrame(${1:#ccs.Frame frame},${2:#int index})"
                },
                "getActionTag": {
                    "type": "method",
                    "define": "getActionTag()"
                },
                "addFrame": {
                    "type": "method",
                    "define": "addFrame(${1:#ccs.Frame frame})"
                }
            },
            "ArmatureAnimation": {
                "1": "new",
                "2": "setFrameEventCallFunc",
                "getSpeedScale": {
                    "type": "method",
                    "define": "getSpeedScale()"
                },
                "playWithIndex": {
                    "type": "method",
                    "define": "playWithIndex(${1:#int animationIndex},${2:#int durationTo},${3:#int loop})"
                },
                "play": {
                    "type": "method",
                    "define": "play(${1:#string animationName},${2:#int durationTo},${3:#int loop})",
                    "detail": "Play animation by animation name.\nparam  animationName  The animation name you want to play\nparam  durationTo The frames between two animation changing-over.\nIt's meaning is changing to this animation need how many frames\n-1 : use the value from MovementData get from flash design panel\nparam  loop   Whether the animation is loop\nloop < 0 : use the value from MovementData get from flash design panel\nloop = 0 : this animation is not loop\nloop > 0 : this animation is loop\n"
                },
                "setSpeedScale": {
                    "type": "method",
                    "define": "setSpeedScale(${1:#float speedScale})",
                    "detail": "Scale animation play speed.\nparam animationScale Scale value\n"
                },
                "gotoAndPause": {
                    "type": "method",
                    "define": "gotoAndPause(${1:#int frameIndex})",
                    "detail": "Go to specified frame and pause current movement.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#ccs.Armature armature})",
                    "detail": "Create with a Armature\nparam armature The Armature ArmatureAnimation will bind to\n"
                },
                "gotoAndPlay": {
                    "type": "method",
                    "define": "gotoAndPlay(${1:#int frameIndex})",
                    "detail": "Go to specified frame and play current movement.\nYou need first switch to the movement you want to play, then call this function.\nexample : playByIndex(0);\ngotoAndPlay(0);\nplayByIndex(1);\ngotoAndPlay(0);\ngotoAndPlay(15);\n"
                },
                "playWithNames": {
                    "type": "method",
                    "define": "playWithNames(${1:#array_table movementNames},${2:#int durationTo},${3:#bool loop})"
                },
                "playWithIndexes": {
                    "type": "method",
                    "define": "playWithIndexes(${1:#array_table movementIndexes},${2:#int durationTo},${3:#bool loop})"
                },
                "getAnimationData": {
                    "type": "method",
                    "define": "getAnimationData()"
                },
                "3": "setMovementEventCallFunc",
                "getCurrentMovementID": {
                    "type": "method",
                    "define": "getCurrentMovementID()",
                    "detail": "Get current movementID\nreturn The name of current movement\n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#ccs.Armature armature})",
                    "detail": "Init with a Armature\nparam armature The Armature ArmatureAnimation will bind to\n"
                },
                "setAnimationData": {
                    "type": "method",
                    "define": "setAnimationData(${1:#ccs.AnimationData data})"
                },
                "getMovementCount": {
                    "type": "method",
                    "define": "getMovementCount()",
                    "detail": "Get movement count\n"
                }
            },
            "MovementEventType": [
                "complete",
                "loopComplete",
                "start"
            ],
            "Skin": {
                "getNodeToWorldTransformAR": {
                    "type": "method",
                    "define": "getNodeToWorldTransformAR()"
                },
                "setBone": {
                    "type": "method",
                    "define": "setBone(${1:#ccs.Bone bone})"
                },
                "getDisplayName": {
                    "type": "method",
                    "define": "getDisplayName()"
                },
                "createWithSpriteFrameName": {
                    "type": "method",
                    "define": "createWithSpriteFrameName(${1:#string pszSpriteFrameName})"
                },
                "updateArmatureTransform": {
                    "type": "method",
                    "define": "updateArmatureTransform()"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#string pszFileName})",
                    "detail": "@overload self, string         \n@overload self         \n"
                },
                "getBone": {
                    "type": "method",
                    "define": "getBone()"
                }
            },
            "ScaleFrame": {
                "1": "new",
                "getScaleX": {
                    "type": "method",
                    "define": "getScaleX()"
                },
                "getScaleY": {
                    "type": "method",
                    "define": "getScaleY()"
                },
                "setScale": {
                    "type": "method",
                    "define": "setScale(${1:#float scale})"
                },
                "setScaleX": {
                    "type": "method",
                    "define": "setScaleX(${1:#float scaleX})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setScaleY": {
                    "type": "method",
                    "define": "setScaleY(${1:#float scaleY})"
                }
            },
            "InnerActionType": [
                "LoopAction",
                "NoLoopAction",
                "SingleFrame"
            ],
            "ActionTimelineData": {
                "1": "new",
                "setActionTag": {
                    "type": "method",
                    "define": "setActionTag(${1:#int actionTag})"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#int actionTag})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#int actionTag})"
                },
                "getActionTag": {
                    "type": "method",
                    "define": "getActionTag()"
                }
            },
            "ArmatureDisplayData": {
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "1": "new"
            },
            "AnimationData": {
                "1": "new",
                "addMovement": {
                    "type": "method",
                    "define": "addMovement(${1:#ccs.MovementData movData})"
                },
                "getMovement": {
                    "type": "method",
                    "define": "getMovement(${1:#string movementName})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getMovementCount": {
                    "type": "method",
                    "define": "getMovementCount()"
                }
            },
            "RotationFrame": {
                "1": "new",
                "setRotation": {
                    "type": "method",
                    "define": "setRotation(${1:#float rotation})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getRotation": {
                    "type": "method",
                    "define": "getRotation()"
                }
            },
            "ActionFrame": {
                "1": "new",
                "getFrameIndex": {
                    "type": "method",
                    "define": "getFrameIndex()",
                    "detail": "Gets the index of action frame\nreturn the index of action frame\n"
                },
                "getAction": {
                    "type": "method",
                    "define": "getAction(${1:#float duration},${2:#ccs.ActionFrame srcFrame})",
                    "detail": "@overload self, float, ccs.ActionFrame         \n@overload self, float         \n"
                },
                "getEasingType": {
                    "type": "method",
                    "define": "getEasingType()",
                    "detail": "Gets the easing type.\nreturn the easing type.\n"
                },
                "setEasingType": {
                    "type": "method",
                    "define": "setEasingType(${1:#int easingType})",
                    "detail": "Changes the easing type.\nparam easingType the easing type.\n"
                },
                "setFrameIndex": {
                    "type": "method",
                    "define": "setFrameIndex(${1:#int index})",
                    "detail": "Changes the index of action frame\nparam index   the index of action frame\n"
                },
                "getFrameType": {
                    "type": "method",
                    "define": "getFrameType()",
                    "detail": "Gets the type of action frame\nreturn the type of action frame\n"
                },
                "getFrameTime": {
                    "type": "method",
                    "define": "getFrameTime()",
                    "detail": "Gets the time of action frame\nreturn fTime  the time of action frame\n"
                },
                "setFrameType": {
                    "type": "method",
                    "define": "setFrameType(${1:#int frameType})",
                    "detail": "Changes the type of action frame\nparam frameType   the type of action frame\n"
                },
                "setFrameTime": {
                    "type": "method",
                    "define": "setFrameTime(${1:#float fTime})",
                    "detail": "Changes the time of action frame\nparam fTime  the time of action frame\n"
                },
                "setEasingParameter": {
                    "type": "method",
                    "define": "setEasingParameter(${1:#array_table parameter})",
                    "detail": "Set the ActionInterval easing parameter.\nparam parameter   the parameter for frame ease\n"
                }
            },
            "TextureFrame": {
                "1": "new",
                "getTextureName": {
                    "type": "method",
                    "define": "getTextureName()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setTextureName": {
                    "type": "method",
                    "define": "setTextureName(${1:#string textureName})"
                }
            },
            "ActionTimelineNode": {
                "1": "new",
                "setActionTimeline": {
                    "type": "method",
                    "define": "setActionTimeline(${1:#ccs.ActionTimeline action})"
                },
                "getRoot": {
                    "type": "method",
                    "define": "getRoot()"
                },
                "getActionTimeline": {
                    "type": "method",
                    "define": "getActionTimeline()"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node root},${2:#ccs.ActionTimeline action})"
                },
                "setRoot": {
                    "type": "method",
                    "define": "setRoot(${1:#cc.Node root})"
                }
            },
            "Armature": {
                "1": "new",
                "getBatchNode": {
                    "type": "method",
                    "define": "getBatchNode()"
                },
                "setAnimation": {
                    "type": "method",
                    "define": "setAnimation(${1:#ccs.ArmatureAnimation animation})"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "js NA\nlua NA\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string name},${2:#ccs.Bone parentBone})",
                    "detail": "@overload self, string         \n@overload self         \n@overload self, string, ccs.Bone         \n"
                },
                "removeBone": {
                    "type": "method",
                    "define": "removeBone(${1:#ccs.Bone bone},${2:#bool recursion})",
                    "detail": "Remove a bone with the specified name. If recursion it will also remove child Bone recursionly.\nparam bone The bone you want to remove\nparam recursion Determine whether remove the bone's child  recursion.\n"
                },
                "updateOffsetPoint": {
                    "type": "method",
                    "define": "updateOffsetPoint()",
                    "detail": "Set contentsize and Calculate anchor point.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": "Init the empty armature\n"
                },
                "getBoneAtPoint": {
                    "type": "method",
                    "define": "getBoneAtPoint(${1:#float x},${2:#float y})"
                },
                "getVersion": {
                    "type": "method",
                    "define": "getVersion()"
                },
                "setVersion": {
                    "type": "method",
                    "define": "setVersion(${1:#float version})"
                },
                "getArmatureTransformDirty": {
                    "type": "method",
                    "define": "getArmatureTransformDirty()"
                },
                "setArmatureData": {
                    "type": "method",
                    "define": "setArmatureData(${1:#ccs.ArmatureData armatureData})"
                },
                "setBatchNode": {
                    "type": "method",
                    "define": "setBatchNode(${1:#ccs.BatchNode batchNode})"
                },
                "getBoneDic": {
                    "type": "method",
                    "define": "getBoneDic()",
                    "detail": "Get Armature's bone dictionary\nreturn Armature's bone dictionary\n"
                },
                "getArmatureData": {
                    "type": "method",
                    "define": "getArmatureData()"
                },
                "getOffsetPoints": {
                    "type": "method",
                    "define": "getOffsetPoints()"
                },
                "addBone": {
                    "type": "method",
                    "define": "addBone(${1:#ccs.Bone bone},${2:#string parentName})",
                    "detail": "Add a Bone to this Armature,\nparam bone  The Bone you want to add to Armature\nparam parentName   The parent Bone's name you want to add to . If it's  nullptr, then set Armature to its parent\n"
                },
                "getParentBone": {
                    "type": "method",
                    "define": "getParentBone()"
                },
                "getAnimation": {
                    "type": "method",
                    "define": "getAnimation()"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "js NA\nlua NA\n"
                },
                "changeBoneParent": {
                    "type": "method",
                    "define": "changeBoneParent(${1:#ccs.Bone bone},${2:#string parentName})",
                    "detail": "Change a bone's parent with the specified parent name.\nparam bone The bone you want to change parent\nparam parentName The new parent's name.\n"
                },
                "setParentBone": {
                    "type": "method",
                    "define": "setParentBone(${1:#ccs.Bone parentBone})"
                },
                "getBone": {
                    "type": "method",
                    "define": "getBone(${1:#string name})",
                    "detail": "Get a bone with the specified name\nparam name The bone's name you want to get\n"
                }
            },
            "AnchorPointFrame": {
                "1": "new",
                "setAnchorPoint": {
                    "type": "method",
                    "define": "setAnchorPoint(${1:#vec2_table point})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getAnchorPoint": {
                    "type": "method",
                    "define": "getAnchorPoint()"
                }
            },
            "PositionFrame": {
                "1": "new",
                "setY": {
                    "type": "method",
                    "define": "setY(${1:#float y})"
                },
                "setX": {
                    "type": "method",
                    "define": "setX(${1:#float x})"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#vec2_table position})"
                },
                "getX": {
                    "type": "method",
                    "define": "getX()"
                },
                "getY": {
                    "type": "method",
                    "define": "getY()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getPosition": {
                    "type": "method",
                    "define": "getPosition()"
                }
            },
            "ArmatureData": {
                "1": "new",
                "addBoneData": {
                    "type": "method",
                    "define": "addBoneData(${1:#ccs.BoneData boneData})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getBoneData": {
                    "type": "method",
                    "define": "getBoneData(${1:#string boneName})"
                }
            },
            "ZOrderFrame": {
                "1": "new",
                "setZOrder": {
                    "type": "method",
                    "define": "setZOrder(${1:#int zorder})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getZOrder": {
                    "type": "method",
                    "define": "getZOrder()"
                }
            },
            "ActionScaleFrame": {
                "1": "new",
                "getScaleX": {
                    "type": "method",
                    "define": "getScaleX()",
                    "detail": "Gets the scale action scaleX.\nreturn the scale action scaleX.\n"
                },
                "getScaleY": {
                    "type": "method",
                    "define": "getScaleY()",
                    "detail": "Gets the scale action scaleY.\nreturn the scale action scaleY.\n"
                },
                "setScaleX": {
                    "type": "method",
                    "define": "setScaleX(${1:#float scaleX})",
                    "detail": "Changes the scale action scaleX.\nparam the scale action scaleX.\n"
                },
                "getAction": {
                    "type": "method",
                    "define": "getAction(${1:#float duration})",
                    "detail": "Gets the ActionInterval of ActionFrame.\nparam duration   the duration time of ActionFrame\nreturn ActionInterval\n"
                },
                "setScaleY": {
                    "type": "method",
                    "define": "setScaleY(${1:#float scaleY})",
                    "detail": "Changes the scale action scaleY.\nparam rotation the scale action scaleY.\n"
                }
            },
            "RotationSkewFrame": {
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "1": "new"
            },
            "2": "sendTriggerEvent",
            "VisibleFrame": {
                "1": "new",
                "isVisible": {
                    "type": "method",
                    "define": "isVisible()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setVisible": {
                    "type": "method",
                    "define": "setVisible(${1:#bool visible})"
                }
            },
            "AlphaFrame": {
                "1": "new",
                "getAlpha": {
                    "type": "method",
                    "define": "getAlpha()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setAlpha": {
                    "type": "method",
                    "define": "setAlpha(${1:#unsigned char alpha})"
                }
            },
            "BaseData": {
                "1": "new",
                "setColor": {
                    "type": "method",
                    "define": "setColor(${1:#color4b_table color})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getColor": {
                    "type": "method",
                    "define": "getColor()"
                }
            },
            "ActionObject": {
                "1": "new",
                "stop": {
                    "type": "method",
                    "define": "stop()",
                    "detail": "Stop the action.\n"
                },
                "getCurrentTime": {
                    "type": "method",
                    "define": "getCurrentTime()",
                    "detail": "Gets the current time of frame.\nreturn the current time of frame\n"
                },
                "getLoop": {
                    "type": "method",
                    "define": "getLoop()",
                    "detail": "Gets if the action will loop play.\nreturn   that if the action will loop play\n"
                },
                "setCurrentTime": {
                    "type": "method",
                    "define": "setCurrentTime(${1:#float fTime})",
                    "detail": "Sets the current time of frame.\nparam fTime   the current time of frame\n"
                },
                "simulationActionUpdate": {
                    "type": "method",
                    "define": "simulationActionUpdate(${1:#float dt})"
                },
                "play": {
                    "type": "method",
                    "define": "play(${1:#cc.CallFunc func})",
                    "detail": "@overload self, cc.CallFunc         \n@overload self         \n"
                },
                "updateToFrameByTime": {
                    "type": "method",
                    "define": "updateToFrameByTime(${1:#float fTime})"
                },
                "removeActionNode": {
                    "type": "method",
                    "define": "removeActionNode(${1:#ccs.ActionNode node})",
                    "detail": "Removes a ActionNode which play the action.\nparam node    the ActionNode which play the action\n"
                },
                "getTotalTime": {
                    "type": "method",
                    "define": "getTotalTime()",
                    "detail": "Gets the total time of frame.\nreturn the total time of frame\n"
                },
                "pause": {
                    "type": "method",
                    "define": "pause()",
                    "detail": "Pause the action.\n"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()",
                    "detail": "Gets name of object\nreturn name of object\n"
                },
                "addActionNode": {
                    "type": "method",
                    "define": "addActionNode(${1:#ccs.ActionNode node})",
                    "detail": "Adds a ActionNode to play the action.\nparam node    the ActionNode which will play the action\n"
                },
                "getUnitTime": {
                    "type": "method",
                    "define": "getUnitTime()",
                    "detail": "Gets the time interval of frame.\nreturn the time interval of frame\n"
                },
                "isPlaying": {
                    "type": "method",
                    "define": "isPlaying()",
                    "detail": "Return if the action is playing.\nreturn true if the action is playing, false the otherwise\n"
                },
                "setLoop": {
                    "type": "method",
                    "define": "setLoop(${1:#bool bLoop})",
                    "detail": "Sets if the action will loop play.\nparam bLoop     that if the action will loop play\n"
                },
                "setName": {
                    "type": "method",
                    "define": "setName(${1:#char name})",
                    "detail": "Sets name for object\nparam name    name of object\n"
                },
                "setUnitTime": {
                    "type": "method",
                    "define": "setUnitTime(${1:#float fTime})",
                    "detail": "Sets the time interval of frame.\nparam fTime   the time interval of frame\n"
                }
            },
            "ComExtensionData": {
                "1": "new",
                "getCustomProperty": {
                    "type": "method",
                    "define": "getCustomProperty()"
                },
                "setActionTag": {
                    "type": "method",
                    "define": "setActionTag(${1:#int actionTag})"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "setCustomProperty": {
                    "type": "method",
                    "define": "setCustomProperty(${1:#string customProperty})"
                },
                "getActionTag": {
                    "type": "method",
                    "define": "getActionTag()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                }
            },
            "ActionManagerEx": {
                "playActionByName": {
                    "type": "method",
                    "define": "playActionByName(${1:#char jsonName},${2:#char actionName},${3:#cc.CallFunc func})",
                    "detail": "@overload self, char, char, cc.CallFunc         \n@overload self, char, char         \n"
                },
                "getStudioVersionNumber": {
                    "type": "method",
                    "define": "getStudioVersionNumber()"
                },
                "stopActionByName": {
                    "type": "method",
                    "define": "stopActionByName(${1:#char jsonName},${2:#char actionName})",
                    "detail": "Stop an Action with a name.\nparam jsonName  UI file name\nparam actionName  action name in the UIfile.\nreturn  ActionObject which named as the param name\n"
                },
                "releaseActions": {
                    "type": "method",
                    "define": "releaseActions()",
                    "detail": "Release all actions.\n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": "Purges ActionManager point.\njs purge\nlua destroyActionManager\n"
                },
                "getActionByName": {
                    "type": "method",
                    "define": "getActionByName(${1:#char jsonName},${2:#char actionName})",
                    "detail": "Gets an ActionObject with a name.\nparam jsonName  UI file name\nparam actionName  action name in the UI file.\nreturn  ActionObject which named as the param name\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "Gets the static instance of ActionManager.\njs getInstance\nlua getInstance\n"
                }
            },
            "ActionTimelineCache": {
                "1": "getInstance",
                "removeAction": {
                    "type": "method",
                    "define": "removeAction(${1:#string fileName})",
                    "detail": " Remove action with filename, and also remove other resource relate with this file \n"
                },
                "loadAnimationActionWithFlatBuffersFile": {
                    "type": "method",
                    "define": "loadAnimationActionWithFlatBuffersFile(${1:#string fileName})"
                },
                "createActionFromContent": {
                    "type": "method",
                    "define": "createActionFromContent(${1:#string fileName},${2:#string content})"
                },
                "createActionFromJson": {
                    "type": "method",
                    "define": "createActionFromJson(${1:#string fileName})",
                    "detail": " Clone a action with the specified name from the container. \n"
                },
                "loadAnimationActionWithContent": {
                    "type": "method",
                    "define": "loadAnimationActionWithContent(${1:#string fileName},${2:#string content})"
                },
                "loadAnimationActionWithFile": {
                    "type": "method",
                    "define": "loadAnimationActionWithFile(${1:#string fileName})"
                },
                "purge": {
                    "type": "method",
                    "define": "purge()"
                },
                "createAction": {
                    "type": "method",
                    "define": "createAction(${1:#string fileName})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": " Destroys the singleton \n"
                },
                "createActionWithFlatBuffersForSimulator": {
                    "type": "method",
                    "define": "createActionWithFlatBuffersForSimulator(${1:#string fileName})"
                },
                "createActionWithFlatBuffersFile": {
                    "type": "method",
                    "define": "createActionWithFlatBuffersFile(${1:#string fileName})"
                }
            },
            "BatchNode": {
                "create": {
                    "type": "method",
                    "define": "create()"
                }
            },
            "TriggerObj": [
                "_enable",
                "_id",
                "create",
                "ctor",
                "detect",
                "done",
                "extend",
                "getEvents",
                "getId",
                "init",
                "new",
                "removeAll",
                "serialize",
                "setEnable"
            ],
            "ObjectFactory": [
                "create",
                "createObject",
                "ctor",
                "destroyInstance",
                "getInstance",
                "new",
                "registerType"
            ],
            "Tween": {
                "1": "new",
                "play": {
                    "type": "method",
                    "define": "play(${1:#ccs.MovementBoneData movementBoneData},${2:#int durationTo},${3:#int durationTween},${4:#int loop},${5:#int tweenEasing})",
                    "detail": "Start the Process\nparam  movementBoneData  the MovementBoneData include all FrameData\nparam  durationTo the number of frames changing to this animation needs.\nparam  durationTween  the number of frames this animation actual last.\nparam  loop   whether the animation is loop\nloop < 0 : use the value from MovementData get from Action Editor\nloop = 0 : this animation is not loop\nloop > 0 : this animation is loop\nparam  tweenEasing    tween easing is used for calculate easing effect\nTWEEN_EASING_MAX : use the value from MovementData get from Action Editor\n-1 : fade out\n0  : line\n1  : fade in\n2  : fade in and out\n"
                },
                "setAnimation": {
                    "type": "method",
                    "define": "setAnimation(${1:#ccs.ArmatureAnimation animation})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#ccs.Bone bone})",
                    "detail": "Create with a Bone\nparam bone the Bone Tween will bind to\n"
                },
                "gotoAndPause": {
                    "type": "method",
                    "define": "gotoAndPause(${1:#int frameIndex})"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#ccs.Bone bone})",
                    "detail": "Init with a Bone\nparam bone the Bone Tween will bind to\n"
                },
                "getAnimation": {
                    "type": "method",
                    "define": "getAnimation()"
                },
                "gotoAndPlay": {
                    "type": "method",
                    "define": "gotoAndPlay(${1:#int frameIndex})"
                }
            },
            "SkeletonNode": {
                "getAllSubBonesMap": {
                    "type": "method",
                    "define": "getAllSubBonesMap()",
                    "detail": "get All bones in this skeleton, <bone's name, BoneNode>\n"
                },
                "changeSkins": {
                    "type": "method",
                    "define": "changeSkins(${1:#map_table boneSkinNameMap})",
                    "detail": "@overload self, string         \n@overload self, map_table         \n"
                },
                "getBoneNode": {
                    "type": "method",
                    "define": "getBoneNode(${1:#string boneName})",
                    "detail": "get bonenode in skeleton node by bone name\n"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "addSkinGroup": {
                    "type": "method",
                    "define": "addSkinGroup(${1:#string groupName},${2:#map_table boneSkinNameMap})",
                    "detail": "brief: add a boneSkinNameMap as a SkinGroup named groupName\nparam: groupName, key\nparam: boneSkinNameMap, map <name of bone, name of skin to display which added to bone>\n"
                }
            },
            "ActionMoveFrame": {
                "1": "new",
                "getAction": {
                    "type": "method",
                    "define": "getAction(${1:#float duration})",
                    "detail": "Gets the ActionInterval of ActionFrame.\nparam duration   the duration time of ActionFrame\nreturn ActionInterval\n"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#vec2_table pos})",
                    "detail": "Changes the move action position.\nparam the move action position.\n"
                },
                "getPosition": {
                    "type": "method",
                    "define": "getPosition()",
                    "detail": "Gets the move action position.\nreturn the move action position.\n"
                }
            },
            "ContourData": {
                "1": "new",
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "addVertex": {
                    "type": "method",
                    "define": "addVertex(${1:#vec2_table vertex})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                }
            },
            "CustomGUIReader": [
                "create"
            ],
            "EventFrame": {
                "1": "new",
                "setEvent": {
                    "type": "method",
                    "define": "setEvent(${1:#string event})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getEvent": {
                    "type": "method",
                    "define": "getEvent()"
                }
            },
            "SpriteDisplayData": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "copy": {
                    "type": "method",
                    "define": "copy(${1:#ccs.DisplayData displayData})"
                }
            },
            "BlendFuncFrame": {
                "1": "new",
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                }
            },
            "DisplayData": {
                "changeDisplayToTexture": {
                    "type": "method",
                    "define": "changeDisplayToTexture(${1:#string displayName})"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "copy": {
                    "type": "method",
                    "define": "copy(${1:#ccs.DisplayData displayData})"
                }
            },
            "Frame": {
                "getFrameIndex": {
                    "type": "method",
                    "define": "getFrameIndex()"
                },
                "setTweenType": {
                    "type": "method",
                    "define": "setTweenType(${1:#int tweenType})"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()"
                },
                "setFrameIndex": {
                    "type": "method",
                    "define": "setFrameIndex(${1:#unsigned int frameIndex})"
                },
                "setTimeline": {
                    "type": "method",
                    "define": "setTimeline(${1:#ccs.Timeline timeline})"
                },
                "apply": {
                    "type": "method",
                    "define": "apply(${1:#float percent})"
                },
                "setTween": {
                    "type": "method",
                    "define": "setTween(${1:#bool tween})"
                },
                "getTimeline": {
                    "type": "method",
                    "define": "getTimeline()"
                },
                "setNode": {
                    "type": "method",
                    "define": "setNode(${1:#cc.Node node})"
                },
                "getEasingParams": {
                    "type": "method",
                    "define": "getEasingParams()"
                },
                "isTween": {
                    "type": "method",
                    "define": "isTween()"
                },
                "isEnterWhenPassed": {
                    "type": "method",
                    "define": "isEnterWhenPassed()"
                },
                "setEasingParams": {
                    "type": "method",
                    "define": "setEasingParams(${1:#array_table easingParams})"
                },
                "getTweenType": {
                    "type": "method",
                    "define": "getTweenType()"
                },
                "getNode": {
                    "type": "method",
                    "define": "getNode()"
                }
            },
            "ComAudio": {
                "1": "endToLua",
                "stop": {
                    "type": "method",
                    "define": "stop()"
                },
                "isLoop": {
                    "type": "method",
                    "define": "isLoop()"
                },
                "resumeBackgroundMusic": {
                    "type": "method",
                    "define": "resumeBackgroundMusic()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "willPlayBackgroundMusic": {
                    "type": "method",
                    "define": "willPlayBackgroundMusic()"
                },
                "unloadEffect": {
                    "type": "method",
                    "define": "unloadEffect(${1:#char pszFilePath})"
                },
                "resumeAllEffects": {
                    "type": "method",
                    "define": "resumeAllEffects()"
                },
                "stopEffect": {
                    "type": "method",
                    "define": "stopEffect(${1:#unsigned int nSoundId})"
                },
                "setBackgroundMusicVolume": {
                    "type": "method",
                    "define": "setBackgroundMusicVolume(${1:#float volume})"
                },
                "stopBackgroundMusic": {
                    "type": "method",
                    "define": "stopBackgroundMusic(${1:#bool bReleaseData})",
                    "detail": "@overload self         \n@overload self, bool         \n"
                },
                "getEffectsVolume": {
                    "type": "method",
                    "define": "getEffectsVolume()"
                },
                "start": {
                    "type": "method",
                    "define": "start()",
                    "detail": "/ @{/ @name implement Playable Protocol\n"
                },
                "getBackgroundMusicVolume": {
                    "type": "method",
                    "define": "getBackgroundMusicVolume()"
                },
                "setLoop": {
                    "type": "method",
                    "define": "setLoop(${1:#bool bLoop})"
                },
                "rewindBackgroundMusic": {
                    "type": "method",
                    "define": "rewindBackgroundMusic()"
                },
                "playBackgroundMusic": {
                    "type": "method",
                    "define": "playBackgroundMusic(${1:#char pszFilePath},${2:#bool bLoop})",
                    "detail": "@overload self, char         \n@overload self, char, bool         \n@overload self         \n"
                },
                "setFile": {
                    "type": "method",
                    "define": "setFile(${1:#char pszFilePath})"
                },
                "preloadBackgroundMusic": {
                    "type": "method",
                    "define": "preloadBackgroundMusic(${1:#char pszFilePath})"
                },
                "setEffectsVolume": {
                    "type": "method",
                    "define": "setEffectsVolume(${1:#float volume})"
                },
                "resumeEffect": {
                    "type": "method",
                    "define": "resumeEffect(${1:#unsigned int nSoundId})"
                },
                "pauseAllEffects": {
                    "type": "method",
                    "define": "pauseAllEffects()"
                },
                "playEffect": {
                    "type": "method",
                    "define": "playEffect(${1:#char pszFilePath},${2:#bool bLoop})",
                    "detail": "@overload self, char         \n@overload self, char, bool         \n@overload self         \n"
                },
                "pauseEffect": {
                    "type": "method",
                    "define": "pauseEffect(${1:#unsigned int nSoundId})"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "isBackgroundMusicPlaying": {
                    "type": "method",
                    "define": "isBackgroundMusicPlaying()"
                },
                "stopAllEffects": {
                    "type": "method",
                    "define": "stopAllEffects()"
                },
                "getFile": {
                    "type": "method",
                    "define": "getFile()"
                },
                "pauseBackgroundMusic": {
                    "type": "method",
                    "define": "pauseBackgroundMusic()"
                },
                "preloadEffect": {
                    "type": "method",
                    "define": "preloadEffect(${1:#char pszFilePath})"
                }
            },
            "SceneReader": {
                "createNodeWithSceneFile": {
                    "type": "method",
                    "define": "createNodeWithSceneFile(${1:#string fileName},${2:#int attachComponent})"
                },
                "setTarget": {
                    "type": "method",
                    "define": "setTarget(${1:#function selector})"
                },
                "getAttachComponentType": {
                    "type": "method",
                    "define": "getAttachComponentType()"
                },
                "sceneReaderVersion": {
                    "type": "method",
                    "define": "sceneReaderVersion()"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": "js purge\nlua destroySceneReader\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()"
                },
                "getNodeByTag": {
                    "type": "method",
                    "define": "getNodeByTag(${1:#int nTag})"
                }
            },
            "ActionFadeFrame": {
                "1": "new",
                "getAction": {
                    "type": "method",
                    "define": "getAction(${1:#float duration})",
                    "detail": "Gets the ActionInterval of ActionFrame.\nparam duration   the duration time of ActionFrame\nreturn ActionInterval\n"
                },
                "getOpacity": {
                    "type": "method",
                    "define": "getOpacity()",
                    "detail": "Gets the fade action opacity.\nreturn the fade action opacity.\n"
                },
                "setOpacity": {
                    "type": "method",
                    "define": "setOpacity(${1:#int opacity})",
                    "detail": "Changes the fade action opacity.\nparam opacity the fade action opacity\n"
                }
            },
            "PlayableFrame": {
                "1": "new",
                "getPlayableAct": {
                    "type": "method",
                    "define": "getPlayableAct()"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setPlayableAct": {
                    "type": "method",
                    "define": "setPlayableAct(${1:#string playact})"
                }
            }
        },
        "CCArray": [
            "addObject",
            "addObjectsFromArray",
            "capacity",
            "containsObject",
            "count",
            "create",
            "createWithArray",
            "createWithCapacity",
            "createWithContentsOfFile",
            "createWithObject",
            "exchangeObject",
            "exchangeObjectAtIndex",
            "fastRemoveObject",
            "fastRemoveObjectAtIndex",
            "indexOfObject",
            "insertObject",
            "isEqualToArray",
            "lastObject",
            "objectAtIndex",
            "randomObject",
            "reduceMemoryFootprint",
            "removeAllObjects",
            "removeLastObject",
            "removeObject",
            "removeObjectAtIndex",
            "removeObjectsInArray",
            "replaceObjectAtIndex",
            "reverseObjects"
        ],
        "ccexp": {
            "AudioEngine": {
                "1": "endToLua",
                "2": "setFinishCallback",
                "stop": {
                    "type": "method",
                    "define": "stop(${1:#int audioID})",
                    "detail": "Stop an audio instance.\nparam audioID An audioID returned by the play2d function.\n"
                },
                "getCurrentTime": {
                    "type": "method",
                    "define": "getCurrentTime(${1:#int audioID})",
                    "detail": "Gets the current playback position of an audio instance.\nparam audioID An audioID returned by the play2d function.\nreturn The current playback position of an audio instance.\n"
                },
                "getDefaultProfile": {
                    "type": "method",
                    "define": "getDefaultProfile()",
                    "detail": "Gets the default profile of audio instances.\nreturn The default profile of audio instances.\n"
                },
                "isLoop": {
                    "type": "method",
                    "define": "isLoop(${1:#int audioID})",
                    "detail": "Checks whether an audio instance is loop.\nparam audioID An audioID returned by the play2d function.\nreturn Whether or not an audio instance is loop.\n"
                },
                "setLoop": {
                    "type": "method",
                    "define": "setLoop(${1:#int audioID},${2:#bool loop})",
                    "detail": "Sets whether an audio instance loop or not.\nparam audioID An audioID returned by the play2d function.\nparam loop Whether audio instance loop or not.\n"
                },
                "setCurrentTime": {
                    "type": "method",
                    "define": "setCurrentTime(${1:#int audioID},${2:#float sec})",
                    "detail": "Sets the current playback position of an audio instance.\nparam audioID   An audioID returned by the play2d function.\nparam sec       The offset in seconds from the start to seek to.\nreturn \n"
                },
                "resume": {
                    "type": "method",
                    "define": "resume(${1:#int audioID})",
                    "detail": "Resume an audio instance.\nparam audioID An audioID returned by the play2d function.\n"
                },
                "pauseAll": {
                    "type": "method",
                    "define": "pauseAll()",
                    "detail": " Pause all playing audio instances. \n"
                },
                "getDuration": {
                    "type": "method",
                    "define": "getDuration(${1:#int audioID})",
                    "detail": "Gets the duration of an audio instance.\nparam audioID An audioID returned by the play2d function.\nreturn The duration of an audio instance.\n"
                },
                "uncacheAll": {
                    "type": "method",
                    "define": "uncacheAll()",
                    "detail": "Uncache all audio data from internal buffer.\nwarning All audio will be stopped first.\n"
                },
                "getMaxAudioInstance": {
                    "type": "method",
                    "define": "getMaxAudioInstance()",
                    "detail": "Gets the maximum number of simultaneous audio instance of AudioEngine.\n"
                },
                "pause": {
                    "type": "method",
                    "define": "pause(${1:#int audioID})",
                    "detail": "Pause an audio instance.\nparam audioID An audioID returned by the play2d function.\n"
                },
                "getState": {
                    "type": "method",
                    "define": "getState(${1:#int audioID})",
                    "detail": "Returns the state of an audio instance.\nparam audioID An audioID returned by the play2d function.\nreturn The status of an audio instance.\n"
                },
                "stopAll": {
                    "type": "method",
                    "define": "stopAll()",
                    "detail": " Stop all audio instances. \n"
                },
                "setVolume": {
                    "type": "method",
                    "define": "setVolume(${1:#int audioID},${2:#float volume})",
                    "detail": "Sets volume for an audio instance.\nparam audioID An audioID returned by the play2d function.\nparam volume Volume value (range from 0.0 to 1.0).\n"
                },
                "setMaxAudioInstance": {
                    "type": "method",
                    "define": "setMaxAudioInstance(${1:#int maxInstances})",
                    "detail": "Sets the maximum number of simultaneous audio instance for AudioEngine.\nparam maxInstances The maximum number of simultaneous audio instance.\n"
                },
                "lazyInit": {
                    "type": "method",
                    "define": "lazyInit()"
                },
                "uncache": {
                    "type": "method",
                    "define": "uncache(${1:#string filePath})",
                    "detail": "Uncache the audio data from internal buffer.\nAudioEngine cache audio data on ios,mac, and win32 platform.\nwarning This can lead to stop related audio first.\nparam filePath Audio file path.\n"
                },
                "getVolume": {
                    "type": "method",
                    "define": "getVolume(${1:#int audioID})",
                    "detail": "Gets the volume value of an audio instance.\nparam audioID An audioID returned by the play2d function.\nreturn Volume value (range from 0.0 to 1.0).\n"
                },
                "getProfile": {
                    "type": "method",
                    "define": "getProfile(${1:#int audioID})",
                    "detail": "@overload self, string         \n@overload self, int         \n"
                },
                "play2d": {
                    "type": "method",
                    "define": "play2d(${1:#string filePath},${2:#bool loop},${3:#float volume},${4:#cc.experimental::AudioProfile profile})",
                    "detail": "Play 2d sound.\nparam filePath The path of an audio file.\nparam loop Whether audio instance loop or not.\nparam volume Volume value (range from 0.0 to 1.0).\nparam profile A profile for audio instance. When profile is not specified, default profile will be used.\nreturn An audio ID. It allows you to dynamically change the behavior of an audio instance on the fly.\nsee `AudioProfile`\n"
                },
                "resumeAll": {
                    "type": "method",
                    "define": "resumeAll()",
                    "detail": " Resume all suspended audio instances. \n"
                },
                "preload": {
                    "type": "method",
                    "define": "preload(${1:#string filePath},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                }
            },
            "TMXTiledMap": {
                "getLayer": {
                    "type": "method",
                    "define": "getLayer(${1:#string layerName})",
                    "detail": " Return the FastTMXLayer for the specific layer. \nreturn Return the FastTMXLayer for the specific layer.\n"
                },
                "setTileSize": {
                    "type": "method",
                    "define": "setTileSize(${1:#size_table tileSize})",
                    "detail": " Set the tiles's size property measured in pixels. \nparam tileSize The tiles's size property measured in pixels.\n"
                },
                "setMapOrientation": {
                    "type": "method",
                    "define": "setMapOrientation(${1:#int mapOrientation})",
                    "detail": " Set map orientation. \nparam mapOrientation The map orientation.\n"
                },
                "getProperty": {
                    "type": "method",
                    "define": "getProperty(${1:#string propertyName})",
                    "detail": " Return the value for the specific property name.\nreturn Return the value for the specific property name.\n"
                },
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})",
                    "detail": " Set properties. \nparam properties An ValueMap Properties.\n"
                },
                "setObjectGroups": {
                    "type": "method",
                    "define": "setObjectGroups(${1:#array_table groups})",
                    "detail": " Set object groups. \nparam groups An object groups.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string tmxFile})",
                    "detail": " Creates a TMX Tiled Map with a TMX file.\nreturn An autorelease object.\n"
                },
                "getObjectGroup": {
                    "type": "method",
                    "define": "getObjectGroup(${1:#string groupName})",
                    "detail": " Return the TMXObjectGroup for the specific group. \nreturn Return the TMXObjectGroup for the specific group.\n"
                },
                "setMapSize": {
                    "type": "method",
                    "define": "setMapSize(${1:#size_table mapSize})",
                    "detail": " Set the map's size property measured in tiles.\nparam mapSize The map's size property measured in tiles.\n"
                },
                "getTileSize": {
                    "type": "method",
                    "define": "getTileSize()",
                    "detail": " The tiles's size property measured in pixels.\nreturn The tiles's size property measured in pixels.\n"
                },
                "getPropertiesForGID": {
                    "type": "method",
                    "define": "getPropertiesForGID(${1:#int GID})",
                    "detail": " Return properties dictionary for tile GID.\nreturn Return properties dictionary for tile GID.\n"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()",
                    "detail": " Get properties.\nreturn Properties.\n"
                },
                "createWithXML": {
                    "type": "method",
                    "define": "createWithXML(${1:#string tmxString},${2:#string resourcePath})",
                    "detail": " Initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources. \nparam tmxString A TMX formatted XML string.\nparam resourcePath A path to TMX resources.\nreturn An autorelease object.\n"
                },
                "getMapSize": {
                    "type": "method",
                    "define": "getMapSize()",
                    "detail": " The map's size property measured in tiles. \nreturn The map's size property measured in tiles.\n"
                },
                "getMapOrientation": {
                    "type": "method",
                    "define": "getMapOrientation()",
                    "detail": " Get map orientation. \nreturn The map orientation.\n"
                },
                "getObjectGroups": {
                    "type": "method",
                    "define": "getObjectGroups()",
                    "detail": "@overload self         \n@overload self         \n"
                }
            },
            "TMXLayer": {
                "1": "getTileGIDAt",
                "2": "new",
                "getMapTileSize": {
                    "type": "method",
                    "define": "getMapTileSize()",
                    "detail": " Size of the map's tile (could be different from the tile's size).\nreturn Size of the map's tile (could be different from the tile's size).\n"
                },
                "setLayerSize": {
                    "type": "method",
                    "define": "setLayerSize(${1:#size_table size})",
                    "detail": " Set the size of the layer in tiles. \nparam size The new size of the layer in tiles.\n"
                },
                "getProperty": {
                    "type": "method",
                    "define": "getProperty(${1:#string propertyName})",
                    "detail": " Return the value for the specific property name.\nparam propertyName The value for the specific property name.\nreturn The value for the specific property name.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.TMXTilesetInfo tilesetInfo},${2:#cc.TMXLayerInfo layerInfo},${3:#cc.TMXMapInfo mapInfo})",
                    "detail": " Creates a FastTMXLayer with an tileset info, a layer info and a map info.\nparam tilesetInfo An tileset info.\nparam layerInfo A layer info.\nparam mapInfo A map info.\nreturn Return an autorelease object.\n"
                },
                "getLayerOrientation": {
                    "type": "method",
                    "define": "getLayerOrientation()",
                    "detail": " Layer orientation, which is the same as the map orientation.\nreturn Layer orientation, which is the same as the map orientation.\n"
                },
                "getLayerSize": {
                    "type": "method",
                    "define": "getLayerSize()",
                    "detail": " Size of the layer in tiles.\nreturn Size of the layer in tiles.\n"
                },
                "setTileGID": {
                    "type": "method",
                    "define": "setTileGID(${1:#int gid},${2:#vec2_table tileCoordinate},${3:#int flags})",
                    "detail": "@overload self, int, vec2_table, int         \n@overload self, int, vec2_table         \n"
                },
                "setLayerOrientation": {
                    "type": "method",
                    "define": "setLayerOrientation(${1:#int orientation})",
                    "detail": " Set Layer orientation, which is the same as the map orientation. \nparam orientation Layer orientation, which is the same as the map orientation.\n"
                },
                "getPositionAt": {
                    "type": "method",
                    "define": "getPositionAt(${1:#vec2_table tileCoordinate})",
                    "detail": " Returns the position in points of a given tile coordinate.\nparam tileCoordinate The tile Coordinate.\nreturn The position in points of a given tile coordinate.\n"
                },
                "setMapTileSize": {
                    "type": "method",
                    "define": "setMapTileSize(${1:#size_table size})",
                    "detail": " Set the size of the map's tile. \nparam size The new size of the map's tile.\n"
                },
                "getLayerName": {
                    "type": "method",
                    "define": "getLayerName()",
                    "detail": " Get the tile layer name.\nreturn The tile layer name.\n"
                },
                "setupTileSprite": {
                    "type": "method",
                    "define": "setupTileSprite(${1:#cc.Sprite sprite},${2:#vec2_table pos},${3:#unsigned int gid})",
                    "detail": " Set an sprite to the tile,with the tile coordinate and gid.\nparam sprite A Sprite.\nparam pos The tile coordinate.\nparam gid The tile gid.\n"
                },
                "setTileSet": {
                    "type": "method",
                    "define": "setTileSet(${1:#cc.TMXTilesetInfo info})",
                    "detail": " Set the tileset information for the layer. \nparam info The new tileset information for the layer.\n"
                },
                "setupTiles": {
                    "type": "method",
                    "define": "setupTiles()",
                    "detail": " Creates the tiles. \n"
                },
                "getTileSet": {
                    "type": "method",
                    "define": "getTileSet()",
                    "detail": " Tileset information for the layer.\nreturn Tileset information for the layer.\n"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "removeTileAt": {
                    "type": "method",
                    "define": "removeTileAt(${1:#vec2_table tileCoordinate})",
                    "detail": " Removes a tile at given tile coordinate.\nparam tileCoordinate The tile Coordinate.\n"
                },
                "getTileAt": {
                    "type": "method",
                    "define": "getTileAt(${1:#vec2_table tileCoordinate})",
                    "detail": " Returns the tile (Sprite) at a given a tile coordinate.\nThe returned Sprite will be already added to the TMXLayer. Don't add it again.\nThe Sprite can be treated like any other Sprite: rotated, scaled, translated, opacity, color, etc.\nYou can remove either by calling:\n- layer->removeChild(sprite, cleanup);\nreturn Returns the tile (Sprite) at a given a tile coordinate.\n"
                },
                "setLayerName": {
                    "type": "method",
                    "define": "setLayerName(${1:#string layerName})",
                    "detail": " Set the tile layer name.\nparam layerName The new layer name.\n"
                },
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})",
                    "detail": " Set the properties to the layer.\nparam properties The properties to the layer.\n"
                }
            },
            "VideoPlayerEvent": [
                "COMPLETED",
                "PAUSED",
                "PLAYING",
                "STOPPED"
            ],
            "AudioProfile": [
                "new"
            ]
        },
        "CCSize": [
            "call",
            "new",
            "new_local"
        ],
        "GameUpdater": [
            "checkUpdate",
            "create",
            "getUpdateSize",
            "getVersion",
            "setApkVersion",
            "setErrorHandler",
            "setProcessHandler",
            "setSuccessHandler",
            "update"
        ],
        "protobuf": {
            "c": [
                "_add_pattern",
                "_add_rmessage",
                "_decode",
                "_env_new",
                "_env_register",
                "_env_type",
                "_gc",
                "_last_error",
                "_pattern_delete",
                "_pattern_new",
                "_pattern_pack",
                "_pattern_size",
                "_pattern_unpack",
                "_rmessage_delete",
                "_rmessage_int32",
                "_rmessage_int52",
                "_rmessage_int64",
                "_rmessage_integer",
                "_rmessage_message",
                "_rmessage_new",
                "_rmessage_real",
                "_rmessage_size",
                "_rmessage_string",
                "_rmessage_uint52",
                "_wmessage_buffer",
                "_wmessage_buffer_string",
                "_wmessage_delete",
                "_wmessage_int32",
                "_wmessage_int52",
                "_wmessage_int64",
                "_wmessage_integer",
                "_wmessage_message",
                "_wmessage_new",
                "_wmessage_real",
                "_wmessage_string",
                "_wmessage_uint52"
            ]
        },
        "table": [
            "concat",
            "filter",
            "foreach",
            "foreachi",
            "getn",
            "indexof",
            "insert",
            "insertto",
            "keyof",
            "keys",
            "map",
            "maxn",
            "merge",
            "nums",
            "remove",
            "removebyvalue",
            "sort",
            "unique",
            "values",
            "walk"
        ],
        "ccui": {
            "CheckBoxEventType": [
                "selected",
                "unselected"
            ],
            "CheckBox": {
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#string backGround},${2:#string backGroundSelected},${3:#string cross},${4:#string backGroundDisabled},${5:#string frontCrossDisabled},${6:#int texType})",
                    "detail": "@overload self, string, string, string, string, string, int         \n@overload self         \n@overload self, string, string, int         \n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add a callback function which would be called when checkbox is selected or unselected.\nparam callback A std::function with type @see `ccCheckBoxCallback`\n"
                }
            },
            "ImageView": {
                "1": "new",
                "getCapInsets": {
                    "type": "method",
                    "define": "getCapInsets()",
                    "detail": "Get ImageView's capInsets size.\nreturn Query capInsets size in Rect\nsee `setCapInsets(const Rect&)`\n"
                },
                "getRenderFile": {
                    "type": "method",
                    "define": "getRenderFile()"
                },
                "isScale9Enabled": {
                    "type": "method",
                    "define": "isScale9Enabled()",
                    "detail": "Query whether button is using scale9 renderer or not.\nreturn whether button use scale9 renderer or not.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "setCapInsets": {
                    "type": "method",
                    "define": "setCapInsets(${1:#rect_table capInsets})",
                    "detail": "Sets capInsets for imageview.\nThe capInsets affects the ImageView's renderer only if `setScale9Enabled(true)` is called.\nparam capInsets    capinsets for imageview\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string imageFileName},${2:#int texType})",
                    "detail": "@overload self, string, int         \n@overload self         \n"
                },
                "loadTexture": {
                    "type": "method",
                    "define": "loadTexture(${1:#string fileName},${2:#int texType})",
                    "detail": "Load texture for imageview.\nparam fileName   file name of texture.\nparam texType    @see `Widget::TextureResType`\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "setTextureRect": {
                    "type": "method",
                    "define": "setTextureRect(${1:#rect_table rect})",
                    "detail": "Updates the texture rect of the ImageView in points.\nIt will call setTextureRect:rotated:untrimmedSize with rotated = NO, and utrimmedSize = rect.size.\n"
                },
                "setScale9Enabled": {
                    "type": "method",
                    "define": "setScale9Enabled(${1:#bool enabled})",
                    "detail": "Enable scale9 renderer.\nparam enabled Set to true will use scale9 renderer, false otherwise.\n"
                }
            },
            "ListViewEventType": [
                "ONSELECTEDITEM_END",
                "ONSELECTEDITEM_START"
            ],
            "BrightStyle": [
                "highlight",
                "none",
                "normal"
            ],
            "LinearGravity": [
                "bottom",
                "centerHorizontal",
                "centerVertical",
                "left",
                "none",
                "right",
                "top"
            ],
            "LayoutParameter": {
                "3": "setMargin",
                "2": "new",
                "getLayoutType": {
                    "type": "method",
                    "define": "getLayoutType()",
                    "detail": "Gets LayoutParameterType of LayoutParameter.\nsee LayoutParameterType.\nreturn LayoutParameterType\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "Create a copy of original LayoutParameter.\nreturn A LayoutParameter pointer.\n"
                },
                "createCloneInstance": {
                    "type": "method",
                    "define": "createCloneInstance()",
                    "detail": "Create a cloned instance of LayoutParameter.\nreturn A LayoutParameter pointer.\n"
                },
                "1": "getMargin",
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create a empty LayoutParameter.\nreturn A autorelease LayoutParameter instance.\n"
                },
                "copyProperties": {
                    "type": "method",
                    "define": "copyProperties(${1:#ccui.LayoutParameter model})",
                    "detail": "Copy all the member field from argument LayoutParameter to self.\nparam model A LayoutParameter instance.\n"
                }
            },
            "TextBMFont": {
                "1": "new",
                "setFntFile": {
                    "type": "method",
                    "define": "setFntFile(${1:#string fileName})",
                    "detail": " init a bitmap font atlas with an initial string and the FNT file \n"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string value})"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()"
                },
                "getRenderFile": {
                    "type": "method",
                    "define": "getRenderFile()"
                },
                "getStringLength": {
                    "type": "method",
                    "define": "getStringLength()",
                    "detail": "Gets the string length of the label.\nNote: This length will be larger than the raw string length,\nif you want to get the raw string length, you should call this->getString().size() instead\nreturn  string length.\n"
                },
                "resetRender": {
                    "type": "method",
                    "define": "resetRender()",
                    "detail": "reset TextBMFont inner label\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string text},${2:#string filename})",
                    "detail": "@overload self, string, string         \n@overload self         \n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                }
            },
            "LayoutBackGroundColorType": [
                "gradient",
                "none",
                "solid"
            ],
            "LayoutComponent": {
                "1": "new",
                "getBottomMargin": {
                    "type": "method",
                    "define": "getBottomMargin()",
                    "detail": "Query the bottom margin of owner relative to its parent.\nreturn Bottom margin in float.\n"
                },
                "getPercentHeight": {
                    "type": "method",
                    "define": "getPercentHeight()",
                    "detail": "Query percent height of owner.         \nreturn Percent height in float.\n"
                },
                "refreshLayout": {
                    "type": "method",
                    "define": "refreshLayout()",
                    "detail": "Refresh layout of the owner.\n"
                },
                "isPositionPercentYEnabled": {
                    "type": "method",
                    "define": "isPositionPercentYEnabled()",
                    "detail": "Whether position percentY is enabled or not.\nsee `setPositionPercentYEnabled`\nreturn True if position percentY is enabled, false otherwise.\n"
                },
                "setPercentHeightEnabled": {
                    "type": "method",
                    "define": "setPercentHeightEnabled(${1:#bool isUsed})",
                    "detail": "Toggle enable percent height.\nparam isUsed True if percent height is enabled, false otherwise.\n"
                },
                "isStretchWidthEnabled": {
                    "type": "method",
                    "define": "isStretchWidthEnabled()",
                    "detail": "Query whether stretch width is enabled or not.\nreturn True if stretch width is enabled, false otherwise.\n"
                },
                "getHorizontalEdge": {
                    "type": "method",
                    "define": "getHorizontalEdge()",
                    "detail": "Query element horizontal dock type.\nreturn Horizontal dock type.\n"
                },
                "getPositionPercentY": {
                    "type": "method",
                    "define": "getPositionPercentY()",
                    "detail": "Query the position percentY Y value.\nreturn Position percent Y value in float.\n"
                },
                "setStretchHeightEnabled": {
                    "type": "method",
                    "define": "setStretchHeightEnabled(${1:#bool isUsed})",
                    "detail": "Toggle enable stretch height.\nparam isUsed True if stretch height is enabled, false otherwise.\n"
                },
                "getPercentContentSize": {
                    "type": "method",
                    "define": "getPercentContentSize()",
                    "detail": "Query the percent content size value.\nreturn Percent (x,y) in Vec2.\n"
                },
                "setPositionPercentY": {
                    "type": "method",
                    "define": "setPositionPercentY(${1:#float percentMargin})",
                    "detail": "Change position percentY value.\nparam percentMargin Margin in float.\n"
                },
                "getRightMargin": {
                    "type": "method",
                    "define": "getRightMargin()",
                    "detail": "Query the right margin of owner relative to its parent.\nreturn Right margin in float.\n"
                },
                "getPositionPercentX": {
                    "type": "method",
                    "define": "getPositionPercentX()",
                    "detail": "Query the position percent X value.\nreturn Position percent X value in float.\n"
                },
                "getAnchorPosition": {
                    "type": "method",
                    "define": "getAnchorPosition()",
                    "detail": "Query the anchor position.\nreturn Anchor position to it's parent\n"
                },
                "getUsingPercentContentSize": {
                    "type": "method",
                    "define": "getUsingPercentContentSize()",
                    "detail": "Query whether use percent content size or not.\nreturn True if using percent content size, false otherwise.\n"
                },
                "setPositionPercentX": {
                    "type": "method",
                    "define": "setPositionPercentX(${1:#float percentMargin})",
                    "detail": "Change position percent X value.\nparam percentMargin Margin in float.\n"
                },
                "setHorizontalEdge": {
                    "type": "method",
                    "define": "setHorizontalEdge(${1:#int hEage})",
                    "detail": "Change element's horizontal dock type.\nparam hEage Horizontal dock type @see `HorizontalEdge`\n"
                },
                "setPercentWidthEnabled": {
                    "type": "method",
                    "define": "setPercentWidthEnabled(${1:#bool isUsed})",
                    "detail": "Toggle enable percent width.\nparam isUsed True if percent width is enabled, false otherwise.\n"
                },
                "setPositionPercentXEnabled": {
                    "type": "method",
                    "define": "setPositionPercentXEnabled(${1:#bool isUsed})",
                    "detail": "Toggle position percentX enabled.\nparam isUsed  True if enable position percentX, false otherwise.\n"
                },
                "getSizeHeight": {
                    "type": "method",
                    "define": "getSizeHeight()",
                    "detail": "Query size height of owner.\nreturn Size height in float.\n"
                },
                "setAnchorPosition": {
                    "type": "method",
                    "define": "setAnchorPosition(${1:#vec2_table point})",
                    "detail": "Change the anchor position to it's parent.\nparam point A value in (x,y) format.\n"
                },
                "bindLayoutComponent": {
                    "type": "method",
                    "define": "bindLayoutComponent(${1:#cc.Node node})",
                    "detail": "Bind a LayoutComponent to a specified node.\nIf the node has already binded a LayoutComponent named __LAYOUT_COMPONENT_NAME, just return the LayoutComponent.\nOtherwise, create a new LayoutComponent and bind the LayoutComponent to the node.\nparam node A Node* instance pointer.\nreturn The binded LayoutComponent instance pointer.\n"
                },
                "setSizeWidth": {
                    "type": "method",
                    "define": "setSizeWidth(${1:#float width})",
                    "detail": "Change content size width of owner.\nparam width Content size width in float.\n"
                },
                "isStretchHeightEnabled": {
                    "type": "method",
                    "define": "isStretchHeightEnabled()",
                    "detail": "Query whether stretch height is enabled or not.\nreturn True if stretch height is enabled, false otherwise.\n"
                },
                "setActiveEnabled": {
                    "type": "method",
                    "define": "setActiveEnabled(${1:#bool enable})",
                    "detail": "Toggle active enabled of LayoutComponent's owner.\nparam enable True if active layout component, false otherwise.\n"
                },
                "getVerticalEdge": {
                    "type": "method",
                    "define": "getVerticalEdge()",
                    "detail": "Query element vertical dock type.\nreturn Vertical dock type.\n"
                },
                "setUsingPercentContentSize": {
                    "type": "method",
                    "define": "setUsingPercentContentSize(${1:#bool isUsed})",
                    "detail": "Percent content size is used to adapt node's content size based on parent's content size.\nIf set to true then node's content size will be changed based on the value set by @see setPercentContentSize\nparam isUsed True to enable percent content size, false otherwise.\n"
                },
                "setLeftMargin": {
                    "type": "method",
                    "define": "setLeftMargin(${1:#float margin})",
                    "detail": "Change left margin of owner relative to its parent.\nparam margin Margin in float.\n"
                },
                "getSize": {
                    "type": "method",
                    "define": "getSize()",
                    "detail": "Query owner's content size.\nreturn Owner's content size.\n"
                },
                "setTopMargin": {
                    "type": "method",
                    "define": "setTopMargin(${1:#float margin})",
                    "detail": "Change the top margin of owner relative to its parent.\nparam margin Margin in float.\n"
                },
                "getPercentWidth": {
                    "type": "method",
                    "define": "getPercentWidth()",
                    "detail": "Query percent width of owner.\nreturn percent width in float.\n"
                },
                "setBottomMargin": {
                    "type": "method",
                    "define": "setBottomMargin(${1:#float margin})",
                    "detail": "Change the bottom margin of owner relative to its parent.\nparam margin in float.\n"
                },
                "getSizeWidth": {
                    "type": "method",
                    "define": "getSizeWidth()",
                    "detail": "Query content size width of owner.\nreturn Content size width in float.\n"
                },
                "setSizeHeight": {
                    "type": "method",
                    "define": "setSizeHeight(${1:#float height})",
                    "detail": "Change size height of owner.\nparam height Size height in float.\n"
                },
                "setSize": {
                    "type": "method",
                    "define": "setSize(${1:#size_table size})",
                    "detail": "Change the content size of owner.\nparam size Content size in @see `Size`.\n"
                },
                "isPercentHeightEnabled": {
                    "type": "method",
                    "define": "isPercentHeightEnabled()",
                    "detail": "Query whether percent height is enabled or not.\nreturn True if percent height is enabled, false otherwise.\n"
                },
                "setPercentHeight": {
                    "type": "method",
                    "define": "setPercentHeight(${1:#float percentHeight})",
                    "detail": "Change percent height value of owner.\nparam percentHeight Percent height in float.\n"
                },
                "setStretchWidthEnabled": {
                    "type": "method",
                    "define": "setStretchWidthEnabled(${1:#bool isUsed})",
                    "detail": "Toggle enable stretch width.\nparam isUsed True if enable stretch width, false otherwise.\n"
                },
                "setPositionPercentYEnabled": {
                    "type": "method",
                    "define": "setPositionPercentYEnabled(${1:#bool isUsed})",
                    "detail": "Toggle position percentY enabled.\nparam isUsed True if position percentY is enabled, false otherwise.\n"
                },
                "getLeftMargin": {
                    "type": "method",
                    "define": "getLeftMargin()",
                    "detail": "Query left margin of owner relative to its parent.\nreturn Left margin in float.\n"
                },
                "setPercentWidth": {
                    "type": "method",
                    "define": "setPercentWidth(${1:#float percentWidth})",
                    "detail": "Change percent width of owner.\nparam percentWidth Percent Width in float.\n"
                },
                "isPositionPercentXEnabled": {
                    "type": "method",
                    "define": "isPositionPercentXEnabled()",
                    "detail": "Whether position percentX is enabled or not. \nreturn True if position percentX is enable, false otherwise.\n"
                },
                "getPosition": {
                    "type": "method",
                    "define": "getPosition()",
                    "detail": "Query the owner's position.\nreturn The owner's position.\n"
                },
                "setPercentOnlyEnabled": {
                    "type": "method",
                    "define": "setPercentOnlyEnabled(${1:#bool enable})",
                    "detail": "Toggle enable percent only.\nparam enable True if percent only is enabled, false otherwise.\n"
                },
                "getTopMargin": {
                    "type": "method",
                    "define": "getTopMargin()",
                    "detail": "Query the top margin of owner relative to its parent.\nreturn Top margin in float.\n"
                },
                "setVerticalEdge": {
                    "type": "method",
                    "define": "setVerticalEdge(${1:#int vEage})",
                    "detail": "Change element's vertical dock type.\nparam vEage Vertical dock type @see `VerticalEdge`.\n"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#vec2_table position})",
                    "detail": "Change the position of component owner.\nparam position A position in (x,y)\n"
                },
                "setPercentContentSize": {
                    "type": "method",
                    "define": "setPercentContentSize(${1:#vec2_table percent})",
                    "detail": "Set percent content size.\nThe value should be [0-1], 0 means the child's content size will be 0\nand 1 means the child's content size is the same as its parents.\nparam percent The percent (x,y) of the node in [0-1] scope.\n"
                },
                "isPercentWidthEnabled": {
                    "type": "method",
                    "define": "isPercentWidthEnabled()",
                    "detail": "Query whether percent width is enabled or not.\nreturn True if percent width is enabled, false, otherwise.\n"
                },
                "setRightMargin": {
                    "type": "method",
                    "define": "setRightMargin(${1:#float margin})",
                    "detail": "Change right margin of owner relative to its parent.\nparam margin Margin in float.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                }
            },
            "TextFiledEventType": [
                "attach_with_ime",
                "delete_backward",
                "detach_with_ime",
                "insert_text"
            ],
            "TextField": {
                "1": "new",
                "setTextHorizontalAlignment": {
                    "type": "method",
                    "define": "setTextHorizontalAlignment(${1:#int alignment})",
                    "detail": "brief Change horizontal text alignment.\nparam alignment A alignment arguments in @see `TextHAlignment`.\n"
                },
                "attachWithIME": {
                    "type": "method",
                    "define": "attachWithIME()",
                    "detail": "brief Attach the IME for inputing.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string placeholder},${2:#string fontName},${3:#int fontSize})",
                    "detail": "@overload self, string, string, int         \n@overload self         \n"
                },
                "setCursorFromPoint": {
                    "type": "method",
                    "define": "setCursorFromPoint(${1:#vec2_table point},${2:#cc.Camera camera})",
                    "detail": "Set cursor position to hit letter, if enabled\njs NA\n"
                },
                "getFontName": {
                    "type": "method",
                    "define": "getFontName()",
                    "detail": "brief Query the TextField's font name.\nreturn The font name string.\n"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()",
                    "detail": "Query the content of TextField.\nreturn The string value of TextField.\n"
                },
                "getTextColor": {
                    "type": "method",
                    "define": "getTextColor()",
                    "detail": "brief Query the text string color.\nreturn The color of the text.\n"
                },
                "setPlaceHolderColor": {
                    "type": "method",
                    "define": "setPlaceHolderColor(${1:#color3b_table color})",
                    "detail": "@overload self, color4b_table         \n@overload self, color3b_table         \n"
                },
                "getInsertText": {
                    "type": "method",
                    "define": "getInsertText()",
                    "detail": "brief Whether it is ready to get the inserted text or not.\nreturn True if the insert text is ready, false otherwise.\n"
                },
                "getAttachWithIME": {
                    "type": "method",
                    "define": "getAttachWithIME()",
                    "detail": "brief Query whether the IME is attached or not.\nreturn True if IME is attached, false otherwise.\n"
                },
                "setMaxLength": {
                    "type": "method",
                    "define": "setMaxLength(${1:#int length})",
                    "detail": "brief Change maximize input length limitation.\nparam length A character count in integer.\n"
                },
                "setDeleteBackward": {
                    "type": "method",
                    "define": "setDeleteBackward(${1:#bool deleteBackward})",
                    "detail": "brief Toggle enable delete backward mode.\nparam deleteBackward True is delete backward is enabled, false otherwise.\n"
                },
                "isMaxLengthEnabled": {
                    "type": "method",
                    "define": "isMaxLengthEnabled()",
                    "detail": "brief Query whether max length is enabled or not.\nreturn True if maximize length is enabled, false otherwise.\n"
                },
                "getTextHorizontalAlignment": {
                    "type": "method",
                    "define": "getTextHorizontalAlignment()",
                    "detail": "brief Inquire the horizontal alignment\nreturn The horizontal alignment\n"
                },
                "getPlaceHolderColor": {
                    "type": "method",
                    "define": "getPlaceHolderColor()",
                    "detail": "brief Query the placeholder string color.\nreturn The color of placeholder.\n"
                },
                "getDetachWithIME": {
                    "type": "method",
                    "define": "getDetachWithIME()",
                    "detail": "brief Query whether IME is detached or not.\nreturn True if IME is detached, false otherwise.\n"
                },
                "isPasswordEnabled": {
                    "type": "method",
                    "define": "isPasswordEnabled()",
                    "detail": "brief Query whether password is enabled or not.\nreturn True if password is enabled, false otherwise.\n"
                },
                "getMaxLength": {
                    "type": "method",
                    "define": "getMaxLength()",
                    "detail": "brief Query maximize input length of TextField.\nreturn The integer value of maximize input length.\n"
                },
                "setDetachWithIME": {
                    "type": "method",
                    "define": "setDetachWithIME(${1:#bool detach})",
                    "detail": "brief Toggle detach with IME.\nparam detach True if detach with IME, false otherwise.\n"
                },
                "getPlaceHolder": {
                    "type": "method",
                    "define": "getPlaceHolder()",
                    "detail": "brief Get the placeholder of TextField.\nreturn A placeholder string.\n"
                },
                "setPasswordEnabled": {
                    "type": "method",
                    "define": "setPasswordEnabled(${1:#bool enable})",
                    "detail": "brief Toggle enable password input mode.\nparam enable True if enable password input mode, false otherwise.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "setFontName": {
                    "type": "method",
                    "define": "setFontName(${1:#string name})",
                    "detail": "brief Change the font name of TextField.\nparam name The font name string.\n"
                },
                "setTouchSize": {
                    "type": "method",
                    "define": "setTouchSize(${1:#size_table size})",
                    "detail": "brief Set the touch size\nThe touch size is used for @see `hitTest`.\nparam size A delimitation zone.\n"
                },
                "setTouchAreaEnabled": {
                    "type": "method",
                    "define": "setTouchAreaEnabled(${1:#bool enable})",
                    "detail": "brief Toggle enable touch area.\nparam enable True if enable touch area, false otherwise.\n"
                },
                "getFontSize": {
                    "type": "method",
                    "define": "getFontSize()",
                    "detail": "brief Query the font size.\nreturn The integer font size.\n"
                },
                "setInsertText": {
                    "type": "method",
                    "define": "setInsertText(${1:#bool insertText})",
                    "detail": "brief Toggle enable insert text mode\nparam insertText True if enable insert text, false otherwise.\n"
                },
                "getStringLength": {
                    "type": "method",
                    "define": "getStringLength()",
                    "detail": "brief Query the input string length.\nreturn A integer length value.\n"
                },
                "getAutoRenderSize": {
                    "type": "method",
                    "define": "getAutoRenderSize()",
                    "detail": "brief Get the renderer size in auto mode.\nreturn A delimitation zone.\n"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string text})",
                    "detail": "Change content of TextField.\nparam text A string content.\n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add a event listener to TextField, when some predefined event happens, the callback will be called.\nparam callback A callback function with type of `ccTextFieldCallback`.\n"
                },
                "setMaxLengthEnabled": {
                    "type": "method",
                    "define": "setMaxLengthEnabled(${1:#bool enable})",
                    "detail": "brief Toggle maximize length enable\nparam enable True if enable maximize length, false otherwise.\n"
                },
                "setPlaceHolder": {
                    "type": "method",
                    "define": "setPlaceHolder(${1:#string value})",
                    "detail": "brief Set placeholder of TextField.\nparam value The string value of placeholder.\n"
                },
                "getPasswordStyleText": {
                    "type": "method",
                    "define": "getPasswordStyleText()",
                    "detail": "brief Query the password style text.\nreturn A password style text.\n"
                },
                "setCursorEnabled": {
                    "type": "method",
                    "define": "setCursorEnabled(${1:#bool enabled})",
                    "detail": "Set enable cursor use.\njs NA\n"
                },
                "getDeleteBackward": {
                    "type": "method",
                    "define": "getDeleteBackward()",
                    "detail": "brief Whether it is ready to delete backward in TextField.\nreturn True is the delete backward is enabled, false otherwise.\n"
                },
                "didNotSelectSelf": {
                    "type": "method",
                    "define": "didNotSelectSelf()",
                    "detail": "brief Detach the IME.\n"
                },
                "setCursorChar": {
                    "type": "method",
                    "define": "setCursorChar(${1:#char cursor})",
                    "detail": "Set char showing cursor.\njs NA\n"
                },
                "setTextColor": {
                    "type": "method",
                    "define": "setTextColor(${1:#color4b_table textColor})",
                    "detail": "brief Change the text color.\nparam textColor The color value in `Color4B`.\n"
                },
                "setCursorPosition": {
                    "type": "method",
                    "define": "setCursorPosition(${1:#unsigned long cursorPosition})",
                    "detail": "Set cursor position, if enabled\njs NA\n"
                },
                "setFontSize": {
                    "type": "method",
                    "define": "setFontSize(${1:#int size})",
                    "detail": "brief Change font size of TextField.\nparam size The integer font size.\n"
                },
                "setTextAreaSize": {
                    "type": "method",
                    "define": "setTextAreaSize(${1:#size_table size})",
                    "detail": "brief Change the text area size.\nparam size A delimitation zone.\n"
                },
                "getTextVerticalAlignment": {
                    "type": "method",
                    "define": "getTextVerticalAlignment()",
                    "detail": "brief Inquire the horizontal alignment\nreturn The horizontal alignment\n"
                },
                "setAttachWithIME": {
                    "type": "method",
                    "define": "setAttachWithIME(${1:#bool attach})",
                    "detail": "brief Toggle attach with IME.\nparam attach True if attach with IME, false otherwise.\n"
                },
                "setTextVerticalAlignment": {
                    "type": "method",
                    "define": "setTextVerticalAlignment(${1:#int alignment})",
                    "detail": "brief Change the vertical text alignment.\nparam alignment A alignment arguments in @see `TextVAlignment`.\n"
                },
                "setPasswordStyleText": {
                    "type": "method",
                    "define": "setPasswordStyleText(${1:#char styleText})",
                    "detail": "brief Change password style text.\nparam styleText The styleText for password mask, the default value is \"*\".\n"
                },
                "getTouchSize": {
                    "type": "method",
                    "define": "getTouchSize()",
                    "detail": "brief Get current touch size of TextField.\nreturn The TextField's touch size.\n"
                }
            },
            "HBox": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table size})",
                    "detail": "@overload self, size_table         \n@overload self         \n"
                },
                "initWithSize": {
                    "type": "method",
                    "define": "initWithSize(${1:#size_table size})"
                }
            },
            "LayoutType": [
                "ABSOLUTE",
                "HORIZONTAL",
                "RELATIVE",
                "VERTICAL"
            ],
            "PositionType": [
                "absolute",
                "percent"
            ],
            "TextType": [
                "SYSTEM",
                "TTF"
            ],
            "ScrollViewMoveDir": [
                "down",
                "left",
                "none",
                "right",
                "up"
            ],
            "RichElement": {
                "1": "new",
                "equalType": {
                    "type": "method",
                    "define": "equalType(${1:#int type})"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity})",
                    "detail": "brief Initialize a rich element with different arguments.\nparam tag A integer tag value.\nparam color A color in @see `Color3B`.\nparam opacity A opacity value in `GLubyte`.\nreturn True if initialize success, false otherwise.\n"
                },
                "setColor": {
                    "type": "method",
                    "define": "setColor(${1:#color3b_table color})"
                }
            },
            "TouchEventType": [
                "began",
                "canceled",
                "ended",
                "moved"
            ],
            "TextAtlas": {
                "1": "new",
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string value})"
                },
                "adaptRenderers": {
                    "type": "method",
                    "define": "adaptRenderers()",
                    "detail": "js NA\n"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()"
                },
                "getRenderFile": {
                    "type": "method",
                    "define": "getRenderFile()"
                },
                "getStringLength": {
                    "type": "method",
                    "define": "getStringLength()",
                    "detail": "Gets the string length of the label.\nNote: This length will be larger than the raw string length,\nif you want to get the raw string length, you should call this->getString().size() instead\nreturn  string length.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string stringValue},${2:#string charMapFile},${3:#int itemWidth},${4:#int itemHeight},${5:#string startCharMap})",
                    "detail": "@overload self, string, string, int, int, string         \n@overload self         \n"
                },
                "setProperty": {
                    "type": "method",
                    "define": "setProperty(${1:#string stringValue},${2:#string charMapFile},${3:#int itemWidth},${4:#int itemHeight},${5:#string startCharMap})",
                    "detail": " Initializes the LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas.\nparam stringValue A given string needs to be displayed.\nparam charMapFile A given char map file name.\nparam itemWidth The element width.\nparam itemHeight The element height.\nparam startCharMap The starting char of the atlas.\n"
                }
            },
            "Text": {
                "1": "new",
                "enableShadow": {
                    "type": "method",
                    "define": "enableShadow()",
                    "detail": "Enable shadow for the label.\ntodo support blur for shadow effect\nparam shadowColor The color of shadow effect.\nparam offset The offset of shadow effect.\nparam blurRadius The blur radius of shadow effect.\n"
                },
                "setTextHorizontalAlignment": {
                    "type": "method",
                    "define": "setTextHorizontalAlignment(${1:#int alignment})",
                    "detail": " Sets text horizontal alignment.\nparam alignment Horizontal text alignment type\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string textContent},${2:#string fontName},${3:#float fontSize})",
                    "detail": "@overload self, string, string, float         \n@overload self         \n"
                },
                "getType": {
                    "type": "method",
                    "define": "getType()",
                    "detail": " Gets the font type.\nreturn The font type.\n"
                },
                "getAutoRenderSize": {
                    "type": "method",
                    "define": "getAutoRenderSize()",
                    "detail": " Gets the render size in auto mode.\nreturn The size of render size in auto mode.\n"
                },
                "getFontName": {
                    "type": "method",
                    "define": "getFontName()",
                    "detail": " Gets the font name.\nreturn Font name.\n"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()"
                },
                "getTextColor": {
                    "type": "method",
                    "define": "getTextColor()",
                    "detail": " Gets text color.\nreturn Text color.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "getShadowOffset": {
                    "type": "method",
                    "define": "getShadowOffset()",
                    "detail": "Return shadow effect offset value.\n"
                },
                "getLetter": {
                    "type": "method",
                    "define": "getLetter(${1:#int lettetIndex})",
                    "detail": "Provides a way to treat each character like a Sprite.\nwarning No support system font.\n"
                },
                "getTextHorizontalAlignment": {
                    "type": "method",
                    "define": "getTextHorizontalAlignment()",
                    "detail": " Gets text horizontal alignment.\nreturn Horizontal text alignment type\n"
                },
                "getFontSize": {
                    "type": "method",
                    "define": "getFontSize()",
                    "detail": "Gets the font size of label.\nreturn The font size.\n"
                },
                "disableEffect": {
                    "type": "method",
                    "define": "disableEffect(${1:#int effect})",
                    "detail": "@overload self, int         \n@overload self         \n"
                },
                "setTouchScaleChangeEnabled": {
                    "type": "method",
                    "define": "setTouchScaleChangeEnabled(${1:#bool enabled})",
                    "detail": "Sets the touch scale enabled of label.\nparam enabled Touch scale enabled of label.\n"
                },
                "getEffectColor": {
                    "type": "method",
                    "define": "getEffectColor()",
                    "detail": "Return current effect color value.\n"
                },
                "getLabelEffectType": {
                    "type": "method",
                    "define": "getLabelEffectType()",
                    "detail": "Return current effect type.\n"
                },
                "getOutlineSize": {
                    "type": "method",
                    "define": "getOutlineSize()",
                    "detail": "Return the outline effect size value.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "setFontName": {
                    "type": "method",
                    "define": "setFontName(${1:#string name})",
                    "detail": "Sets the font name of label.\nIf you are trying to use a system font, you could just pass a font name\nIf you are trying to use a TTF, you should pass a file path to the TTF file\nUsage:\ncode\ncreate a system font UIText\nText *text = Text::create(\"Hello\", \"Arial\", 20);\nit will change the font to system font no matter the previous font type is TTF or system font\ntext->setFontName(\"Marfelt\");\nit will change the font to TTF font no matter the previous font type is TTF or system font\ntext->setFontName(\"xxxx/xxx.ttf\");\nendcode\nparam name Font name.\n"
                },
                "getShadowBlurRadius": {
                    "type": "method",
                    "define": "getShadowBlurRadius()",
                    "detail": "Return the shadow effect blur radius.\n"
                },
                "getStringLength": {
                    "type": "method",
                    "define": "getStringLength()",
                    "detail": "Gets the string length of the label.\nNote: This length will be larger than the raw string length,\nif you want to get the raw string length,\nyou should call this->getString().size() instead.\nreturn  String length.\n"
                },
                "getShadowColor": {
                    "type": "method",
                    "define": "getShadowColor()",
                    "detail": "Return the shadow effect color value.\n"
                },
                "isTouchScaleChangeEnabled": {
                    "type": "method",
                    "define": "isTouchScaleChangeEnabled()",
                    "detail": "Gets the touch scale enabled of label.\nreturn  Touch scale enabled of label.\n"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string text})"
                },
                "setTextColor": {
                    "type": "method",
                    "define": "setTextColor(${1:#color4b_table color})",
                    "detail": " Sets text color.\nparam color Text color.\n"
                },
                "getTextAreaSize": {
                    "type": "method",
                    "define": "getTextAreaSize()",
                    "detail": " Return the text rendering area size.\nreturn The text rendering area size.\n"
                },
                "isShadowEnabled": {
                    "type": "method",
                    "define": "isShadowEnabled()",
                    "detail": "Return whether the shadow effect is enabled.\n"
                },
                "setTextAreaSize": {
                    "type": "method",
                    "define": "setTextAreaSize(${1:#size_table size})",
                    "detail": "Sets the rendering size of the text, you should call this method\nalong with calling `ignoreContentAdaptWithSize(false)`, otherwise the text area\nsize is calculated by the real size of the text content.\nparam size The text rendering area size.\n"
                },
                "setFontSize": {
                    "type": "method",
                    "define": "setFontSize(${1:#float size})",
                    "detail": "Sets the font size of label.\nparam size The font size.\n"
                },
                "enableGlow": {
                    "type": "method",
                    "define": "enableGlow(${1:#color4b_table glowColor})",
                    "detail": " Only support for TTF.\nparam glowColor The color of glow.\n"
                },
                "setTextVerticalAlignment": {
                    "type": "method",
                    "define": "setTextVerticalAlignment(${1:#int alignment})",
                    "detail": " Sets text vertical alignment.\nparam alignment vertical text alignment type\n"
                },
                "getTextVerticalAlignment": {
                    "type": "method",
                    "define": "getTextVerticalAlignment()",
                    "detail": " Gets text vertical alignment.\nreturn Vertical text alignment type\n"
                },
                "enableOutline": {
                    "type": "method",
                    "define": "enableOutline(${1:#color4b_table outlineColor},${2:#int outlineSize})",
                    "detail": "Enable outline for the label.\nIt only works on IOS and Android when you use System fonts.\nparam outlineColor The color of outline.\nparam outlineSize The size of outline.\n"
                }
            },
            "RadioButton": {
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#string backGround},${2:#string backGroundSelected},${3:#string cross},${4:#string backGroundDisabled},${5:#string frontCrossDisabled},${6:#int texType})",
                    "detail": "@overload self, string, string, string, string, string, int         \n@overload self         \n@overload self, string, string, int         \n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add a callback function which would be called when radio button is selected or unselected.\nparam callback A std::function with type @see `ccRadioButtonCallback`\n"
                }
            },
            "RelativeLayoutParameter": {
                "1": "new",
                "getRelativeToWidgetName": {
                    "type": "method",
                    "define": "getRelativeToWidgetName()",
                    "detail": "Get the relative widget name.\nreturn name A relative widget name in string.\n"
                },
                "setAlign": {
                    "type": "method",
                    "define": "setAlign(${1:#int align})",
                    "detail": "Sets RelativeAlign parameter for LayoutParameter.\nsee RelativeAlign\nparam align Relative align in  `RelativeAlign`.\n"
                },
                "getRelativeName": {
                    "type": "method",
                    "define": "getRelativeName()",
                    "detail": "Get a name of LayoutParameter in Relative Layout.\nreturn name Relative name in string.\n"
                },
                "setRelativeToWidgetName": {
                    "type": "method",
                    "define": "setRelativeToWidgetName(${1:#string name})",
                    "detail": "Set widget name your widget want to relative to.\nparam name Relative widget name.\n"
                },
                "getAlign": {
                    "type": "method",
                    "define": "getAlign()",
                    "detail": "Get RelativeAlign parameter for LayoutParameter.\nsee RelativeAlign\nreturn  A RelativeAlign variable.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create a RelativeLayoutParameter instance.\nreturn A initialized LayoutParameter which is marked as \"autorelease\".\n"
                },
                "setRelativeName": {
                    "type": "method",
                    "define": "setRelativeName(${1:#string name})",
                    "detail": "Set a name for LayoutParameter in Relative Layout.\nparam name A string name.\n"
                }
            },
            "RadioButtonEventType": [
                "selected",
                "unselected"
            ],
            "TabControl": {
                "isIgnoreHeadersTextureSize": {
                    "type": "method",
                    "define": "isIgnoreHeadersTextureSize()",
                    "detail": "get whether ignore the textures' size in header, scale them with _headerWidth and _headerHeight\nreturn whether ignore the textures' size in header\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "removeTab": {
                    "type": "method",
                    "define": "removeTab(${1:#int index})",
                    "detail": "remove the tab from this TabControl\nparam index The index of tab\n"
                },
                "getHeaderHeight": {
                    "type": "method",
                    "define": "getHeaderHeight()",
                    "detail": "get tab header's height\nreturn header's height\n"
                },
                "setHeaderWidth": {
                    "type": "method",
                    "define": "setHeaderWidth(${1:#float headerWidth})",
                    "detail": "set header width, affect all tab\nparam headerWidth each tab header's width\n"
                },
                "getSelectedTabIndex": {
                    "type": "method",
                    "define": "getSelectedTabIndex()",
                    "detail": "get current selected tab's index\nreturn the current selected tab index\n"
                },
                "getTabCount": {
                    "type": "method",
                    "define": "getTabCount()",
                    "detail": "get the count of tabs in this TabControl\nreturn the count of tabs\n"
                },
                "getHeaderSelectedZoom": {
                    "type": "method",
                    "define": "getHeaderSelectedZoom()",
                    "detail": "get the delta zoom of selected tab\nreturn zoom, the delta zoom\n"
                },
                "getHeaderDockPlace": {
                    "type": "method",
                    "define": "getHeaderDockPlace()"
                },
                "getTabContainer": {
                    "type": "method",
                    "define": "getTabContainer(${1:#int index})",
                    "detail": "get Container\nparam index The index of tab\n"
                },
                "getHeaderWidth": {
                    "type": "method",
                    "define": "getHeaderWidth()",
                    "detail": "get tab header's width\nreturn header's width\n"
                },
                "setHeaderDockPlace": {
                    "type": "method",
                    "define": "setHeaderDockPlace(${1:#int dockPlace})",
                    "detail": "the header dock place of header in TabControl\nparam dockPlace The strip place\n"
                },
                "setTabChangedEventListener": {
                    "type": "method",
                    "define": "setTabChangedEventListener(${1:#function callback})",
                    "detail": "Add a callback function which would be called when selected tab changed\nparam callback A std::function with type @see `ccTabControlCallback`\n"
                },
                "setSelectTab": {
                    "type": "method",
                    "define": "setSelectTab(${1:#int index})",
                    "detail": "@overload self, ccui.TabHeader         \n@overload self, int         \n"
                },
                "setHeaderSelectedZoom": {
                    "type": "method",
                    "define": "setHeaderSelectedZoom(${1:#float zoom})",
                    "detail": "set the delta zoom of selected tab\nparam zoom The delta zoom\n"
                },
                "getTabHeader": {
                    "type": "method",
                    "define": "getTabHeader(${1:#int index})",
                    "detail": "get TabHeader\nparam index The index of tab\n"
                },
                "indexOfTabHeader": {
                    "type": "method",
                    "define": "indexOfTabHeader(${1:#ccui.TabHeader tabCell})",
                    "detail": "get the index of tabCell in TabView, return -1 if not exists in.\nreturn the index of tabCell in TabView, `-1` means not exists in.\n"
                },
                "setHeaderHeight": {
                    "type": "method",
                    "define": "setHeaderHeight(${1:#float headerHeight})",
                    "detail": "set header height, affect all tab\nparam headerHeight each tab header's height\n"
                },
                "insertTab": {
                    "type": "method",
                    "define": "insertTab(${1:#int index},${2:#ccui.TabHeader header},${3:#ccui.Layout container})",
                    "detail": "insert tab, and init the position of header and container\nparam index The index tab should be\nparam header The header Button, will be a protected child in TabControl\nparam container The container, will be a protected child in TabControl\n"
                },
                "ignoreHeadersTextureSize": {
                    "type": "method",
                    "define": "ignoreHeadersTextureSize(${1:#bool ignore})",
                    "detail": "ignore the textures' size in header, scale them with _headerWidth and _headerHeight\nparam ignore is `true`, the header's texture scale with _headerWidth and _headerHeight\nignore is `false`, use the texture's size, do not scale them\n"
                }
            },
            "Scale9Sprite": {
                "1": "new",
                "updateWithSprite": {
                    "type": "method",
                    "define": "updateWithSprite(${1:#cc.Sprite sprite},${2:#rect_table rect},${3:#bool rotated},${4:#vec2_table offset},${5:#size_table originalSize},${6:#rect_table capInsets})",
                    "detail": "@overload self, cc.Sprite, rect_table, bool, vec2_table, size_table, rect_table         \n@overload self, cc.Sprite, rect_table, bool, rect_table         \n"
                },
                "setState": {
                    "type": "method",
                    "define": "setState(${1:#int state})",
                    "detail": "Change the state of 9-slice sprite.\nsee `State`\nparam state A enum value in State.\nsince v3.4\n"
                },
                "getInsetRight": {
                    "type": "method",
                    "define": "getInsetRight()",
                    "detail": "brief Query the right sprite's cap inset.\nreturn The right sprite's cap inset.\n"
                },
                "isScale9Enabled": {
                    "type": "method",
                    "define": "isScale9Enabled()",
                    "detail": "brief Query whether the Scale9Sprite is enable 9-slice or not.\nreturn True if 9-slice is enabled, false otherwise.\njs NA\n"
                },
                "getRenderingType": {
                    "type": "method",
                    "define": "getRenderingType()",
                    "detail": "Return the slice sprite rendering type.\n"
                },
                "setCapInsets": {
                    "type": "method",
                    "define": "setCapInsets(${1:#rect_table insets})",
                    "detail": "Set the Cap Insets in Points using the untrimmed size as reference\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string file},${2:#rect_table rect},${3:#rect_table capInsets})",
                    "detail": "@overload self, string, rect_table, rect_table         \n@overload self         \n@overload self, rect_table, string         \n@overload self, string, rect_table         \n@overload self, string         \n"
                },
                "getOriginalSize": {
                    "type": "method",
                    "define": "getOriginalSize()",
                    "detail": "brief Query the sprite's original size.\nreturn Sprite size.\n"
                },
                "setInsetLeft": {
                    "type": "method",
                    "define": "setInsetLeft(${1:#float leftInset})",
                    "detail": "brief Change the left sprite's cap inset.\nparam leftInset The values to use for the cap inset.\n"
                },
                "copyTo": {
                    "type": "method",
                    "define": "copyTo(${1:#ccui.Scale9Sprite copy})",
                    "detail": "brief copies self to copy\n"
                },
                "setInsetRight": {
                    "type": "method",
                    "define": "setInsetRight(${1:#float rightInset})",
                    "detail": "brief Change the right sprite's cap inset.\nparam rightInset The values to use for the cap inset.\n"
                },
                "getPreferredSize": {
                    "type": "method",
                    "define": "getPreferredSize()",
                    "detail": "brief Query the Scale9Sprite's preferred size.\nreturn Scale9Sprite's preferred size.\n"
                },
                "createWithSpriteFrame": {
                    "type": "method",
                    "define": "createWithSpriteFrame(${1:#cc.SpriteFrame spriteFrame},${2:#rect_table capInsets})",
                    "detail": "@overload self, cc.SpriteFrame, rect_table         \n@overload self, cc.SpriteFrame         \n"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": "@overload self, cc.Sprite, rect_table, rect_table         \n@overload self, cc.Sprite, rect_table, bool, rect_table         \n@overload self, cc.Sprite, rect_table, bool, vec2_table, size_table, rect_table         \n"
                },
                "getInsetLeft": {
                    "type": "method",
                    "define": "getInsetLeft()",
                    "detail": "brief Query the left sprite's cap inset.\nreturn The left sprite's cap inset.\n"
                },
                "setScale9Enabled": {
                    "type": "method",
                    "define": "setScale9Enabled(${1:#bool enabled})",
                    "detail": "brief Toggle 9-slice feature.\nIf Scale9Sprite is 9-slice disabled, the Scale9Sprite will rendered as a normal sprite.\nwarning: Don't use setScale9Enabled(false), use setRenderingType(RenderingType::SIMPLE) instead.\nThe setScale9Enabled(false) is kept only for back back compatibility.\nparam enabled True to enable 9-slice, false otherwise.\njs NA\n"
                },
                "setInsetTop": {
                    "type": "method",
                    "define": "setInsetTop(${1:#float topInset})",
                    "detail": "brief Change the top sprite's cap inset.\nparam topInset The values to use for the cap inset.\n"
                },
                "getCapInsets": {
                    "type": "method",
                    "define": "getCapInsets()",
                    "detail": "Returns the Cap Insets\n"
                },
                "initWithSpriteFrame": {
                    "type": "method",
                    "define": "initWithSpriteFrame(${1:#cc.SpriteFrame spriteFrame},${2:#rect_table capInsets})",
                    "detail": "Initializes a 9-slice sprite with an sprite frame and with the specified\ncap insets.\nOnce the sprite is created, you can then call its \"setContentSize:\" method\nto resize the sprite will all it's 9-slice goodness interact.\nIt respects the anchorPoint too.\nparam spriteFrame The sprite frame object.\nparam capInsets The values to use for the cap insets.\nreturn True if initializes success, false otherwise.\n"
                },
                "setInsetBottom": {
                    "type": "method",
                    "define": "setInsetBottom(${1:#float bottomInset})",
                    "detail": "brief Change the bottom sprite's cap inset.\nparam bottomInset The values to use for the cap inset.\n"
                },
                "initWithSpriteFrameName": {
                    "type": "method",
                    "define": "initWithSpriteFrameName(${1:#string spriteFrameName})",
                    "detail": "Initializes a 9-slice sprite with an sprite frame name.\nOnce the sprite is created, you can then call its \"setContentSize:\" method\nto resize the sprite will all it's 9-slice goodness interact.\nIt respects the anchorPoint too.\nparam spriteFrameName The sprite frame name.\nreturn True if initializes success, false otherwise.\n"
                },
                "getState": {
                    "type": "method",
                    "define": "getState()",
                    "detail": "Query the current bright state.\nreturn @see `State`\nsince v3.7\n"
                },
                "getSprite": {
                    "type": "method",
                    "define": "getSprite()",
                    "detail": "brief Get the original no 9-sliced sprite\nreturn A sprite instance.\n"
                },
                "createWithSpriteFrameName": {
                    "type": "method",
                    "define": "createWithSpriteFrameName(${1:#string spriteFrameName},${2:#rect_table capInsets})",
                    "detail": "@overload self, string, rect_table         \n@overload self, string         \n"
                },
                "resizableSpriteWithCapInsets": {
                    "type": "method",
                    "define": "resizableSpriteWithCapInsets(${1:#rect_table capInsets})",
                    "detail": "Creates and returns a new sprite object with the specified cap insets.\nYou use this method to add cap insets to a sprite or to change the existing\ncap insets of a sprite. In both cases, you get back a new image and the\noriginal sprite remains untouched.\nparam capInsets The values to use for the cap insets.\nreturn A Scale9Sprite instance.\n"
                },
                "setRenderingType": {
                    "type": "method",
                    "define": "setRenderingType(${1:#int type})",
                    "detail": "Set the slice sprite rendering type.\nWhen setting to SIMPLE, only 4 vertexes is used to rendering.\notherwise 16 vertexes will be used to rendering.\nsee RenderingType\n"
                },
                "getInsetBottom": {
                    "type": "method",
                    "define": "getInsetBottom()",
                    "detail": "brief Query the bottom sprite's cap inset.\nreturn The bottom sprite's cap inset.\n"
                },
                "setSpriteFrame": {
                    "type": "method",
                    "define": "setSpriteFrame(${1:#cc.SpriteFrame spriteFrame},${2:#rect_table capInsets})",
                    "detail": "brief Change inner sprite's sprite frame.\nparam spriteFrame A sprite frame pointer.\nparam capInsets The values to use for the cap insets.\n"
                },
                "getInsetTop": {
                    "type": "method",
                    "define": "getInsetTop()",
                    "detail": "brief Query the top sprite's cap inset.\nreturn The top sprite's cap inset.\n"
                },
                "resetRender": {
                    "type": "method",
                    "define": "resetRender()"
                },
                "initWithFile": {
                    "type": "method",
                    "define": "initWithFile(${1:#string file},${2:#rect_table rect})",
                    "detail": "@overload self, string         \n@overload self, string, rect_table         \n"
                },
                "setPreferredSize": {
                    "type": "method",
                    "define": "setPreferredSize(${1:#size_table size})",
                    "detail": "brief Change the preferred size of Scale9Sprite.\nparam size A delimitation zone.\n"
                }
            },
            "ListView": {
                "1": "addScrollViewEventListener",
                "2": "new",
                "scrollToItem": {
                    "type": "method",
                    "define": "scrollToItem(${1:#int itemIndex},${2:#vec2_table positionRatioInView},${3:#vec2_table itemAnchorPoint},${4:#float timeInSec})",
                    "detail": "@overload self, int, vec2_table, vec2_table, float         \n@overload self, int, vec2_table, vec2_table         \n"
                },
                "setItemsMargin": {
                    "type": "method",
                    "define": "setItemsMargin(${1:#float margin})",
                    "detail": "Set the margin between each item in ListView.\nparam margin A margin in float.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create an empty ListView.\nreturn A ListView instance.\n"
                },
                "getItemsMargin": {
                    "type": "method",
                    "define": "getItemsMargin()",
                    "detail": "brief Query margin between each item in ListView.\nreturn A margin in float.\n"
                },
                "getItem": {
                    "type": "method",
                    "define": "getItem(${1:#int index})",
                    "detail": "Return an item at a given index.\nparam index A given index in ssize_t.\nreturn A widget instance.\n"
                },
                "setGravity": {
                    "type": "method",
                    "define": "setGravity(${1:#int gravity})",
                    "detail": "Set the gravity of ListView.\nsee `ListViewGravity`\n"
                },
                "removeLastItem": {
                    "type": "method",
                    "define": "removeLastItem()",
                    "detail": "Removes the last item of ListView.\n"
                },
                "getScrollDuration": {
                    "type": "method",
                    "define": "getScrollDuration()",
                    "detail": "Get the time in seconds to scroll between items.\nreturn The time in seconds to scroll between items\nsee setScrollDuration(float)\n"
                },
                "getTopmostItemInCurrentView": {
                    "type": "method",
                    "define": "getTopmostItemInCurrentView()",
                    "detail": "brief Query the topmost item in horizontal list\nreturn An item instance.\n"
                },
                "getClosestItemToPositionInCurrentView": {
                    "type": "method",
                    "define": "getClosestItemToPositionInCurrentView(${1:#vec2_table positionRatioInView},${2:#vec2_table itemAnchorPoint})",
                    "detail": "brief Query the closest item to a specific position in current view.\nFor instance, to find the item in the center of view, call 'getClosestItemToPositionInCurrentView(Vec2::ANCHOR_MIDDLE, Vec2::ANCHOR_MIDDLE)'.\nparam positionRatioInView Specifies the target position with ratio in list view's content size.\nparam itemAnchorPoint Specifies an anchor point of each item for position to calculate distance.\nreturn An item instance if list view is not empty. Otherwise, returns null.\n"
                },
                "getClosestItemToPosition": {
                    "type": "method",
                    "define": "getClosestItemToPosition(${1:#vec2_table targetPosition},${2:#vec2_table itemAnchorPoint})",
                    "detail": "brief Query the closest item to a specific position in inner container.\nparam targetPosition Specifies the target position in inner container's coordinates.\nparam itemAnchorPoint Specifies an anchor point of each item for position to calculate distance.\nreturn An item instance if list view is not empty. Otherwise, returns null.\n"
                },
                "getMagneticAllowedOutOfBoundary": {
                    "type": "method",
                    "define": "getMagneticAllowedOutOfBoundary()",
                    "detail": "Query whether the magnetic out of boundary is allowed.\n"
                },
                "insertCustomItem": {
                    "type": "method",
                    "define": "insertCustomItem(${1:#ccui.Widget item},${2:#int index})",
                    "detail": "brief Insert a custom widget into ListView at a given index.\nparam item A widget pointer to be inserted.\nparam index A given index in ssize_t.\n"
                },
                "setScrollDuration": {
                    "type": "method",
                    "define": "setScrollDuration(${1:#float time})",
                    "detail": "Set the time in seconds to scroll between items.\nSubsequent calls of function 'scrollToItem', will take 'time' seconds for scrolling.\nparam time The seconds needed to scroll between two items. 'time' must be >= 0\nsee scrollToItem(ssize_t, const Vec2&, const Vec2&)\n"
                },
                "getMagneticType": {
                    "type": "method",
                    "define": "getMagneticType()",
                    "detail": "Get magnetic type of ListView.\n"
                },
                "getItems": {
                    "type": "method",
                    "define": "getItems()",
                    "detail": "Return all items in a ListView.\nreturns A vector of widget pointers.\n"
                },
                "getRightmostItemInCurrentView": {
                    "type": "method",
                    "define": "getRightmostItemInCurrentView()",
                    "detail": "brief Query the rightmost item in horizontal list\nreturn An item instance.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "getIndex": {
                    "type": "method",
                    "define": "getIndex(${1:#ccui.Widget item})",
                    "detail": "Return the index of specified widget.\nparam item  A widget pointer.\nreturn The index of a given widget in ListView.\n"
                },
                "removeAllItems": {
                    "type": "method",
                    "define": "removeAllItems()",
                    "detail": "brief Remove all items in current ListView.\n"
                },
                "setItemModel": {
                    "type": "method",
                    "define": "setItemModel(${1:#ccui.Widget model})",
                    "detail": "Set an item model for listview.\nWhen calling `pushBackDefaultItem`, the model will be used as a blueprint and new model copy will be inserted into ListView.\nparam model  Model in `Widget*`.\n"
                },
                "pushBackCustomItem": {
                    "type": "method",
                    "define": "pushBackCustomItem(${1:#ccui.Widget item})",
                    "detail": "Insert a  custom item into the end of ListView.\nparam item An item in `Widget*`.\n"
                },
                "getCenterItemInCurrentView": {
                    "type": "method",
                    "define": "getCenterItemInCurrentView()",
                    "detail": "brief Query the center item\nreturn An item instance.\n"
                },
                "getLeftmostItemInCurrentView": {
                    "type": "method",
                    "define": "getLeftmostItemInCurrentView()",
                    "detail": "brief Query the leftmost item in horizontal list\nreturn An item instance.\n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add an event click callback to ListView, then one item of Listview is clicked, the callback will be called.\nparam callback A callback function with type of `ccListViewCallback`.\n"
                },
                "setCurSelectedIndex": {
                    "type": "method",
                    "define": "setCurSelectedIndex(${1:#int itemIndex})",
                    "detail": "brief Set current selected widget's index and call TouchEventType::ENDED event.\nparam itemIndex A index of a selected item.\n"
                },
                "getBottommostItemInCurrentView": {
                    "type": "method",
                    "define": "getBottommostItemInCurrentView()",
                    "detail": "brief Query the bottommost item in horizontal list\nreturn An item instance.\n"
                },
                "3": "setStartDirection",
                "setMagneticType": {
                    "type": "method",
                    "define": "setMagneticType(${1:#int magneticType})",
                    "detail": "Set magnetic type of ListView.\nsee `MagneticType`\n"
                },
                "setMagneticAllowedOutOfBoundary": {
                    "type": "method",
                    "define": "setMagneticAllowedOutOfBoundary(${1:#bool magneticAllowedOutOfBoundary})",
                    "detail": "Set magnetic allowed out of boundary.\n"
                },
                "getCurSelectedIndex": {
                    "type": "method",
                    "define": "getCurSelectedIndex()",
                    "detail": "brief Query current selected widget's index.\nreturn An index of a selected item.\n"
                },
                "jumpToItem": {
                    "type": "method",
                    "define": "jumpToItem(${1:#int itemIndex},${2:#vec2_table positionRatioInView},${3:#vec2_table itemAnchorPoint})",
                    "detail": "brief Jump to specific item\nparam itemIndex Specifies the item's index\nparam positionRatioInView Specifies the position with ratio in list view's content size.\nparam itemAnchorPoint Specifies an anchor point of each item for position to calculate distance.\n"
                },
                "pushBackDefaultItem": {
                    "type": "method",
                    "define": "pushBackDefaultItem()",
                    "detail": "Insert a default item(create by a cloned model) at the end of the listview.\n"
                },
                "insertDefaultItem": {
                    "type": "method",
                    "define": "insertDefaultItem(${1:#int index})",
                    "detail": "Insert a default item(create by cloning model) into listview at a give index.\nparam index  An index in ssize_t.\n"
                },
                "doLayout": {
                    "type": "method",
                    "define": "doLayout()"
                },
                "removeItem": {
                    "type": "method",
                    "define": "removeItem(${1:#int index})",
                    "detail": "Remove an item at given index.\nparam index A given index in ssize_t.\n"
                }
            },
            "SliderEventType": [
                "percentChanged",
                "slideBallCancel",
                "slideBallDown",
                "slideBallUp"
            ],
            "SizeType": [
                "absolute",
                "percent"
            ],
            "PageViewDirection": [
                "BOTH",
                "HORIZONTAL",
                "NONE",
                "VERTICAL"
            ],
            "EditBox": {
                "1": "new",
                "setPlaceholderFont": {
                    "type": "method",
                    "define": "setPlaceholderFont(${1:#char pFontName},${2:#int fontSize})",
                    "detail": "Set the placeholder's font. Only system font is allowed.\nparam pFontName The font name.\nparam fontSize The font size.\n"
                },
                "setTextHorizontalAlignment": {
                    "type": "method",
                    "define": "setTextHorizontalAlignment(${1:#int alignment})",
                    "detail": "Set the text horizontal alignment.\n"
                },
                "setFontColor": {
                    "type": "method",
                    "define": "setFontColor(${1:#color3b_table color})",
                    "detail": "@overload self, color4b_table         \n@overload self, color3b_table         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table size},${2:#ccui.Scale9Sprite normalSprite},${3:#ccui.Scale9Sprite pressedSprite},${4:#ccui.Scale9Sprite disabledSprite})",
                    "detail": "@overload self, size_table, string, int         \n@overload self, size_table, ccui.Scale9Sprite, ccui.Scale9Sprite, ccui.Scale9Sprite         \n"
                },
                "registerScriptEditBoxHandler": {
                    "type": "method",
                    "define": "registerScriptEditBoxHandler(${1:#int handler})",
                    "detail": "Registers a script function that will be called for EditBox events.\nThis handler will be removed automatically after onExit() called.\ncode\nlua sample\nlocal function editboxEventHandler(eventType)\nif eventType == \"began\" then\ntriggered when an edit box gains focus after keyboard is shown\nelseif eventType == \"ended\" then\ntriggered when an edit box loses focus after keyboard is hidden.\nelseif eventType == \"changed\" then\ntriggered when the edit box text was changed.\nelseif eventType == \"return\" then\ntriggered when the return button was pressed or the outside area of keyboard was touched.\nend\nend\nlocal editbox = EditBox:create(Size(...), Scale9Sprite:create(...))\neditbox = registerScriptEditBoxHandler(editboxEventHandler)\nendcode\nparam handler A number that indicates a lua function.\njs NA\nlua NA\n"
                },
                "getFontName": {
                    "type": "method",
                    "define": "getFontName()",
                    "detail": "Get the font name.\nreturn The font name.\n"
                },
                "setFont": {
                    "type": "method",
                    "define": "setFont(${1:#char pFontName},${2:#int fontSize})",
                    "detail": "Set the font. Only system font is allowed.\nparam pFontName The font name.\nparam fontSize The font size.\n"
                },
                "initWithSizeAndBackgroundSprite": {
                    "type": "method",
                    "define": "initWithSizeAndBackgroundSprite(${1:#size_table size},${2:#string normal9SpriteBg},${3:#int texType})",
                    "detail": "@overload self, size_table, ccui.Scale9Sprite         \n@overload self, size_table, string, int         \n"
                },
                "keyboardWillShow": {
                    "type": "method",
                    "define": "keyboardWillShow(${1:#cc.IMEKeyboardNotificationInfo info})",
                    "detail": "js NA\nlua NA\n"
                },
                "getTextHorizontalAlignment": {
                    "type": "method",
                    "define": "getTextHorizontalAlignment()",
                    "detail": "Get the text horizontal alignment.\n"
                },
                "setPlaceholderFontName": {
                    "type": "method",
                    "define": "setPlaceholderFontName(${1:#char pFontName})",
                    "detail": "Set the placeholder's font name. only system font is allowed.\nparam pFontName The font name.\n"
                },
                "getFontSize": {
                    "type": "method",
                    "define": "getFontSize()",
                    "detail": "Get the font size.\nreturn The font size.\n"
                },
                "unregisterScriptEditBoxHandler": {
                    "type": "method",
                    "define": "unregisterScriptEditBoxHandler()",
                    "detail": "Unregisters a script function that will be called for EditBox events.\njs NA\nlua NA\n"
                },
                "getInputFlag": {
                    "type": "method",
                    "define": "getInputFlag()",
                    "detail": "Get the input flags that are to be applied to the edit box.\nreturn One of the EditBox::InputFlag constants.\n"
                },
                "getMaxLength": {
                    "type": "method",
                    "define": "getMaxLength()",
                    "detail": "Gets the maximum input length of the edit box.\nreturn Maximum input length.\n"
                },
                "keyboardWillHide": {
                    "type": "method",
                    "define": "keyboardWillHide(${1:#cc.IMEKeyboardNotificationInfo info})",
                    "detail": "js NA\nlua NA\n"
                },
                "getPlaceHolder": {
                    "type": "method",
                    "define": "getPlaceHolder()",
                    "detail": "Get a text in the edit box that acts as a placeholder when an\nedit box is empty.\n"
                },
                "setPlaceholderFontColor": {
                    "type": "method",
                    "define": "setPlaceholderFontColor(${1:#color3b_table color})",
                    "detail": "@overload self, color4b_table         \n@overload self, color3b_table         \n"
                },
                "setPlaceHolder": {
                    "type": "method",
                    "define": "setPlaceHolder(${1:#char pText})",
                    "detail": "Set a text in the edit box that acts as a placeholder when an\nedit box is empty.\nparam pText The given text.\n"
                },
                "setFontName": {
                    "type": "method",
                    "define": "setFontName(${1:#char pFontName})",
                    "detail": "Set the font name. Only system font is allowed.\nparam pFontName The font name.\n"
                },
                "setInputFlag": {
                    "type": "method",
                    "define": "setInputFlag(${1:#int inputFlag})",
                    "detail": "Set the input flags that are to be applied to the edit box.\nparam inputFlag One of the EditBox::InputFlag constants.\n"
                },
                "setPlaceholderFontSize": {
                    "type": "method",
                    "define": "setPlaceholderFontSize(${1:#int fontSize})",
                    "detail": "Set the placeholder's font size.\nparam fontSize The font size.\n"
                },
                "getText": {
                    "type": "method",
                    "define": "getText()",
                    "detail": "Get the text entered in the edit box.\nreturn The text entered in the edit box.\n"
                },
                "getPlaceholderFontName": {
                    "type": "method",
                    "define": "getPlaceholderFontName()",
                    "detail": "Get the placeholder's font name. only system font is allowed.\nreturn The font name.\n"
                },
                "touchDownAction": {
                    "type": "method",
                    "define": "touchDownAction(${1:#cc.Ref sender},${2:#int controlEvent})"
                },
                "setText": {
                    "type": "method",
                    "define": "setText(${1:#char pText})",
                    "detail": "Set the text entered in the edit box.\nparam pText The given text.\n"
                },
                "setReturnType": {
                    "type": "method",
                    "define": "setReturnType(${1:#int returnType})",
                    "detail": "Set the return type that are to be applied to the edit box.\nparam returnType One of the EditBox::KeyboardReturnType constants.\n"
                },
                "getScriptEditBoxHandler": {
                    "type": "method",
                    "define": "getScriptEditBoxHandler()",
                    "detail": "get a script Handler\njs NA\nlua NA\n"
                },
                "setFontSize": {
                    "type": "method",
                    "define": "setFontSize(${1:#int fontSize})",
                    "detail": "Set the font size.\nparam fontSize The font size.\n"
                },
                "getPlaceholderFontColor": {
                    "type": "method",
                    "define": "getPlaceholderFontColor()",
                    "detail": "Get the font color of the placeholder text when the edit box is empty.\n"
                },
                "keyboardDidHide": {
                    "type": "method",
                    "define": "keyboardDidHide(${1:#cc.IMEKeyboardNotificationInfo info})",
                    "detail": "js NA\nlua NA\n"
                },
                "getFontColor": {
                    "type": "method",
                    "define": "getFontColor()",
                    "detail": "Get the font color of the widget's text.\n"
                },
                "keyboardDidShow": {
                    "type": "method",
                    "define": "keyboardDidShow(${1:#cc.IMEKeyboardNotificationInfo info})",
                    "detail": "js NA\nlua NA\n"
                },
                "setInputMode": {
                    "type": "method",
                    "define": "setInputMode(${1:#int inputMode})",
                    "detail": "Set the input mode of the edit box.\nparam inputMode One of the EditBox::InputMode constants.\n"
                },
                "getReturnType": {
                    "type": "method",
                    "define": "getReturnType()",
                    "detail": "Get the return type that are to be applied to the edit box.\nreturn One of the EditBox::KeyboardReturnType constants.\n"
                },
                "getInputMode": {
                    "type": "method",
                    "define": "getInputMode()",
                    "detail": "Get the input mode of the edit box.\nreturn One of the EditBox::InputMode constants.\n"
                },
                "setMaxLength": {
                    "type": "method",
                    "define": "setMaxLength(${1:#int maxLength})",
                    "detail": "Sets the maximum input length of the edit box.\nSetting this value enables multiline input mode by default.\nAvailable on Android, iOS and Windows Phone.\nparam maxLength The maximum length.\n"
                },
                "getPlaceholderFontSize": {
                    "type": "method",
                    "define": "getPlaceholderFontSize()",
                    "detail": "Get the placeholder's font size.\nreturn The font size.\n"
                }
            },
            "Slider": {
                "loadBarTexture": {
                    "type": "method",
                    "define": "loadBarTexture(${1:#string fileName},${2:#int resType})",
                    "detail": "Load texture for slider bar.\nparam fileName   File name of texture.\nparam resType    @see TextureResType .\n"
                },
                "setPercent": {
                    "type": "method",
                    "define": "setPercent(${1:#int percent})",
                    "detail": "Changes the progress direction of slider.\nparam percent  Percent value from 1 to 100.\n"
                },
                "setScale9Enabled": {
                    "type": "method",
                    "define": "setScale9Enabled(${1:#bool able})",
                    "detail": "Sets if slider is using scale9 renderer.\nparam able True that using scale9 renderer, false otherwise.\n"
                },
                "isScale9Enabled": {
                    "type": "method",
                    "define": "isScale9Enabled()",
                    "detail": "Gets If slider is using scale9 renderer.\nreturn True that using scale9 renderer, false otherwise.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "getSlidBallDisabledRenderer": {
                    "type": "method",
                    "define": "getSlidBallDisabledRenderer()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string barTextureName},${2:#string normalBallTextureName},${3:#int resType})",
                    "detail": "@overload self, string, string, int         \n@overload self         \n"
                },
                "setZoomScale": {
                    "type": "method",
                    "define": "setZoomScale(${1:#float scale})",
                    "detail": " When user pressed the button, the button will zoom to a scale.\nThe final scale of the button  equals (button original scale + _zoomScale)\nsince v3.3\n"
                },
                "setMaxPercent": {
                    "type": "method",
                    "define": "setMaxPercent(${1:#int percent})",
                    "detail": "Set a large value could give more control to the precision.\nsince v3.7\nparam percent The max percent of Slider.\n"
                },
                "setCapInsets": {
                    "type": "method",
                    "define": "setCapInsets(${1:#rect_table capInsets})",
                    "detail": "Sets capinsets for slider, if slider is using scale9 renderer.\nparam capInsets Capinsets for slider.\n"
                },
                "getSlidBallNormalRenderer": {
                    "type": "method",
                    "define": "getSlidBallNormalRenderer()"
                },
                "getSlidBallRenderer": {
                    "type": "method",
                    "define": "getSlidBallRenderer()"
                },
                "getCapInsetsProgressBarRenderer": {
                    "type": "method",
                    "define": "getCapInsetsProgressBarRenderer()",
                    "detail": "Gets capinsets for progress bar slider, if slider is using scale9 renderer.\nreturn Capinsets for progress bar slider.\njs NA\n"
                },
                "1": "new",
                "setCapInsetsBarRenderer": {
                    "type": "method",
                    "define": "setCapInsetsBarRenderer(${1:#rect_table capInsets})",
                    "detail": "Sets capinsets for bar slider, if slider is using scale9 renderer.\nparam capInsets Capinsets for bar slider.\n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add call back function called when slider's percent has changed to slider.\nparam callback An given call back function called when slider's percent has changed to slider.\n"
                },
                "setCapInsetProgressBarRenderer": {
                    "type": "method",
                    "define": "setCapInsetProgressBarRenderer(${1:#rect_table capInsets})",
                    "detail": "Sets capinsets for progress bar slider, if slider is using scale9 renderer.\nparam capInsets Capinsets for progress bar slider.\njs NA\n"
                },
                "getSlidBallPressedRenderer": {
                    "type": "method",
                    "define": "getSlidBallPressedRenderer()"
                },
                "getMaxPercent": {
                    "type": "method",
                    "define": "getMaxPercent()",
                    "detail": "Query the maximum percent of Slider. The default value is 100.\nsince v3.7\nreturn The maximum percent of the Slider.\n"
                },
                "getPercent": {
                    "type": "method",
                    "define": "getPercent()",
                    "detail": "Gets the progress direction of slider.\nreturn percent Percent value from 1 to 100.\n"
                },
                "getBackFile": {
                    "type": "method",
                    "define": "getBackFile()"
                },
                "loadSlidBallTextures": {
                    "type": "method",
                    "define": "loadSlidBallTextures(${1:#string normal},${2:#string pressed},${3:#string disabled},${4:#int texType})",
                    "detail": "Load textures for slider ball.\nparam normal     Normal state texture.\nparam pressed    Pressed state texture.\nparam disabled    Disabled state texture.\nparam texType    @see TextureResType .\n"
                },
                "getZoomScale": {
                    "type": "method",
                    "define": "getZoomScale()",
                    "detail": "brief Return a zoom scale\nsince v3.3\n"
                },
                "loadProgressBarTexture": {
                    "type": "method",
                    "define": "loadProgressBarTexture(${1:#string fileName},${2:#int resType})",
                    "detail": "Load dark state texture for slider progress bar.\nparam fileName   File path of texture.\nparam resType    @see TextureResType .\n"
                },
                "loadSlidBallTexturePressed": {
                    "type": "method",
                    "define": "loadSlidBallTexturePressed(${1:#string pressed},${2:#int resType})",
                    "detail": "Load pressed state texture for slider ball.\nparam pressed    Pressed state texture.\nparam resType    @see TextureResType .\n"
                },
                "getProgressBarFile": {
                    "type": "method",
                    "define": "getProgressBarFile()"
                },
                "loadSlidBallTextureNormal": {
                    "type": "method",
                    "define": "loadSlidBallTextureNormal(${1:#string normal},${2:#int resType})",
                    "detail": "Load normal state texture for slider ball.\nparam normal    Normal state texture.\nparam resType    @see TextureResType .\n"
                },
                "getCapInsetsBarRenderer": {
                    "type": "method",
                    "define": "getCapInsetsBarRenderer()",
                    "detail": "Gets capinsets for bar slider, if slider is using scale9 renderer.\nreturn capInsets Capinsets for bar slider.\n"
                },
                "loadSlidBallTextureDisabled": {
                    "type": "method",
                    "define": "loadSlidBallTextureDisabled(${1:#string disabled},${2:#int resType})",
                    "detail": "Load disabled state texture for slider ball.\nparam disabled   Disabled state texture.\nparam resType    @see TextureResType .\n"
                },
                "getBallDisabledFile": {
                    "type": "method",
                    "define": "getBallDisabledFile()"
                },
                "getBallPressedFile": {
                    "type": "method",
                    "define": "getBallPressedFile()"
                },
                "getBallNormalFile": {
                    "type": "method",
                    "define": "getBallNormalFile()"
                }
            },
            "ScrollviewEventType": [
                "autoscrollEnded",
                "bounceBottom",
                "bounceLeft",
                "bounceRight",
                "bounceTop",
                "containerMoved",
                "scrollToBottom",
                "scrollToLeft",
                "scrollToRight",
                "scrollToTop",
                "scrolling"
            ],
            "Widget": {
                "1": "addClickEventListener",
                "2": "addTouchEventListener",
                "3": "new",
                "setLayoutParameter": {
                    "type": "method",
                    "define": "setLayoutParameter(${1:#ccui.LayoutParameter parameter})",
                    "detail": "Sets a LayoutParameter to widget.\nsee LayoutParameter\nparam parameter LayoutParameter pointer\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool enabled})",
                    "detail": "Sets whether the widget is enabled\ntrue if the widget is enabled, widget may be touched , false if the widget is disabled, widget cannot be touched.\nNote: If you want to change the widget's appearance  to disabled state, you should also call  `setBright(false)`.\nThe default value is true, a widget is default to enable touch.\nparam enabled Set to true to enable touch, false otherwise.\n"
                },
                "getSizePercent": {
                    "type": "method",
                    "define": "getSizePercent()",
                    "detail": "Get size percent of widget.\nreturn Percent size.\n"
                },
                "getPositionPercent": {
                    "type": "method",
                    "define": "getPositionPercent()",
                    "detail": "Gets the percent (x,y) of the widget in OpenGL coordinates\nsee setPosition(const Vec2&)\nreturn The percent (x,y) of the widget in OpenGL coordinates\n"
                },
                "setSwallowTouches": {
                    "type": "method",
                    "define": "setSwallowTouches(${1:#bool swallow})",
                    "detail": "Toggle widget swallow touch option.\nbrief Specify widget to swallow touches or not\nparam swallow True to swallow touch, false otherwise.\nsince v3.3\n"
                },
                "getVirtualRendererSize": {
                    "type": "method",
                    "define": "getVirtualRendererSize()",
                    "detail": "Get the virtual renderer's size\nreturn Widget virtual renderer size.\n"
                },
                "ignoreContentAdaptWithSize": {
                    "type": "method",
                    "define": "ignoreContentAdaptWithSize(${1:#bool ignore})",
                    "detail": "Toggle whether ignore user defined content size for widget.\nSet true will ignore user defined content size which means \nthe widget size is always equal to the return value of `getVirtualRendererSize`.\nparam ignore set member variable _ignoreSize to ignore\n"
                },
                "isFocusEnabled": {
                    "type": "method",
                    "define": "isFocusEnabled()",
                    "detail": "Query widget's focus enable state.\nreturn true represent the widget could accept focus, false represent the widget couldn't accept focus\n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()",
                    "detail": "Determines if the widget is enabled or not.\nreturn true if the widget is enabled, false if the widget is disabled.\n"
                },
                "getCallbackType": {
                    "type": "method",
                    "define": "getCallbackType()",
                    "detail": "Query callback type.\nreturn Callback type string.\n"
                },
                "setCallbackName": {
                    "type": "method",
                    "define": "setCallbackName(${1:#string callbackName})",
                    "detail": "Set callback name.\nparam callbackName A string representation of callback name.\n"
                },
                "setSizePercent": {
                    "type": "method",
                    "define": "setSizePercent(${1:#vec2_table percent})",
                    "detail": "Changes the percent that is widget's percent size\nparam percent that is widget's percent size\n"
                },
                "getLeftBoundary": {
                    "type": "method",
                    "define": "getLeftBoundary()",
                    "detail": "Gets the left boundary position of this widget in parent's coordination system.\nreturn The left boundary position of this widget.\n"
                },
                "setPropagateTouchEvents": {
                    "type": "method",
                    "define": "setPropagateTouchEvents(${1:#bool isPropagate})",
                    "detail": "brief Allow widget touch events to propagate to its parents. Set false will disable propagation\nparam isPropagate  True to allow propagation, false otherwise.\nsince v3.3\n"
                },
                "setFlippedX": {
                    "type": "method",
                    "define": "setFlippedX(${1:#bool flippedX})",
                    "detail": "Sets whether the widget should be flipped horizontally or not.\nparam flippedX true if the widget should be flipped horizontally, false otherwise.\n"
                },
                "isBright": {
                    "type": "method",
                    "define": "isBright()",
                    "detail": "Determines if the widget is bright\nreturn true if the widget is bright, false if the widget is dark.\n"
                },
                "setPositionPercent": {
                    "type": "method",
                    "define": "setPositionPercent(${1:#vec2_table percent})",
                    "detail": "Set the percent(x,y) of the widget in OpenGL coordinates\nparam percent  The percent (x,y) of the widget in OpenGL coordinates\n"
                },
                "setCallbackType": {
                    "type": "method",
                    "define": "setCallbackType(${1:#string callbackType})",
                    "detail": "Set callback type.\nparam callbackType A string representation of callback type.\n"
                },
                "setBright": {
                    "type": "method",
                    "define": "setBright(${1:#bool bright})",
                    "detail": "Sets whether the widget is bright\nThe default value is true, a widget is default to bright\nparam bright   true if the widget is bright, false if the widget is dark.\n"
                },
                "getTopBoundary": {
                    "type": "method",
                    "define": "getTopBoundary()",
                    "detail": "Gets the top boundary position of this widget in parent's coordination system.\nreturn The top boundary position of this widget.\n"
                },
                "setFlippedY": {
                    "type": "method",
                    "define": "setFlippedY(${1:#bool flippedY})",
                    "detail": "Sets whether the widget should be flipped vertically or not.\nparam flippedY true if the widget should be flipped vertically, false otherwise.\n"
                },
                "setTouchEnabled": {
                    "type": "method",
                    "define": "setTouchEnabled(${1:#bool enabled})",
                    "detail": "Sets whether the widget is touch enabled.\nThe default value is false, a widget is default to touch disabled.\nparam enabled   True if the widget is touch enabled, false if the widget is touch disabled.\n"
                },
                "isFlippedX": {
                    "type": "method",
                    "define": "isFlippedX()",
                    "detail": "Returns the flag which indicates whether the widget is flipped horizontally or not.\nIt not only flips the texture of the widget, but also the texture of the widget's children.\nAlso, flipping relies on widget's anchor point.\nInternally, it just use setScaleX(-1) to flip the widget.\nreturn true if the widget is flipped horizontally, false otherwise.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "Create a new widget copy of the original one.\nreturn A cloned widget copy of original.\n"
                },
                "onFocusChange": {
                    "type": "method",
                    "define": "onFocusChange(${1:#ccui.Widget widgetLostFocus},${2:#ccui.Widget widgetGetFocus})",
                    "detail": "This method is called when a focus change event happens\nparam widgetLostFocus  The widget which lose its focus\nparam widgetGetFocus  The widget which get its focus\n"
                },
                "updateSizeAndPosition": {
                    "type": "method",
                    "define": "updateSizeAndPosition(${1:#size_table parentSize})",
                    "detail": "@overload self, size_table         \n@overload self         \n"
                },
                "setFocused": {
                    "type": "method",
                    "define": "setFocused(${1:#bool focus})",
                    "detail": "Toggle widget focus status.\nparam focus  pass true to let the widget get focus or pass false to let the widget lose focus\n"
                },
                "setSizeType": {
                    "type": "method",
                    "define": "setSizeType(${1:#int type})",
                    "detail": "Changes the size type of widget.\nsee `SizeType`\nparam type that is widget's size type\n"
                },
                "hitTest": {
                    "type": "method",
                    "define": "hitTest(${1:#vec2_table pt},${2:#cc.Camera camera},${3:#vec3_table p})",
                    "detail": "Checks a point is in widget's content space.\nThis function is used for determining touch area of widget.\nparam pt        The point in `Vec2`.\nparam camera    The camera look at widget, used to convert GL screen point to near/far plane.\nparam p         Point to a Vec3 for store the intersect point, if don't need them set to nullptr.\nreturn true if the point is in widget's content space, false otherwise.\n"
                },
                "getCustomSize": {
                    "type": "method",
                    "define": "getCustomSize()",
                    "detail": "Get the user defined widget size.\nreturn User defined size.\n"
                },
                "isPropagateTouchEvents": {
                    "type": "method",
                    "define": "isPropagateTouchEvents()",
                    "detail": "Return whether the widget is propagate touch events to its parents or not\nreturn whether touch event propagation is allowed or not.\nsince v3.3\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create and return a empty Widget instance pointer.\n"
                },
                "dispatchFocusEvent": {
                    "type": "method",
                    "define": "dispatchFocusEvent(${1:#ccui.Widget widgetLoseFocus},${2:#ccui.Widget widgetGetFocus})",
                    "detail": "Dispatch a EventFocus through a EventDispatcher\nparam widgetLoseFocus  The widget which lose its focus\nparam widgetGetFocus he widget which get its focus\n"
                },
                "isFocused": {
                    "type": "method",
                    "define": "isFocused()",
                    "detail": "Query whether widget is focused or not.\nreturn  whether the widget is focused or not\n"
                },
                "getTouchBeganPosition": {
                    "type": "method",
                    "define": "getTouchBeganPosition()",
                    "detail": "Gets the touch began point of widget when widget is selected.\nreturn the touch began point.\n"
                },
                "getTouchEndPosition": {
                    "type": "method",
                    "define": "getTouchEndPosition()"
                },
                "interceptTouchEvent": {
                    "type": "method",
                    "define": "interceptTouchEvent(${1:#int event},${2:#ccui.Widget sender},${3:#cc.Touch touch})"
                },
                "setBrightStyle": {
                    "type": "method",
                    "define": "setBrightStyle(${1:#int style})",
                    "detail": "To set the bright style of widget.\nsee BrightStyle\nparam style   BrightStyle::NORMAL means the widget is in normal state, BrightStyle::HIGHLIGHT means the widget is in highlight state.\n"
                },
                "getVirtualRenderer": {
                    "type": "method",
                    "define": "getVirtualRenderer()",
                    "detail": "Gets the inner Renderer node of widget.\nFor example, a button's Virtual Renderer is it's texture renderer.\nreturn Node pointer.\n"
                },
                "isLayoutComponentEnabled": {
                    "type": "method",
                    "define": "isLayoutComponentEnabled()",
                    "detail": "Query whether layout component is enabled or not. \nreturn true represent the widget use Layout Component, false represent the widget couldn't use Layout Component.\n"
                },
                "getRightBoundary": {
                    "type": "method",
                    "define": "getRightBoundary()",
                    "detail": "Gets the right boundary position of this widget in parent's coordination system.\nreturn The right boundary position of this widget.\n"
                },
                "getCallbackName": {
                    "type": "method",
                    "define": "getCallbackName()",
                    "detail": "Query callback name.\nreturn The callback name.\n"
                },
                "isSwallowTouches": {
                    "type": "method",
                    "define": "isSwallowTouches()",
                    "detail": "Return whether the widget is swallowing touch or not\nreturn Whether touch is swallowed.\nsince v3.3\n"
                },
                "isUnifySizeEnabled": {
                    "type": "method",
                    "define": "isUnifySizeEnabled()",
                    "detail": "Query whether unify size enable state. \nreturn true represent the widget use Unify Size, false represent the widget couldn't use Unify Size\n"
                },
                "getPositionType": {
                    "type": "method",
                    "define": "getPositionType()",
                    "detail": "Gets the position type of the widget\nsee `PositionType`\nreturn type  the position type of widget\n"
                },
                "isFlippedY": {
                    "type": "method",
                    "define": "isFlippedY()",
                    "detail": "Return the flag which indicates whether the widget is flipped vertically or not.\nIt not only flips the texture of the widget, but also the texture of the widget's children.\nAlso, flipping relies on widget's anchor point.\nInternally, it just use setScaleY(-1) to flip the widget.\nreturn true if the widget is flipped vertically, false otherwise.\n"
                },
                "setUnifySizeEnabled": {
                    "type": "method",
                    "define": "setUnifySizeEnabled(${1:#bool enable})",
                    "detail": "Toggle use unify size.\nparam enable True to use unify size, false otherwise.\n"
                },
                "isClippingParentContainsPoint": {
                    "type": "method",
                    "define": "isClippingParentContainsPoint(${1:#vec2_table pt})",
                    "detail": "Checks a point if in parent's area.\nparam pt A point in `Vec2`.\nreturn true if the point is in parent's area, false otherwise.\n"
                },
                "propagateTouchEvent": {
                    "type": "method",
                    "define": "propagateTouchEvent(${1:#int event},${2:#ccui.Widget sender},${3:#cc.Touch touch})",
                    "detail": "brief Propagate touch events to its parents\n"
                },
                "enableDpadNavigation": {
                    "type": "method",
                    "define": "enableDpadNavigation(${1:#bool enable})"
                },
                "findNextFocusedWidget": {
                    "type": "method",
                    "define": "findNextFocusedWidget(${1:#int direction},${2:#ccui.Widget current})",
                    "detail": "When a widget is in a layout, you could call this method to get the next focused widget within a specified direction. \nIf the widget is not in a layout, it will return itself\nparam direction the direction to look for the next focused widget in a layout\nparam current  the current focused widget\nreturn the next focused widget in a layout\n"
                },
                "isIgnoreContentAdaptWithSize": {
                    "type": "method",
                    "define": "isIgnoreContentAdaptWithSize()",
                    "detail": "Query whether the widget ignores user defined content size or not\nreturn True means ignore user defined content size, false otherwise.\n"
                },
                "requestFocus": {
                    "type": "method",
                    "define": "requestFocus()",
                    "detail": "when a widget calls this method, it will get focus immediately.\n"
                },
                "getCurrentFocusedWidget": {
                    "type": "method",
                    "define": "getCurrentFocusedWidget()",
                    "detail": "Return a current focused widget in your UI scene.\nNo matter what widget object you call this method on , it will return you the exact one focused widget.\n"
                },
                "setActionTag": {
                    "type": "method",
                    "define": "setActionTag(${1:#int tag})",
                    "detail": "Set the tag of action.\nparam tag  A integer tag value.\n"
                },
                "getTouchMovePosition": {
                    "type": "method",
                    "define": "getTouchMovePosition()"
                },
                "getWorldPosition": {
                    "type": "method",
                    "define": "getWorldPosition()",
                    "detail": "Gets position of widget in world space.\nreturn Position of widget in world space.\n"
                },
                "isTouchEnabled": {
                    "type": "method",
                    "define": "isTouchEnabled()",
                    "detail": "Determines if the widget is touch enabled\nreturn true if the widget is touch enabled, false if the widget is touch disabled.\n"
                },
                "setFocusEnabled": {
                    "type": "method",
                    "define": "setFocusEnabled(${1:#bool enable})",
                    "detail": "Allow widget to accept focus.\nparam enable pass true/false to enable/disable the focus ability of a widget\n"
                },
                "getLayoutParameter": {
                    "type": "method",
                    "define": "getLayoutParameter()",
                    "detail": "Gets LayoutParameter of widget.\nsee LayoutParameter\nreturn LayoutParameter\n"
                },
                "getBottomBoundary": {
                    "type": "method",
                    "define": "getBottomBoundary()",
                    "detail": "Gets the bottom boundary position of this widget in parent's coordination system.\nreturn The bottom boundary position of this widget.\n"
                },
                "setPositionType": {
                    "type": "method",
                    "define": "setPositionType(${1:#int type})",
                    "detail": "Changes the position type of the widget\nsee `PositionType`\nparam type  the position type of widget\n"
                },
                "getSizeType": {
                    "type": "method",
                    "define": "getSizeType()",
                    "detail": "Gets the size type of widget.\nsee `SizeType`\n"
                },
                "getLayoutSize": {
                    "type": "method",
                    "define": "getLayoutSize()",
                    "detail": "Get the content size of widget.\nwarning This API exists mainly for keeping back compatibility.\nreturn \n"
                },
                "setLayoutComponentEnabled": {
                    "type": "method",
                    "define": "setLayoutComponentEnabled(${1:#bool enable})",
                    "detail": "Toggle layout component enable.\nparam enable Layout Component of a widget\n"
                },
                "setHighlighted": {
                    "type": "method",
                    "define": "setHighlighted(${1:#bool highlight})",
                    "detail": "Sets whether the widget is highlighted\nThe default value is false, a widget is default to not highlighted\nparam highlight   true if the widget is highlighted, false if the widget is not highlighted.\n"
                },
                "getActionTag": {
                    "type": "method",
                    "define": "getActionTag()",
                    "detail": "Get the action tag.\nreturn Action tag.\n"
                },
                "isHighlighted": {
                    "type": "method",
                    "define": "isHighlighted()",
                    "detail": "Determines if the widget is highlighted\nreturn true if the widget is highlighted, false if the widget is not highlighted.\n"
                }
            },
            "PVTouchDir": [
                "touchDown",
                "touchLeft",
                "touchRight",
                "touchUp"
            ],
            "PageView": {
                "1": "new",
                "addPage": {
                    "type": "method",
                    "define": "addPage(${1:#ccui.Widget page})",
                    "detail": "Insert a page into the end of PageView.\nparam page Page to be inserted.\n"
                },
                "removeAllPages": {
                    "type": "method",
                    "define": "removeAllPages()",
                    "detail": "brief Remove all pages of the PageView.\n"
                },
                "getIndicatorSpaceBetweenIndexNodes": {
                    "type": "method",
                    "define": "getIndicatorSpaceBetweenIndexNodes()",
                    "detail": "brief Get the space between page indicator's index nodes.\nreturn spaceBetweenIndexNodes\n"
                },
                "scrollToItem": {
                    "type": "method",
                    "define": "scrollToItem(${1:#int idx},${2:#float time})",
                    "detail": "@overload self, int, float         \n@overload self, int         \n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create an empty PageView.\nreturn A PageView instance.\n"
                },
                "getCurrentPageIndex": {
                    "type": "method",
                    "define": "getCurrentPageIndex()",
                    "detail": "Gets current displayed page index.\nreturn current page index.\n"
                },
                "setIndicatorIndexNodesScale": {
                    "type": "method",
                    "define": "setIndicatorIndexNodesScale(${1:#float indexNodesScale})",
                    "detail": "brief Set scale of page indicator's index nodes.\nparam indexNodesScale Scale of index nodes.\n"
                },
                "removePageAtIndex": {
                    "type": "method",
                    "define": "removePageAtIndex(${1:#int index})",
                    "detail": "Remove a page at a given index of PageView.\nparam index  A given index.\n"
                },
                "getIndicatorIndexNodesColor": {
                    "type": "method",
                    "define": "getIndicatorIndexNodesColor()",
                    "detail": "brief Get the color of page indicator's index nodes.\nreturn color\n"
                },
                "insertPage": {
                    "type": "method",
                    "define": "insertPage(${1:#ccui.Widget page},${2:#int idx})",
                    "detail": "Insert a page into PageView at a given index.\nparam page  Page to be inserted.\nparam idx   A given index.\n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "brief Add a page turn callback to PageView, then when one page is turning, the callback will be called.\nparam callback A page turning callback.\n"
                },
                "setIndicatorIndexNodesTexture": {
                    "type": "method",
                    "define": "setIndicatorIndexNodesTexture(${1:#string texName},${2:#int texType})",
                    "detail": "sets texture for index nodes.\nparam fileName   File name of texture.\nparam resType    @see TextureResType .\n"
                },
                "setIndicatorSelectedIndexColor": {
                    "type": "method",
                    "define": "setIndicatorSelectedIndexColor(${1:#color3b_table color})",
                    "detail": "brief Set color of page indicator's selected index.\nparam color Space between nodes in pixel.\n"
                },
                "setAutoScrollStopEpsilon": {
                    "type": "method",
                    "define": "setAutoScrollStopEpsilon(${1:#float epsilon})"
                },
                "setIndicatorPosition": {
                    "type": "method",
                    "define": "setIndicatorPosition(${1:#vec2_table position})",
                    "detail": "brief Set the page indicator's position in page view.\nparam position The position in page view\n"
                },
                "setCurrentPageIndex": {
                    "type": "method",
                    "define": "setCurrentPageIndex(${1:#int index})",
                    "detail": "Jump to a page with a given index without scrolling.\nThis is the different between scrollToPage.\nparam index A given index in PageView. Index start from 0 to pageCount -1.\n"
                },
                "getIndicatorIndexNodesScale": {
                    "type": "method",
                    "define": "getIndicatorIndexNodesScale()",
                    "detail": "brief Get scale of page indicator's index nodes.\nreturn indexNodesScale\n"
                },
                "setIndicatorSpaceBetweenIndexNodes": {
                    "type": "method",
                    "define": "setIndicatorSpaceBetweenIndexNodes(${1:#float spaceBetweenIndexNodes})",
                    "detail": "brief Set space between page indicator's index nodes.\nparam spaceBetweenIndexNodes Space between nodes in pixel.\n"
                },
                "getIndicatorPositionAsAnchorPoint": {
                    "type": "method",
                    "define": "getIndicatorPositionAsAnchorPoint()",
                    "detail": "brief Get the page indicator's position as anchor point.\nreturn positionAsAnchorPoint\n"
                },
                "getIndicatorEnabled": {
                    "type": "method",
                    "define": "getIndicatorEnabled()",
                    "detail": "brief Query page indicator state.\nreturn True if page indicator is enabled, false otherwise.\n"
                },
                "setIndicatorIndexNodesColor": {
                    "type": "method",
                    "define": "setIndicatorIndexNodesColor(${1:#color3b_table color})",
                    "detail": "brief Set color of page indicator's index nodes.\nparam color Space between nodes in pixel.\n"
                },
                "removePage": {
                    "type": "method",
                    "define": "removePage(${1:#ccui.Widget page})",
                    "detail": "Remove a page of PageView.\nparam page  Page to be removed.\n"
                },
                "setIndicatorPositionAsAnchorPoint": {
                    "type": "method",
                    "define": "setIndicatorPositionAsAnchorPoint(${1:#vec2_table positionAsAnchorPoint})",
                    "detail": "brief Set the page indicator's position using anchor point.\nparam positionAsAnchorPoint The position as anchor point.\n"
                },
                "setIndicatorEnabled": {
                    "type": "method",
                    "define": "setIndicatorEnabled(${1:#bool enabled})",
                    "detail": "brief Toggle page indicator enabled.\nparam enabled True if enable page indicator, false otherwise.\n"
                },
                "scrollToPage": {
                    "type": "method",
                    "define": "scrollToPage(${1:#int idx},${2:#float time})",
                    "detail": "@overload self, int, float         \n@overload self, int         \n"
                },
                "getIndicatorSelectedIndexColor": {
                    "type": "method",
                    "define": "getIndicatorSelectedIndexColor()",
                    "detail": "brief Get the color of page indicator's selected index.\nreturn color\n"
                },
                "getIndicatorPosition": {
                    "type": "method",
                    "define": "getIndicatorPosition()",
                    "detail": "brief Get the page indicator's position.\nreturn positionAsAnchorPoint\n"
                }
            },
            "RichText": {
                "1": "new",
                "getWrapMode": {
                    "type": "method",
                    "define": "getWrapMode()"
                },
                "getAnchorTextShadowColor3B": {
                    "type": "method",
                    "define": "getAnchorTextShadowColor3B()"
                },
                "setFontColor": {
                    "type": "method",
                    "define": "setFontColor(${1:#string color})"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "brief Create a empty RichText.\nreturn RichText instance.\n"
                },
                "setAnchorTextItalic": {
                    "type": "method",
                    "define": "setAnchorTextItalic(${1:#bool enable})"
                },
                "setAnchorFontColor": {
                    "type": "method",
                    "define": "setAnchorFontColor(${1:#string color})"
                },
                "isAnchorTextShadowEnabled": {
                    "type": "method",
                    "define": "isAnchorTextShadowEnabled()"
                },
                "getAnchorFontColor3B": {
                    "type": "method",
                    "define": "getAnchorFontColor3B()"
                },
                "getFontFace": {
                    "type": "method",
                    "define": "getFontFace()"
                },
                "setAnchorTextShadow": {
                    "type": "method",
                    "define": "setAnchorTextShadow(${1:#bool enable},${2:#color3b_table shadowColor},${3:#size_table offset},${4:#int blurRadius})",
                    "detail": " @brief enable the shadow of a-tag \n"
                },
                "getAnchorTextShadowBlurRadius": {
                    "type": "method",
                    "define": "getAnchorTextShadowBlurRadius()"
                },
                "isAnchorTextUnderlineEnabled": {
                    "type": "method",
                    "define": "isAnchorTextUnderlineEnabled()"
                },
                "color3BWithString": {
                    "type": "method",
                    "define": "color3BWithString(${1:#string color})"
                },
                "getDefaults": {
                    "type": "method",
                    "define": "getDefaults()"
                },
                "getFontColor3B": {
                    "type": "method",
                    "define": "getFontColor3B()"
                },
                "getAnchorTextShadowOffset": {
                    "type": "method",
                    "define": "getAnchorTextShadowOffset()"
                },
                "setAnchorTextDel": {
                    "type": "method",
                    "define": "setAnchorTextDel(${1:#bool enable})"
                },
                "getAnchorTextOutlineColor3B": {
                    "type": "method",
                    "define": "getAnchorTextOutlineColor3B()"
                },
                "openUrl": {
                    "type": "method",
                    "define": "openUrl(${1:#string url})"
                },
                "getAnchorTextOutlineSize": {
                    "type": "method",
                    "define": "getAnchorTextOutlineSize()"
                },
                "removeElement": {
                    "type": "method",
                    "define": "removeElement(${1:#int index})",
                    "detail": "@overload self, ccui.RichElement         \n@overload self, int         \n"
                },
                "isAnchorTextGlowEnabled": {
                    "type": "method",
                    "define": "isAnchorTextGlowEnabled()"
                },
                "setWrapMode": {
                    "type": "method",
                    "define": "setWrapMode(${1:#int wrapMode})"
                },
                "setVerticalSpace": {
                    "type": "method",
                    "define": "setVerticalSpace(${1:#float space})",
                    "detail": "brief Set vertical space between each RichElement.\nparam space Point in float.\n"
                },
                "setFontSize": {
                    "type": "method",
                    "define": "setFontSize(${1:#float size})"
                },
                "isAnchorTextItalicEnabled": {
                    "type": "method",
                    "define": "isAnchorTextItalicEnabled()"
                },
                "setDefaults": {
                    "type": "method",
                    "define": "setDefaults(${1:#map_table defaults})"
                },
                "setAnchorTextOutline": {
                    "type": "method",
                    "define": "setAnchorTextOutline(${1:#bool enable},${2:#color3b_table outlineColor},${3:#int outlineSize})",
                    "detail": " @brief enable the outline of a-tag \n"
                },
                "getFontSize": {
                    "type": "method",
                    "define": "getFontSize()"
                },
                "setAnchorTextBold": {
                    "type": "method",
                    "define": "setAnchorTextBold(${1:#bool enable})"
                },
                "stringWithColor4B": {
                    "type": "method",
                    "define": "stringWithColor4B(${1:#color4b_table color4b})"
                },
                "getAnchorFontColor": {
                    "type": "method",
                    "define": "getAnchorFontColor()"
                },
                "stringWithColor3B": {
                    "type": "method",
                    "define": "stringWithColor3B(${1:#color3b_table color3b})"
                },
                "insertElement": {
                    "type": "method",
                    "define": "insertElement(${1:#ccui.RichElement element},${2:#int index})",
                    "detail": "brief Insert a RichElement at a given index.\nparam element A RichElement type.\nparam index A given index.\n"
                },
                "setAnchorTextUnderline": {
                    "type": "method",
                    "define": "setAnchorTextUnderline(${1:#bool enable})"
                },
                "pushBackElement": {
                    "type": "method",
                    "define": "pushBackElement(${1:#ccui.RichElement element})",
                    "detail": "brief Add a RichElement at the end of RichText.\nparam element A RichElement instance.\n"
                },
                "getAnchorTextGlowColor3B": {
                    "type": "method",
                    "define": "getAnchorTextGlowColor3B()"
                },
                "isAnchorTextOutlineEnabled": {
                    "type": "method",
                    "define": "isAnchorTextOutlineEnabled()"
                },
                "formatText": {
                    "type": "method",
                    "define": "formatText()",
                    "detail": "brief Rearrange all RichElement in the RichText.\nIt's usually called internally.\n"
                },
                "getFontColor": {
                    "type": "method",
                    "define": "getFontColor()"
                },
                "isAnchorTextBoldEnabled": {
                    "type": "method",
                    "define": "isAnchorTextBoldEnabled()"
                },
                "setFontFace": {
                    "type": "method",
                    "define": "setFontFace(${1:#string face})"
                },
                "createWithXML": {
                    "type": "method",
                    "define": "createWithXML(${1:#string xml},${2:#map_table defaults},${3:#function handleOpenUrl})",
                    "detail": "brief Create a RichText from an XML\nreturn RichText instance.\n"
                },
                "initWithXML": {
                    "type": "method",
                    "define": "initWithXML(${1:#string xml},${2:#map_table defaults},${3:#function handleOpenUrl})"
                },
                "isAnchorTextDelEnabled": {
                    "type": "method",
                    "define": "isAnchorTextDelEnabled()"
                },
                "setAnchorTextGlow": {
                    "type": "method",
                    "define": "setAnchorTextGlow(${1:#bool enable},${2:#color3b_table glowColor})"
                }
            },
            "PageViewEventType": [
                "turning"
            ],
            "RichElementImage": {
                "1": "new",
                "setUrl": {
                    "type": "method",
                    "define": "setUrl(${1:#string url})"
                },
                "setHeight": {
                    "type": "method",
                    "define": "setHeight(${1:#int height})"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity},${4:#string filePath},${5:#string url})",
                    "detail": "brief Initialize a RichElementImage with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nparam filePath A image file name.\nparam url uniform resource locator\nreturn True if initialize success, false otherwise.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity},${4:#string filePath},${5:#string url})",
                    "detail": "brief Create a RichElementImage with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nparam filePath A image file name.\nparam url uniform resource locator\nreturn A RichElementImage instance.\n"
                },
                "setWidth": {
                    "type": "method",
                    "define": "setWidth(${1:#int width})"
                }
            },
            "RichElementText": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity},${4:#string text},${5:#string fontName},${6:#float fontSize},${7:#unsigned int flags},${8:#string url},${9:#color3b_table outlineColor},${10:#int outlineSize},${11:#color3b_table shadowColor},${12:#size_table shadowOffset},${13:#int shadowBlurRadius},${14:#color3b_table glowColor})",
                    "detail": "brief Create a RichElementText with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nparam text Content string.\nparam fontName Content font name.\nparam fontSize Content font size.\nparam flags italics, bold, underline, strikethrough, url, outline, shadow or glow\nparam url uniform resource locator\nparam outlineColor the color of the outline\nparam outlineSize the outline effect size value\nparam shadowColor the shadow effect color value\nparam shadowOffset shadow effect offset value\nparam shadowBlurRadius the shadow effect blur radius\nparam glowColor glow color\nreturn RichElementText instance.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity},${4:#string text},${5:#string fontName},${6:#float fontSize},${7:#unsigned int flags},${8:#string url},${9:#color3b_table outlineColor},${10:#int outlineSize},${11:#color3b_table shadowColor},${12:#size_table shadowOffset},${13:#int shadowBlurRadius},${14:#color3b_table glowColor})",
                    "detail": "brief Initialize a RichElementText with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nparam text Content string.\nparam fontName Content font name.\nparam fontSize Content font size.\nparam flags italics, bold, underline, strikethrough, url, outline, shadow or glow\nparam url uniform resource locator\nparam outlineColor the color of the outline\nparam outlineSize the outline effect size value\nparam shadowColor the shadow effect color value\nparam shadowOffset shadow effect offset value\nparam shadowBlurRadius the shadow effect blur radius\nparam glowColor glow color\nreturn True if initialize success, false otherwise.\n"
                }
            },
            "ListViewMoveDirection": [
                "down",
                "left",
                "none",
                "right",
                "up"
            ],
            "RichElementNewLine": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity})",
                    "detail": "brief Create a RichElementNewLine with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nreturn A RichElementNewLine instance.\n"
                },
                "1": "new"
            },
            "RichElementCustomNode": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity},${4:#cc.Node customNode})",
                    "detail": "brief Create a RichElementCustomNode with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nparam customNode A custom node pointer.\nreturn A RichElementCustomNode instance.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#int tag},${2:#color3b_table color},${3:#unsigned char opacity},${4:#cc.Node customNode})",
                    "detail": "brief Initialize a RichElementCustomNode with various arguments.\nparam tag A integer tag value.\nparam color A color in Color3B.\nparam opacity A opacity in GLubyte.\nparam customNode A custom node pointer.\nreturn True if initialize success, false otherwise.\n"
                }
            },
            "LinearLayoutParameter": {
                "1": "new",
                "setGravity": {
                    "type": "method",
                    "define": "setGravity(${1:#int gravity})",
                    "detail": "Sets LinearGravity parameter for LayoutParameter.\nsee LinearGravity\nparam gravity Gravity in LinearGravity.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create a empty LinearLayoutParameter instance.\nreturn A initialized LayoutParameter which is marked as \"autorelease\".\n"
                },
                "getGravity": {
                    "type": "method",
                    "define": "getGravity()",
                    "detail": "Gets LinearGravity parameter for LayoutParameter.\nsee LinearGravity\nreturn LinearGravity\n"
                }
            },
            "RadioButtonGroup": {
                "1": "new",
                "removeAllRadioButtons": {
                    "type": "method",
                    "define": "removeAllRadioButtons()",
                    "detail": "Remove all radio button from this group.\n"
                },
                "setAllowedNoSelection": {
                    "type": "method",
                    "define": "setAllowedNoSelection(${1:#bool allowedNoSelection})",
                    "detail": "Set a flag for allowing no-selection feature.\nIf it is allowed, no radio button can be selected.\nIf it is not allowed, one radio button must be selected all time except it is empty.\nDefault is not allowed.\nparam true means allowing no-selection, false means disallowing no-selection.\n"
                },
                "getRadioButtonByIndex": {
                    "type": "method",
                    "define": "getRadioButtonByIndex(${1:#int index})",
                    "detail": "Get a radio button in this group by index.\nparam index of the radio button\nreturn radio button instance. Returns nullptr if out of index.\n"
                },
                "setSelectedButtonWithoutEvent": {
                    "type": "method",
                    "define": "setSelectedButtonWithoutEvent(${1:#int index})",
                    "detail": "@overload self, ccui.RadioButton         \n@overload self, int         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create and return a empty RadioButtonGroup instance pointer.\n"
                },
                "removeRadioButton": {
                    "type": "method",
                    "define": "removeRadioButton(${1:#ccui.RadioButton radioButton})",
                    "detail": "Remove a radio button from this group.\nparam radio button instance\n"
                },
                "addRadioButton": {
                    "type": "method",
                    "define": "addRadioButton(${1:#ccui.RadioButton radioButton})",
                    "detail": "Add a radio button into this group.\nparam radio button instance\n"
                },
                "setSelectedButton": {
                    "type": "method",
                    "define": "setSelectedButton(${1:#int index})",
                    "detail": "@overload self, ccui.RadioButton         \n@overload self, int         \n"
                },
                "isAllowedNoSelection": {
                    "type": "method",
                    "define": "isAllowedNoSelection()",
                    "detail": "Query whether no-selection is allowed or not.\nparam true means no-selection is allowed, false means no-selection is not allowed.\n"
                },
                "getNumberOfRadioButtons": {
                    "type": "method",
                    "define": "getNumberOfRadioButtons()",
                    "detail": "Get the number of radio buttons in this group.\nreturn the number of radio buttons in this group\n"
                },
                "getSelectedButtonIndex": {
                    "type": "method",
                    "define": "getSelectedButtonIndex()",
                    "detail": "Get the index of selected radio button.\nreturn the selected button's index. Returns -1 if no button is selected.\n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add a callback function which would be called when radio button is selected or unselected.\nparam callback A std::function with type @see `ccRadioButtonGroupCallback`\n"
                }
            },
            "AbstractCheckButton": {
                "getCrossNormalFile": {
                    "type": "method",
                    "define": "getCrossNormalFile()"
                },
                "getRendererFrontCross": {
                    "type": "method",
                    "define": "getRendererFrontCross()",
                    "detail": "brief Return the sprite instance of front cross\nreturn the sprite instance of front cross\n"
                },
                "loadTextureBackGroundDisabled": {
                    "type": "method",
                    "define": "loadTextureBackGroundDisabled(${1:#string backGroundDisabled},${2:#int texType})",
                    "detail": "Load background disabled state texture for checkbox.\nparam backGroundDisabled    The background disabled state texture name.\nparam texType    @see `Widget::TextureResType`\n"
                },
                "getBackNormalFile": {
                    "type": "method",
                    "define": "getBackNormalFile()"
                },
                "getBackDisabledFile": {
                    "type": "method",
                    "define": "getBackDisabledFile()"
                },
                "setZoomScale": {
                    "type": "method",
                    "define": "setZoomScale(${1:#float scale})",
                    "detail": " When user pressed the CheckBox, the button will zoom to a scale.\nThe final scale of the CheckBox  equals (CheckBox original scale + _zoomScale)\nsince v3.3\n"
                },
                "getRendererBackgroundDisabled": {
                    "type": "method",
                    "define": "getRendererBackgroundDisabled()",
                    "detail": "brief Return the sprite instance of background when disabled\nreturn the sprite instance of background when disabled\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "isSelected": {
                    "type": "method",
                    "define": "isSelected()",
                    "detail": "Query whether CheckBox is selected or not.\nreturn true means \"selected\", false otherwise.\n"
                },
                "loadTextureBackGround": {
                    "type": "method",
                    "define": "loadTextureBackGround(${1:#string backGround},${2:#int type})",
                    "detail": "Load background texture for check button.\nparam backGround   The background image name.\nparam type    @see `Widget::TextureResType`\n"
                },
                "getBackPressedFile": {
                    "type": "method",
                    "define": "getBackPressedFile()"
                },
                "loadTextures": {
                    "type": "method",
                    "define": "loadTextures(${1:#string background},${2:#string backgroundSelected},${3:#string cross},${4:#string backgroundDisabled},${5:#string frontCrossDisabled},${6:#int texType})",
                    "detail": "Load all textures for initializing a check button.\nparam background    The background image name.\nparam backgroundSelected    The background selected image name.\nparam cross    The cross image name.\nparam backgroundDisabled    The background disabled state texture.\nparam frontCrossDisabled    The front cross disabled state image name.\nparam texType    @see `Widget::TextureResType`\n"
                },
                "loadTextureFrontCross": {
                    "type": "method",
                    "define": "loadTextureFrontCross(${1:#string crossTextureName},${2:#int texType})",
                    "detail": "Load cross texture for check button.\nparam crossTextureName    The cross texture name.\nparam texType    @see `Widget::TextureResType`\n"
                },
                "getZoomScale": {
                    "type": "method",
                    "define": "getZoomScale()",
                    "detail": "brief Return a zoom scale\nreturn A zoom scale of Checkbox.\nsince v3.3\n"
                },
                "getRendererBackground": {
                    "type": "method",
                    "define": "getRendererBackground()",
                    "detail": "brief Return the sprite instance of background\nreturn the sprite instance of background.\n"
                },
                "setSelected": {
                    "type": "method",
                    "define": "setSelected(${1:#bool selected})",
                    "detail": "Change CheckBox state.\nSet to true will cause the CheckBox's state to \"selected\", false otherwise.\nparam selected Set to true will change CheckBox to selected state, false otherwise.\n"
                },
                "loadTextureFrontCrossDisabled": {
                    "type": "method",
                    "define": "loadTextureFrontCrossDisabled(${1:#string frontCrossDisabled},${2:#int texType})",
                    "detail": "Load frontcross disabled texture for checkbox.\nparam frontCrossDisabled    The front cross disabled state texture name.\nparam texType    @see `Widget::TextureResType`\n"
                },
                "getCrossDisabledFile": {
                    "type": "method",
                    "define": "getCrossDisabledFile()"
                },
                "loadTextureBackGroundSelected": {
                    "type": "method",
                    "define": "loadTextureBackGroundSelected(${1:#string backGroundSelected},${2:#int texType})",
                    "detail": "Load background selected state texture for check button.\nparam backGroundSelected    The background selected state image name.\nparam texType    @see `Widget::TextureResType`\n"
                },
                "getRendererFrontCrossDisabled": {
                    "type": "method",
                    "define": "getRendererFrontCrossDisabled()",
                    "detail": "brief Return the sprite instance of front cross when disabled\nreturn the sprite instance of front cross when disabled\n"
                },
                "getRendererBackgroundSelected": {
                    "type": "method",
                    "define": "getRendererBackgroundSelected()",
                    "detail": "brief Return the sprite instance of background when selected\nreturn the sprite instance of background when selected\n"
                }
            },
            "RelativeBox": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table size})",
                    "detail": "@overload self, size_table         \n@overload self         \n"
                },
                "initWithSize": {
                    "type": "method",
                    "define": "initWithSize(${1:#size_table size})"
                }
            },
            "RelativeAlign": [
                "alignNone",
                "alignParentBottomCenterHorizontal",
                "alignParentLeftBottom",
                "alignParentLeftCenterVertical",
                "alignParentRightBottom",
                "alignParentRightCenterVertical",
                "alignParentTopCenterHorizontal",
                "alignParentTopLeft",
                "alignParentTopRight",
                "centerInParent",
                "locationAboveCenter",
                "locationAboveLeftAlign",
                "locationAboveRightAlign",
                "locationBelowCenter",
                "locationBelowLeftAlign",
                "locationBelowRightAlign",
                "locationLeftOfBottomAlign",
                "locationLeftOfCenter",
                "locationLeftOfTopAlign",
                "locationRightOfBottomAlign",
                "locationRightOfCenter",
                "locationRightOfTopAlign"
            ],
            "LayoutParameterType": [
                "linear",
                "none",
                "relative"
            ],
            "RadioButtonGroupEventType": [
                "select_changed"
            ],
            "ListViewGravity": [
                "bottom",
                "centerHorizontal",
                "centerVertical",
                "left",
                "right",
                "top"
            ],
            "Button": {
                "1": "new",
                "getTitleFontSize": {
                    "type": "method",
                    "define": "getTitleFontSize()",
                    "detail": "Query the font size of button title\nreturn font size in float.\n"
                },
                "setCapInsets": {
                    "type": "method",
                    "define": "setCapInsets(${1:#rect_table capInsets})",
                    "detail": "Sets capInsets for button.\nThe capInset affects  all button scale9 renderer only if `setScale9Enabled(true)` is called\nparam capInsets    capInset in Rect.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string normalImage},${2:#string selectedImage},${3:#string disableImage},${4:#int texType})",
                    "detail": "@overload self, string, string, string, int         \n@overload self         \n"
                },
                "setZoomScale": {
                    "type": "method",
                    "define": "setZoomScale(${1:#float scale})",
                    "detail": " @brief When user pressed the button, the button will zoom to a scale.\nThe final scale of the button  equals (button original scale + _zoomScale)\nsince v3.3\n"
                },
                "setTitleFontSize": {
                    "type": "method",
                    "define": "setTitleFontSize(${1:#float size})",
                    "detail": "Change the font size of button's title\nparam size Title font size in float.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "setScale9Enabled": {
                    "type": "method",
                    "define": "setScale9Enabled(${1:#bool enable})",
                    "detail": "Enable scale9 renderer.\nparam enable Set to true will use scale9 renderer, false otherwise.\n"
                },
                "setCapInsetsDisabledRenderer": {
                    "type": "method",
                    "define": "setCapInsetsDisabledRenderer(${1:#rect_table capInsets})",
                    "detail": "Sets capInsets for button, only the disabled state scale9 renderer will be affected.\nparam capInsets  capInsets in Rect.\n"
                },
                "loadTextures": {
                    "type": "method",
                    "define": "loadTextures(${1:#string normal},${2:#string selected},${3:#string disabled},${4:#int texType})",
                    "detail": "Load textures for button.\nparam normal    normal state texture name.\nparam selected    selected state texture name.\nparam disabled    disabled state texture name.\nparam texType    @see `TextureResType`\n"
                },
                "getRendererNormal": {
                    "type": "method",
                    "define": "getRendererNormal()",
                    "detail": "brief Return the nine-patch sprite of normal state\nreturn the nine-patch sprite of normal state\nsince v3.9\n"
                },
                "resetDisabledRender": {
                    "type": "method",
                    "define": "resetDisabledRender()"
                },
                "getNormalTextureSize": {
                    "type": "method",
                    "define": "getNormalTextureSize()"
                },
                "getDisabledFile": {
                    "type": "method",
                    "define": "getDisabledFile()"
                },
                "getCapInsetsDisabledRenderer": {
                    "type": "method",
                    "define": "getCapInsetsDisabledRenderer()",
                    "detail": "Return the capInsets of disabled state scale9sprite.\nreturn The disabled scale9 renderer capInsets.\n"
                },
                "getCapInsetsPressedRenderer": {
                    "type": "method",
                    "define": "getCapInsetsPressedRenderer()",
                    "detail": "Return the capInsets of pressed state scale9sprite.\nreturn The pressed scale9 renderer capInsets.\n"
                },
                "loadTexturePressed": {
                    "type": "method",
                    "define": "loadTexturePressed(${1:#string selected},${2:#int texType})",
                    "detail": "Load selected state texture for button.\nparam selected    selected state texture.\nparam texType    @see `TextureResType`\n"
                },
                "isScale9Enabled": {
                    "type": "method",
                    "define": "isScale9Enabled()",
                    "detail": "Query whether button is using scale9 renderer or not.\nreturn whether button use scale9 renderer or not.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "getTitleFontName": {
                    "type": "method",
                    "define": "getTitleFontName()",
                    "detail": "Query the font name of button's title\nreturn font name in std::string\n"
                },
                "getCapInsetsNormalRenderer": {
                    "type": "method",
                    "define": "getCapInsetsNormalRenderer()",
                    "detail": "Return the capInsets of normal state scale9sprite.\nreturn The normal scale9 renderer capInsets.\n"
                },
                "getTitleText": {
                    "type": "method",
                    "define": "getTitleText()",
                    "detail": "Query the button title content.\nreturn Get the button's title content.\n"
                },
                "getTitleRenderer": {
                    "type": "method",
                    "define": "getTitleRenderer()",
                    "detail": "Return the inner title renderer of Button.\nreturn The button title.\nsince v3.3\n"
                },
                "setCapInsetsPressedRenderer": {
                    "type": "method",
                    "define": "setCapInsetsPressedRenderer(${1:#rect_table capInsets})",
                    "detail": "Sets capInsets for button, only the pressed state scale9 renderer will be affected.\nparam capInsets    capInsets in Rect\n"
                },
                "getNormalFile": {
                    "type": "method",
                    "define": "getNormalFile()"
                },
                "setTitleText": {
                    "type": "method",
                    "define": "setTitleText(${1:#string text})",
                    "detail": "Change the content of button's title.\nparam text The title in std::string.\n"
                },
                "loadTextureDisabled": {
                    "type": "method",
                    "define": "loadTextureDisabled(${1:#string disabled},${2:#int texType})",
                    "detail": "Load disabled state texture for button.\nparam disabled    dark state texture.\nparam texType    @see `TextureResType`\n"
                },
                "setTitleFontName": {
                    "type": "method",
                    "define": "setTitleFontName(${1:#string fontName})",
                    "detail": "Change the font name of button's title\nparam fontName a font name string.\n"
                },
                "getRendererClicked": {
                    "type": "method",
                    "define": "getRendererClicked()",
                    "detail": "brief Return the nine-patch sprite of clicked state\nreturn the nine-patch sprite of clicked state\nsince v3.9\n"
                },
                "setCapInsetsNormalRenderer": {
                    "type": "method",
                    "define": "setCapInsetsNormalRenderer(${1:#rect_table capInsets})",
                    "detail": "Sets capInsets for button, only the normal state scale9 renderer will be affected.\nparam capInsets    capInsets in Rect.\n"
                },
                "setTitleColor": {
                    "type": "method",
                    "define": "setTitleColor(${1:#color3b_table color})",
                    "detail": "Change the color of button's title.\nparam color The title color in Color3B.\n"
                },
                "setTitleAlignment": {
                    "type": "method",
                    "define": "setTitleAlignment(${1:#int hAlignment},${2:#int vAlignment})",
                    "detail": "@overload self, int, int         \n@overload self, int         \n"
                },
                "getZoomScale": {
                    "type": "method",
                    "define": "getZoomScale()",
                    "detail": "brief Return a zoom scale\nreturn the zoom scale in float\nsince v3.3\n"
                },
                "setPressedActionEnabled": {
                    "type": "method",
                    "define": "setPressedActionEnabled(${1:#bool enabled})",
                    "detail": "Enable zooming action when button is pressed.\nparam enabled Set to true will enable zoom effect, false otherwise.\n"
                },
                "resetNormalRender": {
                    "type": "method",
                    "define": "resetNormalRender()"
                },
                "getTitleLabel": {
                    "type": "method",
                    "define": "getTitleLabel()",
                    "detail": " returns the current Label being used \n"
                },
                "getTitleColor": {
                    "type": "method",
                    "define": "getTitleColor()",
                    "detail": "Query the button title color.\nreturn Color3B of button title.\n"
                },
                "resetPressedRender": {
                    "type": "method",
                    "define": "resetPressedRender()"
                },
                "getPressedFile": {
                    "type": "method",
                    "define": "getPressedFile()"
                },
                "setTitleLabel": {
                    "type": "method",
                    "define": "setTitleLabel(${1:#cc.Label label})",
                    "detail": " replaces the current Label node with a new one \n"
                },
                "getRendererDisabled": {
                    "type": "method",
                    "define": "getRendererDisabled()",
                    "detail": "brief Return the nine-patch sprite of disabled state\nreturn the nine-patch sprite of disabled state\nsince v3.9\n"
                },
                "loadTextureNormal": {
                    "type": "method",
                    "define": "loadTextureNormal(${1:#string normal},${2:#int texType})",
                    "detail": "Load normal state texture for button.\nparam normal    normal state texture.\nparam texType    @see `TextureResType`\n"
                }
            },
            "ScrollView": {
                "1": "new",
                "isScrollBarAutoHideEnabled": {
                    "type": "method",
                    "define": "isScrollBarAutoHideEnabled()",
                    "detail": "brief Query scroll bar auto hide state\nreturn True if scroll bar auto hide is enabled, false otherwise.\n"
                },
                "scrollToRight": {
                    "type": "method",
                    "define": "scrollToRight(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to right boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "setScrollBarOpacity": {
                    "type": "method",
                    "define": "setScrollBarOpacity(${1:#unsigned char opacity})",
                    "detail": "brief Set the scroll bar's opacity\nparam the scroll bar's opacity\n"
                },
                "jumpToTopLeft": {
                    "type": "method",
                    "define": "jumpToTopLeft()",
                    "detail": "Move inner container to top and left boundary of scrollview.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create an empty ScrollView.\nreturn A ScrollView instance.\n"
                },
                "getTouchTotalTimeThreshold": {
                    "type": "method",
                    "define": "getTouchTotalTimeThreshold()",
                    "detail": "brief Get the touch total time threshold\nreturn the touch total time threshold\n"
                },
                "scrollToTopLeft": {
                    "type": "method",
                    "define": "scrollToTopLeft(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to top and left boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "setInnerContainerSize": {
                    "type": "method",
                    "define": "setInnerContainerSize(${1:#size_table size})",
                    "detail": "Change inner container size of scrollview.\nInner container size must be larger than or equal scrollview's size.\nparam size Inner container size.\n"
                },
                "isScrollBarEnabled": {
                    "type": "method",
                    "define": "isScrollBarEnabled()",
                    "detail": "brief Query scroll bar state.\nreturn True if scroll bar is enabled, false otherwise.\n"
                },
                "scrollToPercentBothDirection": {
                    "type": "method",
                    "define": "scrollToPercentBothDirection(${1:#vec2_table percent},${2:#float timeInSec},${3:#bool attenuated})",
                    "detail": "Scroll inner container to both direction percent position of scrollview.\nparam percent A value between 0 and 100.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "scrollToTop": {
                    "type": "method",
                    "define": "scrollToTop(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to top boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "isBounceEnabled": {
                    "type": "method",
                    "define": "isBounceEnabled()",
                    "detail": "brief Query bounce state.\nreturn True if bounce is enabled, false otherwise.\n"
                },
                "jumpToBottomLeft": {
                    "type": "method",
                    "define": "jumpToBottomLeft()",
                    "detail": "Move inner container to bottom and left boundary of scrollview.\n"
                },
                "isInertiaScrollEnabled": {
                    "type": "method",
                    "define": "isInertiaScrollEnabled()",
                    "detail": "brief Query inertia scroll state.\nreturn True if inertia is enabled, false otherwise.\n"
                },
                "setScrollBarPositionFromCornerForHorizontal": {
                    "type": "method",
                    "define": "setScrollBarPositionFromCornerForHorizontal(${1:#vec2_table positionFromCorner})",
                    "detail": "brief Set the horizontal scroll bar position from left-bottom corner.\nparam positionFromCorner The position from left-bottom corner\n"
                },
                "jumpToBottomRight": {
                    "type": "method",
                    "define": "jumpToBottomRight()",
                    "detail": "Move inner container to bottom and right boundary of scrollview.\n"
                },
                "getScrollBarColor": {
                    "type": "method",
                    "define": "getScrollBarColor()",
                    "detail": "brief Get the scroll bar's color\nreturn the scroll bar's color\n"
                },
                "scrollToBottomRight": {
                    "type": "method",
                    "define": "scrollToBottomRight(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to bottom and right boundary of scrollview.\nparam timeInSec Time in seconds\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "scrollToBottom": {
                    "type": "method",
                    "define": "scrollToBottom(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to bottom boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "getScrollBarAutoHideTime": {
                    "type": "method",
                    "define": "getScrollBarAutoHideTime()",
                    "detail": "brief Get the scroll bar's auto hide time\nreturn the scroll bar's auto hide time\n"
                },
                "setScrollBarWidth": {
                    "type": "method",
                    "define": "setScrollBarWidth(${1:#float width})",
                    "detail": "brief Set the scroll bar's width\nparam width The scroll bar's width\n"
                },
                "getInnerContainerPosition": {
                    "type": "method",
                    "define": "getInnerContainerPosition()",
                    "detail": "Get inner container position\nreturn The inner container position.\n"
                },
                "setScrollBarAutoHideTime": {
                    "type": "method",
                    "define": "setScrollBarAutoHideTime(${1:#float autoHideTime})",
                    "detail": "brief Set scroll bar auto hide time\nparam scroll bar auto hide time\n"
                },
                "stopAutoScroll": {
                    "type": "method",
                    "define": "stopAutoScroll()",
                    "detail": "Immediately stops inner container scroll initiated by any of the \"scrollTo*\" member functions\n"
                },
                "getInnerContainer": {
                    "type": "method",
                    "define": "getInnerContainer()",
                    "detail": "Get inner container of scrollview.\nInner container is a child of scrollview.\nreturn Inner container pointer.\n"
                },
                "jumpToPercentHorizontal": {
                    "type": "method",
                    "define": "jumpToPercentHorizontal(${1:#float percent})",
                    "detail": "Move inner container to horizontal percent position of scrollview.\nparam percent   A value between 0 and 100.\n"
                },
                "setInnerContainerPosition": {
                    "type": "method",
                    "define": "setInnerContainerPosition(${1:#vec2_table pos})",
                    "detail": "Set inner container position\nparam pos Inner container position.\n"
                },
                "setDirection": {
                    "type": "method",
                    "define": "setDirection(${1:#int dir})",
                    "detail": "Changes scroll direction of scrollview.\nsee `Direction`\nparam dir Scroll direction enum.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "jumpToPercentVertical": {
                    "type": "method",
                    "define": "jumpToPercentVertical(${1:#float percent})",
                    "detail": "Move inner container to vertical percent position of scrollview.\nparam percent A value between 0 and 100.\n"
                },
                "setInertiaScrollEnabled": {
                    "type": "method",
                    "define": "setInertiaScrollEnabled(${1:#bool enabled})",
                    "detail": "brief Toggle whether enable scroll inertia while scrolling.\nparam enabled True if enable inertia, false otherwise.\n"
                },
                "jumpToRight": {
                    "type": "method",
                    "define": "jumpToRight()",
                    "detail": "Move inner container to right boundary of scrollview.\n"
                },
                "setScrollBarColor": {
                    "type": "method",
                    "define": "setScrollBarColor(${1:#color3b_table color})",
                    "detail": "brief Set the scroll bar's color\nparam the scroll bar's color\n"
                },
                "scrollToBottomLeft": {
                    "type": "method",
                    "define": "scrollToBottomLeft(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to bottom and left boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "setScrollBarPositionFromCornerForVertical": {
                    "type": "method",
                    "define": "setScrollBarPositionFromCornerForVertical(${1:#vec2_table positionFromCorner})",
                    "detail": "brief Set the vertical scroll bar position from right-top corner.\nparam positionFromCorner The position from right-top corner\n"
                },
                "getDirection": {
                    "type": "method",
                    "define": "getDirection()",
                    "detail": "Query scroll direction of scrollview.\nsee `Direction`      Direction::VERTICAL means vertical scroll, Direction::HORIZONTAL means horizontal scroll\nreturn Scrollview scroll direction.\n"
                },
                "setScrollBarAutoHideEnabled": {
                    "type": "method",
                    "define": "setScrollBarAutoHideEnabled(${1:#bool autoHideEnabled})",
                    "detail": "brief Set scroll bar auto hide state\nparam scroll bar auto hide state\n"
                },
                "setScrollBarEnabled": {
                    "type": "method",
                    "define": "setScrollBarEnabled(${1:#bool enabled})",
                    "detail": "brief Toggle scroll bar enabled.\nparam enabled True if enable scroll bar, false otherwise.\n"
                },
                "jumpToBottom": {
                    "type": "method",
                    "define": "jumpToBottom()",
                    "detail": "Move inner container to bottom boundary of scrollview.\n"
                },
                "addEventListener": {
                    "type": "method",
                    "define": "addEventListener(${1:#function callback})",
                    "detail": "Add callback function which will be called  when scrollview event triggered.\nparam callback A callback function with type of `ccScrollViewCallback`.\n"
                },
                "jumpToTopRight": {
                    "type": "method",
                    "define": "jumpToTopRight()",
                    "detail": "Move inner container to top and right boundary of scrollview.\n"
                },
                "scrollToTopRight": {
                    "type": "method",
                    "define": "scrollToTopRight(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to top and right boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "jumpToPercentBothDirection": {
                    "type": "method",
                    "define": "jumpToPercentBothDirection(${1:#vec2_table percent})",
                    "detail": "Move inner container to both direction percent position of scrollview.\nparam percent   A value between 0 and 100.\n"
                },
                "scrollToLeft": {
                    "type": "method",
                    "define": "scrollToLeft(${1:#float timeInSec},${2:#bool attenuated})",
                    "detail": "Scroll inner container to left boundary of scrollview.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "jumpToTop": {
                    "type": "method",
                    "define": "jumpToTop()",
                    "detail": "Move inner container to top boundary of scrollview.\n"
                },
                "scrollToPercentVertical": {
                    "type": "method",
                    "define": "scrollToPercentVertical(${1:#float percent},${2:#float timeInSec},${3:#bool attenuated})",
                    "detail": "Scroll inner container to vertical percent position of scrollview.\nparam percent A value between 0 and 100.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "getScrollBarPositionFromCornerForHorizontal": {
                    "type": "method",
                    "define": "getScrollBarPositionFromCornerForHorizontal()",
                    "detail": "brief Get the horizontal scroll bar's position from right-top corner.\nreturn positionFromCorner\n"
                },
                "scrollToPercentHorizontal": {
                    "type": "method",
                    "define": "scrollToPercentHorizontal(${1:#float percent},${2:#float timeInSec},${3:#bool attenuated})",
                    "detail": "Scroll inner container to horizontal percent position of scrollview.\nparam percent A value between 0 and 100.\nparam timeInSec Time in seconds.\nparam attenuated Whether scroll speed attenuate or not.\n"
                },
                "getScrollBarOpacity": {
                    "type": "method",
                    "define": "getScrollBarOpacity()",
                    "detail": "brief Get the scroll bar's opacity\nreturn the scroll bar's opacity\n"
                },
                "jumpToLeft": {
                    "type": "method",
                    "define": "jumpToLeft()",
                    "detail": "Move inner container to left boundary of scrollview.\n"
                },
                "setBounceEnabled": {
                    "type": "method",
                    "define": "setBounceEnabled(${1:#bool enabled})",
                    "detail": "brief Toggle bounce enabled when scroll to the edge.\nparam enabled True if enable bounce, false otherwise.\n"
                },
                "setTouchTotalTimeThreshold": {
                    "type": "method",
                    "define": "setTouchTotalTimeThreshold(${1:#float touchTotalTimeThreshold})",
                    "detail": "brief Set the touch total time threshold\nparam the touch total time threshold\n"
                },
                "setScrollBarPositionFromCorner": {
                    "type": "method",
                    "define": "setScrollBarPositionFromCorner(${1:#vec2_table positionFromCorner})",
                    "detail": "brief Set the scroll bar positions from the left-bottom corner (horizontal) and right-top corner (vertical).\nparam positionFromCorner The position from the left-bottom corner (horizontal) and right-top corner (vertical).\n"
                },
                "getScrollBarWidth": {
                    "type": "method",
                    "define": "getScrollBarWidth()",
                    "detail": "brief Get the scroll bar's width\nreturn the scroll bar's width\n"
                },
                "getScrollBarPositionFromCornerForVertical": {
                    "type": "method",
                    "define": "getScrollBarPositionFromCornerForVertical()",
                    "detail": "brief Get the vertical scroll bar's position from right-top corner.\nreturn positionFromCorner\n"
                },
                "getInnerContainerSize": {
                    "type": "method",
                    "define": "getInnerContainerSize()",
                    "detail": "Get inner container size of scrollview.\nInner container size must be larger than or equal scrollview's size.\nreturn The inner container size.\n"
                }
            },
            "LoadingBar": {
                "1": "new",
                "getCapInsets": {
                    "type": "method",
                    "define": "getCapInsets()",
                    "detail": "brief Query LoadingBar's capInsets.\nreturn CapInsets of LoadingBar.\n"
                },
                "getRenderFile": {
                    "type": "method",
                    "define": "getRenderFile()"
                },
                "getPercent": {
                    "type": "method",
                    "define": "getPercent()",
                    "detail": "Get the progress value of LoadingBar.\nreturn Progress value from 1 to 100.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "setCapInsets": {
                    "type": "method",
                    "define": "setCapInsets(${1:#rect_table capInsets})",
                    "detail": "Set capInsets for LoadingBar.\nThis setting only take effect when enable scale9 renderer.\nparam capInsets CapInset in `Rect`.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string textureName},${2:#int texType},${3:#float percentage})",
                    "detail": "@overload self, string, float         \n@overload self         \n@overload self, string, int, float         \n"
                },
                "setPercent": {
                    "type": "method",
                    "define": "setPercent(${1:#float percent})",
                    "detail": "Changes the progress value of LoadingBar.\nparam percent   Percent value from 1 to 100.\n"
                },
                "loadTexture": {
                    "type": "method",
                    "define": "loadTexture(${1:#string texture},${2:#int texType})",
                    "detail": "Load texture for LoadingBar.\nparam texture   File name of texture.\nparam texType   Texture resource type,@see TextureResType.\n"
                },
                "setScale9Enabled": {
                    "type": "method",
                    "define": "setScale9Enabled(${1:#bool enabled})",
                    "detail": "Enable scale9 renderer.\nparam enabled Set to true will use scale9 renderer, false otherwise.\n"
                },
                "isScale9Enabled": {
                    "type": "method",
                    "define": "isScale9Enabled()",
                    "detail": "brief Query whether LoadingBar is using scale9 renderer or not.\nreturn Whether LoadingBar uses scale9 renderer or not.\n"
                },
                "getDirection": {
                    "type": "method",
                    "define": "getDirection()",
                    "detail": "Get the progress direction of LoadingBar.\nsee Direction  `LEFT` means progress left to right, `RIGHT` otherwise.\nreturn LoadingBar progress direction.\n"
                },
                "setDirection": {
                    "type": "method",
                    "define": "setDirection(${1:#int direction})",
                    "detail": "Change the progress direction of LoadingBar.\nsee Direction  `LEFT` means progress left to right, `RIGHT` otherwise.\nparam direction Direction\n"
                }
            },
            "TabHeader": {
                "getTitleFontSize": {
                    "type": "method",
                    "define": "getTitleFontSize()",
                    "detail": "get the font size of TabHeader text\nreturn TabHeader text's font size in float.\n"
                },
                "setTitleFontName": {
                    "type": "method",
                    "define": "setTitleFontName(${1:#string fontName})",
                    "detail": "Change the font name of TabHeader text\nparam fontName a font name string.\n"
                },
                "getTitleFontName": {
                    "type": "method",
                    "define": "getTitleFontName()",
                    "detail": "get the font name of TabHeader text\nreturn font name in std::string\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string titleStr},${2:#string backGround},${3:#string backGroundSelected},${4:#string cross},${5:#string backGroundDisabled},${6:#string frontCrossDisabled},${7:#int texType})",
                    "detail": "@overload self, string, string, string, int         \n@overload self         \n@overload self, string, string, string, string, string, string, int         \n"
                },
                "getTitleText": {
                    "type": "method",
                    "define": "getTitleText()",
                    "detail": "get the TabHeader text\nreturn he TabHeader text\n"
                },
                "getIndexInTabControl": {
                    "type": "method",
                    "define": "getIndexInTabControl()",
                    "detail": "get the index this header in the TabControl\nreturn -1 means not in any TabControl\n"
                },
                "getTitleColor": {
                    "type": "method",
                    "define": "getTitleColor()",
                    "detail": "get the TabHeader text color.\nreturn Color4B of TabHeader text.\n"
                },
                "setTitleFontSize": {
                    "type": "method",
                    "define": "setTitleFontSize(${1:#float size})",
                    "detail": "Change the font size of TabHeader text\nparam size TabHeader text's font size in float.\n"
                },
                "setTitleText": {
                    "type": "method",
                    "define": "setTitleText(${1:#string text})",
                    "detail": "Change the content of Header's text.\nparam text The Header's text.\n"
                },
                "getTitleRenderer": {
                    "type": "method",
                    "define": "getTitleRenderer()",
                    "detail": "Return the inner Label renderer of TabHeader.\nreturn The TabHeader Label.\n"
                },
                "setTitleColor": {
                    "type": "method",
                    "define": "setTitleColor(${1:#color4b_table color})",
                    "detail": "Change the color of he TabHeader text\nparam color The he TabHeader text's color in Color4B.\n"
                }
            },
            "TextureResType": [
                "localType",
                "plistType"
            ],
            "VBox": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table size})",
                    "detail": "@overload self, size_table         \n@overload self         \n"
                },
                "initWithSize": {
                    "type": "method",
                    "define": "initWithSize(${1:#size_table size})"
                }
            },
            "LoadingBarDirection": [
                "LEFT",
                "RIGHT"
            ],
            "ListViewDirection": [
                "horizontal",
                "none",
                "vertical"
            ],
            "Layout": {
                "1": "new",
                "getBackGroundColorOpacity": {
                    "type": "method",
                    "define": "getBackGroundColorOpacity()",
                    "detail": "Get the layout's background color opacity.\nreturn Background color opacity value.\n"
                },
                "setBackGroundImageOpacity": {
                    "type": "method",
                    "define": "setBackGroundImageOpacity(${1:#unsigned char opacity})",
                    "detail": "Set opacity of background image.\nparam opacity Background image opacity in GLubyte.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create a empty layout.\n"
                },
                "forceDoLayout": {
                    "type": "method",
                    "define": "forceDoLayout()",
                    "detail": "force refresh widget layout\n"
                },
                "getClippingType": {
                    "type": "method",
                    "define": "getClippingType()",
                    "detail": "see `setClippingType(ClippingType)`\n"
                },
                "requestDoLayout": {
                    "type": "method",
                    "define": "requestDoLayout()",
                    "detail": "request to refresh widget layout\n"
                },
                "setClippingEnabled": {
                    "type": "method",
                    "define": "setClippingEnabled(${1:#bool enabled})",
                    "detail": "Toggle layout clipping.\nIf you do need clipping, you pass true to this function.\nparam enabled Pass true to enable clipping, false otherwise.\n"
                },
                "setBackGroundImage": {
                    "type": "method",
                    "define": "setBackGroundImage(${1:#string fileName},${2:#int texType})",
                    "detail": "Sets a background image for layout.\nparam fileName image file path.\nparam texType @see TextureResType. \n"
                },
                "getRenderFile": {
                    "type": "method",
                    "define": "getRenderFile()"
                },
                "isBackGroundImageScale9Enabled": {
                    "type": "method",
                    "define": "isBackGroundImageScale9Enabled()",
                    "detail": "Query background image scale9 enable status.\nreturn Whether background image is scale9 enabled or not.\n"
                },
                "isLoopFocus": {
                    "type": "method",
                    "define": "isLoopFocus()",
                    "detail": "return If focus loop is enabled, then it will return true, otherwise it returns false. The default value is false.\n"
                },
                "setBackGroundColorVector": {
                    "type": "method",
                    "define": "setBackGroundColorVector(${1:#vec2_table vector})",
                    "detail": "Sets background color vector for layout.\nThis setting only take effect when layout's color type is BackGroundColorType::GRADIENT\nparam vector The color vector in `Vec2`.\n"
                },
                "getBackGroundColorVector": {
                    "type": "method",
                    "define": "getBackGroundColorVector()",
                    "detail": "Get the layout's background color vector.\nreturn Background color vector.\n"
                },
                "createInstance": {
                    "type": "method",
                    "define": "createInstance()"
                },
                "getLayoutType": {
                    "type": "method",
                    "define": "getLayoutType()",
                    "detail": "Query layout type.\nreturn Get the layout type.\n"
                },
                "setBackGroundImageScale9Enabled": {
                    "type": "method",
                    "define": "setBackGroundImageScale9Enabled(${1:#bool enabled})",
                    "detail": "Enable background image scale9 rendering.\nparam enabled  True means enable scale9 rendering for background image, false otherwise.\n"
                },
                "setBackGroundImageColor": {
                    "type": "method",
                    "define": "setBackGroundImageColor(${1:#color3b_table color})",
                    "detail": "Set layout's background image color.\nparam color Background color value in `Color3B`.\n"
                },
                "removeBackGroundImage": {
                    "type": "method",
                    "define": "removeBackGroundImage()",
                    "detail": "Remove the background image of layout.\n"
                },
                "setLoopFocus": {
                    "type": "method",
                    "define": "setLoopFocus(${1:#bool loop})",
                    "detail": "If a layout is loop focused which means that the focus movement will be inside the layout\nparam loop  pass true to let the focus movement loop inside the layout\n"
                },
                "setBackGroundImageCapInsets": {
                    "type": "method",
                    "define": "setBackGroundImageCapInsets(${1:#rect_table capInsets})",
                    "detail": "Sets a background image capinsets for layout, it only affects the scale9 enabled background image\nparam capInsets  The capInsets in Rect.\n"
                },
                "getBackGroundColorType": {
                    "type": "method",
                    "define": "getBackGroundColorType()",
                    "detail": "Query the layout's background color type.\nreturn The layout's background color type.\n"
                },
                "setPassFocusToChild": {
                    "type": "method",
                    "define": "setPassFocusToChild(${1:#bool pass})",
                    "detail": "param pass To specify whether the layout pass its focus to its child\n"
                },
                "setLayoutType": {
                    "type": "method",
                    "define": "setLayoutType(${1:#int type})",
                    "detail": "Change the layout type.\nparam type Layout type.\n"
                },
                "getBackGroundImageCapInsets": {
                    "type": "method",
                    "define": "getBackGroundImageCapInsets()",
                    "detail": "Query background image's capInsets size.\nreturn The background image capInsets.\n"
                },
                "setClippingType": {
                    "type": "method",
                    "define": "setClippingType(${1:#int type})",
                    "detail": "Change the clipping type of layout.\nOn default, the clipping type is `ClippingType::STENCIL`.\nsee `ClippingType`\nparam type The clipping type of layout.\n"
                },
                "setBackGroundColorOpacity": {
                    "type": "method",
                    "define": "setBackGroundColorOpacity(${1:#unsigned char opacity})",
                    "detail": "Sets background color opacity of layout.\nparam opacity The opacity in `GLubyte`.\n"
                },
                "getBackGroundColor": {
                    "type": "method",
                    "define": "getBackGroundColor()",
                    "detail": "Query the layout's background color.\nreturn Background color in Color3B.\n"
                },
                "setBackGroundColorType": {
                    "type": "method",
                    "define": "setBackGroundColorType(${1:#int type})",
                    "detail": "Sets Color Type for layout's background\nparam type   @see `BackGroundColorType`\n"
                },
                "getBackGroundImageTextureSize": {
                    "type": "method",
                    "define": "getBackGroundImageTextureSize()",
                    "detail": "Gets background image texture size.\nreturn background image texture size.\n"
                },
                "isPassFocusToChild": {
                    "type": "method",
                    "define": "isPassFocusToChild()",
                    "detail": "return To query whether the layout will pass the focus to its children or not. The default value is true\n"
                },
                "getBackGroundImageOpacity": {
                    "type": "method",
                    "define": "getBackGroundImageOpacity()",
                    "detail": "Get the opacity of layout's background image.\nreturn The opacity of layout's background image.\n"
                },
                "getBackGroundImageColor": {
                    "type": "method",
                    "define": "getBackGroundImageColor()",
                    "detail": "Get color of layout's background image.\nreturn Layout's background image color.\n"
                },
                "getBackGroundEndColor": {
                    "type": "method",
                    "define": "getBackGroundEndColor()",
                    "detail": "Get the gradient background end color.\nreturn Gradient background end color value.\n"
                },
                "isClippingEnabled": {
                    "type": "method",
                    "define": "isClippingEnabled()",
                    "detail": "Gets if layout is clipping enabled.\nreturn if layout is clipping enabled.\n"
                },
                "getBackGroundStartColor": {
                    "type": "method",
                    "define": "getBackGroundStartColor()",
                    "detail": "Get the gradient background start color.\nreturn  Gradient background start color value.\n"
                },
                "setBackGroundColor": {
                    "type": "method",
                    "define": "setBackGroundColor(${1:#color3b_table startColor},${2:#color3b_table endColor})",
                    "detail": "@overload self, color3b_table, color3b_table         \n@overload self, color3b_table         \n"
                }
            },
            "Helper": {
                "seekWidgetByTag": {
                    "type": "method",
                    "define": "seekWidgetByTag(${1:#ccui.Widget root},${2:#int tag})",
                    "detail": "Find a widget with a specific tag from root widget.\nThis search will be recursive through all child widgets.\nparam root      The be searched root widget.\nparam tag       The widget tag.\nreturn Widget instance pointer.\n"
                },
                "seekWidgetByName": {
                    "type": "method",
                    "define": "seekWidgetByName(${1:#ccui.Widget root},${2:#string name})",
                    "detail": "Find a widget with a specific name from root widget.\nThis search will be recursive through all child widgets.\nparam root      The be searched root widget.\nparam name      The widget name.\nreturn Widget instance pointer.\n"
                },
                "changeLayoutSystemActiveState": {
                    "type": "method",
                    "define": "changeLayoutSystemActiveState(${1:#bool active})",
                    "detail": "Change the active property of Layout's @see `LayoutComponent`\nparam active A boolean value.\n"
                },
                "restrictCapInsetRect": {
                    "type": "method",
                    "define": "restrictCapInsetRect(${1:#rect_table capInsets},${2:#size_table textureSize})",
                    "detail": "brief  restrict capInsetSize, when the capInsets's width is larger than the textureSize, it will restrict to 0,\nthe height goes the same way as width.\nparam  capInsets A user defined capInsets.\nparam  textureSize  The size of a scale9enabled texture\nreturn a restricted capInset.\n"
                },
                "seekActionWidgetByActionTag": {
                    "type": "method",
                    "define": "seekActionWidgetByActionTag(${1:#ccui.Widget root},${2:#int tag})",
                    "detail": "Find a widget with a specific action tag from root widget\nThis search will be recursive through all child widgets.\nparam root The be searched root widget.\nparam tag The widget action's tag.\nreturn Widget instance pointer.\n"
                },
                "convertBoundingBoxToScreen": {
                    "type": "method",
                    "define": "convertBoundingBoxToScreen(${1:#cc.Node node})",
                    "detail": "brief Convert a node's boundingBox rect into screen coordinates.\nparam node Any node pointer.\nreturn A Rect in screen coordinates.\n"
                },
                "doLayout": {
                    "type": "method",
                    "define": "doLayout(${1:#cc.Node rootNode})",
                    "detail": "Refresh object and it's children layout state\nparam rootNode   A Node* or Node* descendant instance pointer.\n"
                },
                "getSubStringOfUTF8String": {
                    "type": "method",
                    "define": "getSubStringOfUTF8String(${1:#string str},${2:#unsigned long start},${3:#unsigned long length})",
                    "detail": "brief Get a UTF8 substring from a std::string with a given start position and length\nSample:  std::string str = \"中国中国中国\";  substr = getSubStringOfUTF8String(str,0,2) will = \"中国\"\nparam str The source string.\nparam start The start position of the substring.\nparam length The length of the substring in UTF8 count\nreturn a UTF8 substring\njs NA\n"
                }
            },
            "ScrollViewDir": [
                "both",
                "horizontal",
                "none",
                "vertical"
            ]
        },
        "sp": {
            "EventType": [
                "ANIMATION_COMPLETE",
                "ANIMATION_DISPOSE",
                "ANIMATION_END",
                "ANIMATION_EVENT",
                "ANIMATION_INTERRUPT",
                "ANIMATION_START"
            ],
            "SkeletonAnimation_my": {
                "1": "new",
                "createWithJsonFile": {
                    "type": "method",
                    "define": "createWithJsonFile(${1:#string skeletonJsonFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                },
                "replaceAttchment": {
                    "type": "method",
                    "define": "replaceAttchment(${1:#string slotName},${2:#string attachmentName},${3:#cc.SpriteFrame pSF})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "createWithData": {
                    "type": "method",
                    "define": "createWithData(${1:#spSkeletonData skeletonData},${2:#bool ownsSkeletonData})"
                },
                "setReplaceTex": {
                    "type": "method",
                    "define": "setReplaceTex()"
                },
                "setOutlineInfo": {
                    "type": "method",
                    "define": "setOutlineInfo(${1:#int outLineSzie},${2:#color3b_table outlineColor},${3:#color3b_table foregroundColor})"
                },
                "clearAllAttchmentReplace": {
                    "type": "method",
                    "define": "clearAllAttchmentReplace()"
                },
                "setEnabledTPRotate": {
                    "type": "method",
                    "define": "setEnabledTPRotate(${1:#bool enabledTPRotate})"
                },
                "isEnabledTPRotate": {
                    "type": "method",
                    "define": "isEnabledTPRotate()"
                },
                "createWithBinaryFile": {
                    "type": "method",
                    "define": "createWithBinaryFile(${1:#string skeletonBinaryFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                }
            },
            "SkeletonRenderer": {
                "1": "new",
                "createWithFile": {
                    "type": "method",
                    "define": "createWithFile(${1:#string skeletonDataFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                },
                "initWithData": {
                    "type": "method",
                    "define": "initWithData(${1:#spSkeletonData skeletonData},${2:#bool ownsSkeletonData})"
                },
                "getDebugSlotsEnabled": {
                    "type": "method",
                    "define": "getDebugSlotsEnabled()"
                },
                "initWithBinaryFile": {
                    "type": "method",
                    "define": "initWithBinaryFile(${1:#string skeletonDataFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                },
                "initWithJsonFile": {
                    "type": "method",
                    "define": "initWithJsonFile(${1:#string skeletonDataFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                },
                "getSkeleton": {
                    "type": "method",
                    "define": "getSkeleton()"
                },
                "setDebugSlotsEnabled": {
                    "type": "method",
                    "define": "setDebugSlotsEnabled(${1:#bool enabled})"
                },
                "setSkin": {
                    "type": "method",
                    "define": "setSkin(${1:#string skinName})",
                    "detail": "@overload self, char         \n@overload self, string         \n"
                },
                "getTimeScale": {
                    "type": "method",
                    "define": "getTimeScale()"
                },
                "setToSetupPose": {
                    "type": "method",
                    "define": "setToSetupPose()"
                },
                "getDebugBonesEnabled": {
                    "type": "method",
                    "define": "getDebugBonesEnabled()"
                },
                "setBonesToSetupPose": {
                    "type": "method",
                    "define": "setBonesToSetupPose()"
                },
                "setDebugBonesEnabled": {
                    "type": "method",
                    "define": "setDebugBonesEnabled(${1:#bool enabled})"
                },
                "setTimeScale": {
                    "type": "method",
                    "define": "setTimeScale(${1:#float scale})"
                },
                "setSlotsToSetupPose": {
                    "type": "method",
                    "define": "setSlotsToSetupPose()"
                },
                "initialize": {
                    "type": "method",
                    "define": "initialize()"
                }
            },
            "SkeletonAnimation": {
                "1": "addAnimation",
                "2": "registerSpineEventHandler",
                "3": "setAnimation",
                "4": "setBlendFunc",
                "createWithJsonFile": {
                    "type": "method",
                    "define": "createWithJsonFile(${1:#string skeletonJsonFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                },
                "setCompleteListener": {
                    "type": "method",
                    "define": "setCompleteListener(${1:#function listener})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "setTrackCompleteListener": {
                    "type": "method",
                    "define": "setTrackCompleteListener(${1:#spTrackEntry entry},${2:#function listener})"
                },
                "clearTrack": {
                    "type": "method",
                    "define": "clearTrack()"
                },
                "setTrackDisposeListener": {
                    "type": "method",
                    "define": "setTrackDisposeListener(${1:#spTrackEntry entry},${2:#function listener})"
                },
                "setEventListener": {
                    "type": "method",
                    "define": "setEventListener(${1:#function listener})"
                },
                "setTrackEndListener": {
                    "type": "method",
                    "define": "setTrackEndListener(${1:#spTrackEntry entry},${2:#function listener})"
                },
                "5": "unregisterSpineEventHandler",
                "clearTracks": {
                    "type": "method",
                    "define": "clearTracks()"
                },
                "setEndListener": {
                    "type": "method",
                    "define": "setEndListener(${1:#function listener})"
                },
                "setTrackStartListener": {
                    "type": "method",
                    "define": "setTrackStartListener(${1:#spTrackEntry entry},${2:#function listener})"
                },
                "setDisposeListener": {
                    "type": "method",
                    "define": "setDisposeListener(${1:#function listener})"
                },
                "createWithBinaryFile": {
                    "type": "method",
                    "define": "createWithBinaryFile(${1:#string skeletonBinaryFile},${2:#spAtlas atlas},${3:#float scale})",
                    "detail": "@overload self, string, string, float         \n@overload self, string, spAtlas, float         \n"
                },
                "setTrackEventListener": {
                    "type": "method",
                    "define": "setTrackEventListener(${1:#spTrackEntry entry},${2:#function listener})"
                },
                "setTrackInterruptListener": {
                    "type": "method",
                    "define": "setTrackInterruptListener(${1:#spTrackEntry entry},${2:#function listener})"
                },
                "findAnimation": {
                    "type": "method",
                    "define": "findAnimation(${1:#string name})"
                },
                "setInterruptListener": {
                    "type": "method",
                    "define": "setInterruptListener(${1:#function listener})"
                },
                "setMix": {
                    "type": "method",
                    "define": "setMix(${1:#string fromAnimation},${2:#string toAnimation},${3:#float duration})"
                },
                "setStartListener": {
                    "type": "method",
                    "define": "setStartListener(${1:#function listener})"
                }
            }
        },
        "serialize": [
            "dump",
            "pack",
            "unpack"
        ],
        "jit": {
            "2": "attach",
            "3": "flush",
            "4": "off",
            "5": "on",
            "6": "os",
            "7": "status",
            "8": "version",
            "9": "version_num",
            "opt": [
                "start"
            ]
        },
        "io": [
            "close",
            "exists",
            "filesize",
            "flush",
            "input",
            "lines",
            "open",
            "output",
            "pathinfo",
            "popen",
            "read",
            "readfile",
            "stderr",
            "stdin",
            "stdout",
            "tmpfile",
            "type",
            "write",
            "writefile"
        ],
        "cc": {
            "2": "ANIMATION_FRAME_DISPLAYED_NOTIFICATION",
            "3": "ASSETSMANAGER_CREATE_FILE",
            "4": "ASSETSMANAGER_NETWORK",
            "5": "ASSETSMANAGER_NO_NEW_VERSION",
            "6": "ASSETSMANAGER_PROTOCOL_ERROR",
            "7": "ASSETSMANAGER_PROTOCOL_PROGRESS",
            "8": "ASSETSMANAGER_PROTOCOL_SUCCESS",
            "9": "ASSETSMANAGER_UNCOMPRESS",
            "10": "ATTRIBUTE_NAME_COLOR",
            "11": "ATTRIBUTE_NAME_POSITION",
            "12": "ATTRIBUTE_NAME_TEX_COORD",
            "13": "AUDIO_INVAILD_ID",
            "14": "AUDIO_TIME_UNKNOWN",
            "15": "AnimationFrameData",
            "16": "BLEND_DST",
            "17": "BLEND_SRC",
            "18": "CHIPMUNK_IMPORT",
            "19": "CONTROL_EVENTTYPE_DRAG_ENTER",
            "20": "CONTROL_EVENTTYPE_DRAG_EXIT",
            "21": "CONTROL_EVENTTYPE_DRAG_INSIDE",
            "22": "CONTROL_EVENTTYPE_DRAG_OUTSIDE",
            "23": "CONTROL_EVENTTYPE_TOUCH_CANCEL",
            "24": "CONTROL_EVENTTYPE_TOUCH_DOWN",
            "25": "CONTROL_EVENTTYPE_TOUCH_UP_INSIDE",
            "26": "CONTROL_EVENTTYPE_TOUCH_UP_OUTSIDE",
            "27": "CONTROL_EVENTTYPE_VALUE_CHANGED",
            "28": "CONTROL_STATE_DISABLED",
            "29": "CONTROL_STATE_HIGH_LIGHTED",
            "30": "CONTROL_STATE_NORMAL",
            "31": "CONTROL_STATE_SELECTED",
            "32": "CONTROL_STEPPER_PART_MINUS",
            "33": "CONTROL_STEPPER_PART_NONE",
            "34": "CONTROL_STEPPER_PART_PLUS",
            "35": "DEVICEI_PAD",
            "36": "DEVICEI_PAD_RETINA_DISPLAY",
            "37": "DEVICEI_PHONE",
            "38": "DEVICEI_PHONE5",
            "39": "DEVICEI_PHONE5_RETINA_DISPLAY",
            "40": "DEVICEI_PHONE_RETINA_DISPLAY",
            "41": "DEVICE_MAC",
            "42": "DEVICE_MAC_RETINA_DISPLAY",
            "43": "DIRECTOR_IOS_USE_BACKGROUND_THREAD",
            "44": "DIRECTOR_MAC_THREAD",
            "45": "DIRECTOR_PROJECTION2_D",
            "46": "DIRECTOR_PROJECTION3_D",
            "47": "DIRECTOR_PROJECTION_2D",
            "48": "DIRECTOR_PROJECTION_3D",
            "49": "DIRECTOR_PROJECTION_CUSTOM",
            "50": "DIRECTOR_PROJECTION_DEFAULT",
            "51": "DIRECTOR_STATS_INTERVAL",
            "52": "EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS",
            "53": "EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE",
            "54": "EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD",
            "55": "EDITBOX_INPUT_FLAG_PASSWORD",
            "56": "EDITBOX_INPUT_FLAG_SENSITIVE",
            "57": "EDITBOX_INPUT_MODE_ANY",
            "58": "EDITBOX_INPUT_MODE_DECIMAL",
            "59": "EDITBOX_INPUT_MODE_EMAILADDR",
            "60": "EDITBOX_INPUT_MODE_NUMERIC",
            "61": "EDITBOX_INPUT_MODE_PHONENUMBER",
            "62": "EDITBOX_INPUT_MODE_SINGLELINE",
            "63": "EDITBOX_INPUT_MODE_URL",
            "64": "ENABLE_BOX2_D_INTEGRATION",
            "65": "ENABLE_DEPRECATED",
            "66": "ENABLE_GL_STATE_CACHE",
            "67": "ENABLE_PROFILERS",
            "68": "ENABLE_STACKABLE_ACTIONS",
            "69": "EVENT_ACCELERATION",
            "70": "EVENT_CUSTOM",
            "71": "EVENT_KEYBOARD",
            "72": "EVENT_MOUSE",
            "73": "EVENT_TOUCH_ALL_AT_ONCE",
            "74": "EVENT_TOUCH_ONE_BY_ONE",
            "75": "EVENT_UNKNOWN",
            "76": "FILE_UTILS_SEARCH_DIRECTORY_MODE",
            "77": "FILE_UTILS_SEARCH_SUFFIX_MODE",
            "78": "FIX_ARTIFACTS_BY_STRECHING_TEXEL",
            "79": "FLIPED_ALL",
            "80": "FLIPPED_MASK",
            "81": "GLYPHCOLLECTION_ASCII",
            "82": "GLYPHCOLLECTION_CUSTOM",
            "83": "GLYPHCOLLECTION_DYNAMIC",
            "84": "GLYPHCOLLECTION_NEHE",
            "85": "GL_ALL",
            "86": "IMAGE_FORMAT_JPEG",
            "87": "IMAGE_FORMAT_PNG",
            "88": "ITEM_SIZE",
            "89": "KEYBOARD_RETURNTYPE_DEFAULT",
            "90": "KEYBOARD_RETURNTYPE_DONE",
            "91": "KEYBOARD_RETURNTYPE_GO",
            "92": "KEYBOARD_RETURNTYPE_SEARCH",
            "93": "KEYBOARD_RETURNTYPE_SEND",
            "94": "LABELATLAS_DEBUG_DRAW",
            "95": "LABELBMFONT_DEBUG_DRAW",
            "96": "LABEL_AUTOMATIC_WIDTH",
            "97": "LANGUAGE_ARABIC",
            "98": "LANGUAGE_BULGARIAN",
            "99": "LANGUAGE_CHINESE",
            "100": "LANGUAGE_DUTCH",
            "101": "LANGUAGE_ENGLISH",
            "102": "LANGUAGE_FRENCH",
            "103": "LANGUAGE_GERMAN",
            "104": "LANGUAGE_HUNGARIAN",
            "105": "LANGUAGE_ITALIAN",
            "106": "LANGUAGE_JAPANESE",
            "107": "LANGUAGE_KOREAN",
            "108": "LANGUAGE_NORWEGIAN",
            "109": "LANGUAGE_POLISH",
            "110": "LANGUAGE_PORTUGUESE",
            "111": "LANGUAGE_ROMANIAN",
            "112": "LANGUAGE_RUSSIAN",
            "113": "LANGUAGE_SPANISH",
            "114": "LANGUAGE_TURKISH",
            "115": "LANGUAGE_UKRAINIAN",
            "116": "LINE_BREAK_MODE_CHARACTER_WRAP",
            "117": "LINE_BREAK_MODE_CLIP",
            "118": "LINE_BREAK_MODE_HEAD_TRUNCATION",
            "119": "LINE_BREAK_MODE_MIDDLE_TRUNCATION",
            "120": "LINE_BREAK_MODE_TAIL_TRUNCATION",
            "121": "LINE_BREAK_MODE_WORD_WRAP",
            "122": "MAC_USE_DISPLAY_LINK_THREAD",
            "123": "MAC_USE_MAIN_THREAD",
            "124": "MAC_USE_OWN_THREAD",
            "125": "MAC_VERSION_10_6",
            "126": "MAC_VERSION_10_7",
            "127": "MAC_VERSION_10_8",
            "128": "MENU_HANDLER_PRIORITY",
            "129": "MENU_STATE_TRACKING_TOUCH",
            "130": "MENU_STATE_WAITING",
            "131": "NODE_ON_CLEAN_UP",
            "132": "NODE_ON_ENTER",
            "133": "NODE_ON_ENTER_TRANSITION_DID_FINISH",
            "134": "NODE_ON_EXIT",
            "135": "NODE_ON_EXIT_TRANSITION_DID_START",
            "136": "NODE_RENDER_SUBPIXEL",
            "137": "NODE_TAG_INVALID",
            "138": "NUMBER_OF_CELLS_IN_TABLEVIEW",
            "139": "OS_VERSION_4_0",
            "140": "OS_VERSION_4_0_1",
            "141": "OS_VERSION_4_1",
            "142": "OS_VERSION_4_2",
            "143": "OS_VERSION_4_2_1",
            "144": "OS_VERSION_4_3",
            "145": "OS_VERSION_4_3_1",
            "146": "OS_VERSION_4_3_2",
            "147": "OS_VERSION_4_3_3",
            "148": "OS_VERSION_4_3_4",
            "149": "OS_VERSION_4_3_5",
            "150": "OS_VERSION_5_0",
            "151": "OS_VERSION_5_0_1",
            "152": "OS_VERSION_5_1_0",
            "153": "OS_VERSION_6_0_0",
            "154": "PARTICLE_DURATION_INFINITY",
            "155": "PARTICLE_MODE_GRAVITY",
            "156": "PARTICLE_MODE_RADIUS",
            "157": "PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS",
            "158": "PARTICLE_START_SIZE_EQUAL_TO_END_SIZE",
            "159": "PLATFORM_OS_ANDROID",
            "160": "PLATFORM_OS_BLACKBERRY",
            "161": "PLATFORM_OS_EMSCRIPTEN",
            "162": "PLATFORM_OS_IPAD",
            "163": "PLATFORM_OS_IPHONE",
            "164": "PLATFORM_OS_LINUX",
            "165": "PLATFORM_OS_MAC",
            "166": "PLATFORM_OS_NACL",
            "167": "PLATFORM_OS_TIZEN",
            "168": "PLATFORM_OS_WINDOWS",
            "169": "PLATFORM_OS_WINRT",
            "170": "PLATFORM_OS_WP8",
            "171": "POSITION_TYPE_FREE",
            "172": "POSITION_TYPE_GROUPED",
            "173": "POSITION_TYPE_RELATIVE",
            "174": "PRIORITY_NON_SYSTEM_MIN",
            "175": "PRIORITY_SYSTEM",
            "176": "PROGRESS_TIMER_TYPE_BAR",
            "177": "PROGRESS_TIMER_TYPE_RADIAL",
            "178": "PVRMIPMAP_MAX",
            "179": "PhysicsMaterial",
            "180": "PointSprite",
            "181": "Quad2",
            "182": "Quad3",
            "183": "REPEAT_FOREVER",
            "184": "RESOLUTION_MAC",
            "185": "RESOLUTION_MAC_RETINA_DISPLAY",
            "186": "RESOLUTION_UNKNOWN",
            "187": "RPerp",
            "188": "SCROLLVIEW_DIRECTION_BOTH",
            "189": "SCROLLVIEW_DIRECTION_HORIZONTAL",
            "190": "SCROLLVIEW_DIRECTION_NONE",
            "191": "SCROLLVIEW_DIRECTION_VERTICAL",
            "192": "SCROLLVIEW_SCRIPT_SCROLL",
            "193": "SCROLLVIEW_SCRIPT_ZOOM",
            "194": "SHADER_POSITION_COLOR",
            "195": "SHADER_POSITION_LENGTH_TEXURE_COLOR",
            "196": "SHADER_POSITION_TEXTURE",
            "197": "SHADER_POSITION_TEXTURE_A8_COLOR",
            "198": "SHADER_POSITION_TEXTURE_COLOR",
            "199": "SHADER_POSITION_TEXTURE_COLOR_ALPHA_TEST",
            "200": "SHADER_POSITION_TEXTURE_U_COLOR",
            "201": "SHADER_POSITION_U_COLOR",
            "202": "SPRITEBATCHNODE_RENDER_SUBPIXEL",
            "203": "SPRITE_DEBUG_DRAW",
            "204": "SPRITE_INDEX_NOT_INITIALIZED",
            "205": "T2F_Quad",
            "206": "TABLECELL_HIGH_LIGHT",
            "207": "TABLECELL_SIZE_AT_INDEX",
            "208": "TABLECELL_SIZE_FOR_INDEX",
            "209": "TABLECELL_TOUCHED",
            "210": "TABLECELL_UNHIGH_LIGHT",
            "211": "TABLECELL_WILL_RECYCLE",
            "212": "TABLEVIEW_FILL_BOTTOMUP",
            "213": "TABLEVIEW_FILL_TOPDOWN",
            "214": "TEXTURE2_D_PIXEL_FORMAT_A8",
            "215": "TEXTURE2_D_PIXEL_FORMAT_AUTO",
            "216": "TEXTURE2_D_PIXEL_FORMAT_A_I88",
            "217": "TEXTURE2_D_PIXEL_FORMAT_BGR_A8888",
            "218": "TEXTURE2_D_PIXEL_FORMAT_DEFAULT",
            "219": "TEXTURE2_D_PIXEL_FORMAT_ETC",
            "220": "TEXTURE2_D_PIXEL_FORMAT_I8",
            "221": "TEXTURE2_D_PIXEL_FORMAT_PVRTC2",
            "222": "TEXTURE2_D_PIXEL_FORMAT_PVRTC2A",
            "223": "TEXTURE2_D_PIXEL_FORMAT_PVRTC4",
            "224": "TEXTURE2_D_PIXEL_FORMAT_PVRTC4A",
            "225": "TEXTURE2_D_PIXEL_FORMAT_RGB5_A1",
            "226": "TEXTURE2_D_PIXEL_FORMAT_RGB_A4444",
            "227": "TEXTURE2_D_PIXEL_FORMAT_RGB_A8888",
            "228": "TEXTURE2_D_PIXEL_FORMAT_RG_B565",
            "229": "TEXTURE2_D_PIXEL_FORMAT_RG_B888",
            "230": "TEXTURE2_D_PIXEL_FORMAT_S3TC_DXT1",
            "231": "TEXTURE2_D_PIXEL_FORMAT_S3TC_DXT3",
            "232": "TEXTURE2_D_PIXEL_FORMAT_S3TC_DXT5",
            "233": "TEXTURE_ATLAS_USE_TRIANGLE_STRIP",
            "234": "TEXTURE_ATLAS_USE_VAO",
            "235": "TEXT_ALIGNMENT_CENTER",
            "236": "TEXT_ALIGNMENT_LEFT",
            "237": "TEXT_ALIGNMENT_RIGHT",
            "238": "TMX_ORIENTATION_HEX",
            "239": "TMX_ORIENTATION_ISO",
            "240": "TMX_ORIENTATION_ORTHO",
            "241": "TMX_TILE_DIAGONAL_FLAG",
            "242": "TMX_TILE_HORIZONTAL_FLAG",
            "243": "TMX_TILE_VERTICAL_FLAG",
            "244": "TOUCHES_ALL_AT_ONCE",
            "245": "TOUCHES_ONE_BY_ONE",
            "246": "TRANSITION_ORIENTATION_DOWN_OVER",
            "247": "TRANSITION_ORIENTATION_LEFT_OVER",
            "248": "TRANSITION_ORIENTATION_RIGHT_OVER",
            "249": "TRANSITION_ORIENTATION_UP_OVER",
            "250": "UNIFORM_ALPHA_TEST_VALUE_S",
            "251": "UNIFORM_COS_TIME",
            "252": "UNIFORM_COS_TIME_S",
            "253": "UNIFORM_MAX",
            "254": "UNIFORM_MVP_MATRIX",
            "255": "UNIFORM_MVP_MATRIX_S",
            "256": "UNIFORM_MV_MATRIX",
            "Animation3D": {
                "1": "new",
                "getDuration": {
                    "type": "method",
                    "define": "getDuration()",
                    "detail": "get duration\n"
                },
                "initWithFile": {
                    "type": "method",
                    "define": "initWithFile(${1:#string filename},${2:#string animationName})",
                    "detail": "init Animation3D with file name and animation name\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string filename},${2:#string animationName})",
                    "detail": "read all animation or only the animation with given animationName? animationName == \"\" read the first.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#cc.Animation3DData data})",
                    "detail": "init Animation3D from bundle data\n"
                }
            },
            "BillBoard_Mode": [
                "VIEW_PLANE_ORIENTED",
                "VIEW_POINT_ORIENTED"
            ],
            "EaseExponentialOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "Properties": {
                "1": "collector",
                "2": "createNonRefCounted",
                "exists": {
                    "type": "method",
                    "define": "exists(${1:#char name})",
                    "detail": "Check if a property with the given name is specified in this Properties object.\nparam name The name of the property to query.\nreturn True if the property exists, false otherwise.\n"
                },
                "parseVec2": {
                    "type": "method",
                    "define": "parseVec2(${1:#char str},${2:#vec2_table out})",
                    "detail": "Attempts to parse the specified string as a Vector2 value.\nOn error, false is returned and the output is set to all zero values.\nparam str The string to parse.\nparam out The value to populate if successful.\nreturn True if a valid Vector2 was parsed, false otherwise.\n"
                },
                "getVec4": {
                    "type": "method",
                    "define": "getVec4(${1:#char name},${2:#vec4_table out})",
                    "detail": "Interpret the value of the given property as a Vector4.\nIf the property does not exist, out will be set to Vector4(0.0f, 0.0f, 0.0f, 0.0f).\nIf the property exists but could not be scanned, an error will be logged and out will be set\nto Vector4(0.0f, 0.0f, 0.0f, 0.0f).\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam out The vector to set to this property's interpreted value.\nreturn True on success, false if the property does not exist or could not be scanned.\n"
                },
                "getColor": {
                    "type": "method",
                    "define": "getColor(${1:#char name},${2:#vec3_table out})",
                    "detail": "@overload self, char, vec4_table         \n@overload self, char, vec3_table         \n"
                },
                "getVariable": {
                    "type": "method",
                    "define": "getVariable(${1:#char name},${2:#char defaultValue})",
                    "detail": "Returns the value of a variable that is set in this Properties object.\nVariables take on the format ${name} and are inherited from parent Property objects.\nparam name Name of the variable to get.\nparam defaultValue Value to return if the variable is not found.\nreturn The value of the specified variable, or defaultValue if not found.\n"
                },
                "getVec2": {
                    "type": "method",
                    "define": "getVec2(${1:#char name},${2:#vec2_table out})",
                    "detail": "Interpret the value of the given property as a Vector2.\nIf the property does not exist, out will be set to Vector2(0.0f, 0.0f).\nIf the property exists but could not be scanned, an error will be logged and out will be set\nto Vector2(0.0f, 0.0f).\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam out The vector to set to this property's interpreted value.\nreturn True on success, false if the property does not exist or could not be scanned.\n"
                },
                "getPath": {
                    "type": "method",
                    "define": "getPath(${1:#char name},${2:#string path})",
                    "detail": "Gets the file path for the given property if the file exists.\nThis method will first search for the file relative to the working directory.\nIf the file is not found then it will search relative to the directory the bundle file is in.\nparam name The name of the property.\nparam path The string to copy the path to if the file exists.\nreturn True if the property exists and the file exists, false otherwise.\nscript{ignore}\n"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()",
                    "detail": "Get the value of the given property as a string. This can always be retrieved,\nwhatever the intended type of the property.\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam defaultValue The default value to return if the specified property does not exist.\nreturn The value of the given property as a string, or the empty string if no property with that name exists.\n"
                },
                "getNamespace": {
                    "type": "method",
                    "define": "getNamespace(${1:#char id},${2:#bool searchNames},${3:#bool recurse})",
                    "detail": "@overload self         \n@overload self, char, bool, bool         \n"
                },
                "setVariable": {
                    "type": "method",
                    "define": "setVariable(${1:#char name},${2:#char value})",
                    "detail": "Sets the value of the specified variable.\nparam name Name of the variable to set.\nparam value The value to set.\n"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#char name},${2:#char value})",
                    "detail": "Sets the value of the property with the specified name.\nIf there is no property in this namespace with the current name,\none is added. Otherwise, the value of the first property with the\nspecified name is updated.\nIf name is NULL, the value current property (see getNextProperty) is\nset, unless there is no current property, in which case false\nis returned.\nparam name The name of the property to set.\nparam value The property value.\nreturn True if the property was set, false otherwise.\n"
                },
                "rewind": {
                    "type": "method",
                    "define": "rewind()",
                    "detail": "Rewind the getNextProperty() and getNextNamespace() iterators\nto the beginning of the file.\n"
                },
                "parseVec4": {
                    "type": "method",
                    "define": "parseVec4(${1:#char str},${2:#vec4_table out})",
                    "detail": "Attempts to parse the specified string as a Vector4 value.\nOn error, false is returned and the output is set to all zero values.\nparam str The string to parse.\nparam out The value to populate if successful.\nreturn True if a valid Vector4 was parsed, false otherwise.\n"
                },
                "getMat4": {
                    "type": "method",
                    "define": "getMat4(${1:#char name},${2:#mat4_table out})",
                    "detail": "Interpret the value of the given property as a Matrix.\nIf the property does not exist, out will be set to the identity matrix.\nIf the property exists but could not be scanned, an error will be logged and out will be set\nto the identity matrix.\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam out The matrix to set to this property's interpreted value.\nreturn True on success, false if the property does not exist or could not be scanned.\n"
                },
                "parseVec3": {
                    "type": "method",
                    "define": "parseVec3(${1:#char str},${2:#vec3_table out})",
                    "detail": "Attempts to parse the specified string as a Vector3 value.\nOn error, false is returned and the output is set to all zero values.\nparam str The string to parse.\nparam out The value to populate if successful.\nreturn True if a valid Vector3 was parsed, false otherwise.\n"
                },
                "getNextProperty": {
                    "type": "method",
                    "define": "getNextProperty()",
                    "detail": "Get the name of the next property.\nIf a valid next property is returned, the value of the property can be\nretrieved using any of the get methods in this class, passing NULL for the property name.\nreturn The name of the next property, or NULL if there are no properties remaining.\n"
                },
                "getQuaternionFromAxisAngle": {
                    "type": "method",
                    "define": "getQuaternionFromAxisAngle(${1:#char name},${2:#cc.Quaternion out})",
                    "detail": "Interpret the value of the given property as a Quaternion specified as an axis angle.\nIf the property does not exist, out will be set to Quaternion().\nIf the property exists but could not be scanned, an error will be logged and out will be set\nto Quaternion().\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam out The quaternion to set to this property's interpreted value.\nreturn True on success, false if the property does not exist or could not be scanned.\n"
                },
                "getVec3": {
                    "type": "method",
                    "define": "getVec3(${1:#char name},${2:#vec3_table out})",
                    "detail": "Interpret the value of the given property as a Vector3.\nIf the property does not exist, out will be set to Vector3(0.0f, 0.0f, 0.0f).\nIf the property exists but could not be scanned, an error will be logged and out will be set\nto Vector3(0.0f, 0.0f, 0.0f).\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam out The vector to set to this property's interpreted value.\nreturn True on success, false if the property does not exist or could not be scanned.\n"
                },
                "getId": {
                    "type": "method",
                    "define": "getId()",
                    "detail": "Get the ID of this Property's namespace. The ID should be a unique identifier,\nbut its uniqueness is not enforced.\nreturn The ID of this Property's namespace.\n"
                },
                "parseColor": {
                    "type": "method",
                    "define": "parseColor(${1:#char str},${2:#vec3_table out})",
                    "detail": "@overload self, char, vec4_table         \n@overload self, char, vec3_table         \n"
                },
                "parseAxisAngle": {
                    "type": "method",
                    "define": "parseAxisAngle(${1:#char str},${2:#cc.Quaternion out})",
                    "detail": "Attempts to parse the specified string as an axis-angle value.\nThe specified string is expected to contain four comma-separated\nvalues, where the first three values represents the axis and the\nfourth value represents the angle, in degrees.\nOn error, false is returned and the output is set to all zero values.\nparam str The string to parse.\nparam out A Quaternion populated with the orientation of the axis-angle, if successful.\nreturn True if a valid axis-angle was parsed, false otherwise.\n"
                },
                "getType": {
                    "type": "method",
                    "define": "getType()",
                    "detail": "Returns the type of a property.\nparam name The name of the property to interpret, or NULL to return the current property's type.\nreturn The type of the property.\n"
                },
                "getFloat": {
                    "type": "method",
                    "define": "getFloat()",
                    "detail": "Interpret the value of the given property as a floating-point number.\nIf the property does not exist, zero will be returned.\nIf the property exists but could not be scanned, an error will be logged and zero will be returned.\nparam name The name of the property to interpret, or NULL to return the current property's value.\nreturn The value of the given property interpreted as a float.\nZero if the property does not exist or could not be scanned.\n"
                },
                "getLong": {
                    "type": "method",
                    "define": "getLong()",
                    "detail": "Interpret the value of the given property as a long integer.\nIf the property does not exist, zero will be returned.\nIf the property exists but could not be scanned, an error will be logged and zero will be returned.\nparam name The name of the property to interpret, or NULL to return the current property's value.\nreturn The value of the given property interpreted as a long.\nZero if the property does not exist or could not be scanned.\n"
                },
                "getNextNamespace": {
                    "type": "method",
                    "define": "getNextNamespace()",
                    "detail": "Get the next namespace.\n"
                },
                "getInt": {
                    "type": "method",
                    "define": "getInt()",
                    "detail": "Interpret the value of the given property as an integer.\nIf the property does not exist, zero will be returned.\nIf the property exists but could not be scanned, an error will be logged and zero will be returned.\nparam name The name of the property to interpret, or NULL to return the current property's value.\nreturn The value of the given property interpreted as an integer.\nZero if the property does not exist or could not be scanned.\n"
                },
                "getBool": {
                    "type": "method",
                    "define": "getBool()",
                    "detail": "Interpret the value of the given property as a boolean.\nparam name The name of the property to interpret, or NULL to return the current property's value.\nparam defaultValue the default value to return if the specified property does not exist within the properties file.\nreturn true if the property exists and its value is \"true\", otherwise false.\n"
                }
            },
            "Show": {
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Allocates and initializes the action.\nreturn  An autoreleased Show object.\n"
                },
                "1": "new"
            },
            "ParticleSmoke": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a smoke particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleSmoke object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a smoke particle system.\nreturn An autoreleased ParticleSmoke object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "Application": {
                "1": "is64BitIOSDevice",
                "2": "isIOS64bit",
                "setAnimationInterval": {
                    "type": "method",
                    "define": "setAnimationInterval(${1:#float interval})",
                    "detail": "brief    Callback by Director to limit FPS.\nparam interval The time, expressed in seconds, between current frame and next.\n"
                },
                "getCurrentLanguageCode": {
                    "type": "method",
                    "define": "getCurrentLanguageCode()",
                    "detail": "brief Get current language iso 639-1 code\nreturn Current language iso 639-1 code\n"
                },
                "openURL": {
                    "type": "method",
                    "define": "openURL(${1:#string url})",
                    "detail": "brief Open url in default browser\nparam String with url to open.\nreturn true if the resource located by the URL was successfully opened; otherwise false.\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "brief    Get current application instance.\nreturn Current application instance pointer.\n"
                },
                "getTargetPlatform": {
                    "type": "method",
                    "define": "getTargetPlatform()",
                    "detail": "brief Get target platform\n"
                },
                "getVersion": {
                    "type": "method",
                    "define": "getVersion()",
                    "detail": "brief Get application version.\n"
                },
                "getCurrentLanguage": {
                    "type": "method",
                    "define": "getCurrentLanguage()",
                    "detail": "brief Get current language config\nreturn Current language config\n"
                }
            },
            "EaseBackIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "AtlasNode": {
                "1": "new",
                "setTextureAtlas": {
                    "type": "method",
                    "define": "setTextureAtlas(${1:#cc.TextureAtlas textureAtlas})",
                    "detail": " Set an buffer manager of the texture vertex. \n"
                },
                "setQuadsToDraw": {
                    "type": "method",
                    "define": "setQuadsToDraw(${1:#int quadsToDraw})"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "code\nWhen this function bound into js or lua,the parameter will be changed\nIn js: var setBlendFunc(var src, var dst)\nendcode\nlua NA\n"
                },
                "initWithTileFile": {
                    "type": "method",
                    "define": "initWithTileFile(${1:#string tile},${2:#int tileWidth},${3:#int tileHeight},${4:#int itemsToRender})",
                    "detail": " Initializes an AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string filename},${2:#int tileWidth},${3:#int tileHeight},${4:#int itemsToRender})",
                    "detail": " creates a AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render.\nparam filename The path of Atlas file.\nparam tileWidth The width of the item.\nparam tileHeight The height of the item.\nparam itemsToRender The quantity of items to render.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "lua NA\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()"
                },
                "initWithTexture": {
                    "type": "method",
                    "define": "initWithTexture(${1:#cc.Texture2D texture},${2:#int tileWidth},${3:#int tileHeight},${4:#int itemsToRender})",
                    "detail": " Initializes an AtlasNode  with a texture the width and height of each item measured in points and the quantity of items to render\n"
                },
                "updateAtlasValues": {
                    "type": "method",
                    "define": "updateAtlasValues()",
                    "detail": " updates the Atlas (indexed vertex array).\nShall be overridden in subclasses.\n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})"
                },
                "getTextureAtlas": {
                    "type": "method",
                    "define": "getTextureAtlas()",
                    "detail": " Return the buffer manager of the texture vertex. \nreturn Return A TextureAtlas.\n"
                },
                "getQuadsToDraw": {
                    "type": "method",
                    "define": "getQuadsToDraw()"
                }
            },
            "EaseCubicActionIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "ParticleSnow": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a snow particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleSnow object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a snow particle system.\nreturn An autoreleased ParticleSnow object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "CameraBackgroundSkyBoxBrush": {
                "1": "new",
                "setTextureValid": {
                    "type": "method",
                    "define": "setTextureValid(${1:#bool valid})"
                },
                "setActived": {
                    "type": "method",
                    "define": "setActived(${1:#bool actived})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string positive_x},${2:#string negative_x},${3:#string positive_y},${4:#string negative_y},${5:#string positive_z},${6:#string negative_z})",
                    "detail": "@overload self         \n@overload self, string, string, string, string, string, string         \n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.TextureCube texture})",
                    "detail": "Set skybox texture \nparam texture Skybox texture\n"
                },
                "isActived": {
                    "type": "method",
                    "define": "isActived()"
                }
            },
            "WebSocket": [
                "collector",
                "close",
                "create",
                "createByAProtocol",
                "createByProtocolArray",
                "getReadyState",
                "registerScriptHandler",
                "sendString",
                "unregisterScriptHandler"
            ],
            "EventListenerTouchOneByOne": {
                "1": "create",
                "2": "new",
                "3": "registerScriptHandler",
                "isSwallowTouches": {
                    "type": "method",
                    "define": "isSwallowTouches()",
                    "detail": " Is swall touches or not.\nreturn True if needs to swall touches.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "setSwallowTouches": {
                    "type": "method",
                    "define": "setSwallowTouches(${1:#bool needSwallow})",
                    "detail": " Whether or not to swall touches.\nparam needSwallow True if needs to swall touches.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "/ Overrides\n"
                }
            },
            "TransitionProgressInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgressInOut object.\n"
                },
                "1": "new"
            },
            "Skybox": {
                "1": "new",
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.TextureCube})",
                    "detail": "texture getter and setter\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": "init Skybox.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string positive_x},${2:#string negative_x},${3:#string positive_y},${4:#string negative_y},${5:#string positive_z},${6:#string negative_z})",
                    "detail": "@overload self, string, string, string, string, string, string         \n@overload self         \n"
                },
                "reload": {
                    "type": "method",
                    "define": "reload()",
                    "detail": " reload sky box after GLESContext reconstructed.\n"
                }
            },
            "ActionCamera": {
                "1": "new",
                "getCenter": {
                    "type": "method",
                    "define": "getCenter()"
                },
                "reverse": {
                    "type": "method",
                    "define": "reverse()"
                },
                "setUp": {
                    "type": "method",
                    "define": "setUp(${1:#vec3_table up})"
                },
                "setCenter": {
                    "type": "method",
                    "define": "setCenter(${1:#vec3_table center})"
                },
                "setEye": {
                    "type": "method",
                    "define": "setEye(${1:#float x},${2:#float y},${3:#float z})",
                    "detail": "@overload self, float, float, float         \n@overload self, vec3_table         \n"
                },
                "getEye": {
                    "type": "method",
                    "define": "getEye()"
                },
                "getUp": {
                    "type": "method",
                    "define": "getUp()"
                }
            },
            "EventListenerTouchAllAtOnce": {
                "1": "create",
                "2": "new",
                "3": "registerScriptHandler",
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "/ Overrides\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                }
            },
            "TMXTilesetInfo": {
                "1": "new",
                "getRectForGID": {
                    "type": "method",
                    "define": "getRectForGID(${1:#unsigned int gid})"
                }
            },
            "Bundle3D": {
                "1": "getTrianglesList",
                "2": "new",
                "loadMaterials": {
                    "type": "method",
                    "define": "loadMaterials(${1:#cc.MaterialDatas materialdatas})"
                },
                "load": {
                    "type": "method",
                    "define": "load(${1:#string path})",
                    "detail": "load a file. You must load a file first, then call loadMeshData, loadSkinData, and so on\nparam path File to be loaded\nreturn result of load\n"
                },
                "loadAnimationData": {
                    "type": "method",
                    "define": "loadAnimationData(${1:#string id},${2:#cc.Animation3DData animationdata})",
                    "detail": "load material data from bundle\nparam id The ID of the animation, load the first animation in the bundle if it is empty\n"
                },
                "loadSkinData": {
                    "type": "method",
                    "define": "loadSkinData(${1:#string id},${2:#cc.SkinData skindata})",
                    "detail": "load skin data from bundle\nparam id The ID of the skin, load the first Skin in the bundle if it is empty\n"
                },
                "destroyBundle": {
                    "type": "method",
                    "define": "destroyBundle(${1:#cc.Bundle3D bundle})"
                },
                "createBundle": {
                    "type": "method",
                    "define": "createBundle()",
                    "detail": "create a new bundle, destroy it when finish using it\n"
                },
                "clear": {
                    "type": "method",
                    "define": "clear()"
                },
                "loadNodes": {
                    "type": "method",
                    "define": "loadNodes(${1:#cc.NodeDatas nodedatas})"
                }
            },
            "LabelOverflow": [
                "CLAMP",
                "NONE",
                "RESIZE_HEIGHT",
                "SHRINK"
            ],
            "CatmullRomBy": {
                "1": "create",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float dt},${2:#point_table points})",
                    "detail": " Initializes the action with a duration and an array of points.\nparam dt In seconds.\nparam points An PointArray.\n"
                }
            },
            "Component": {
                "getOwner": {
                    "type": "method",
                    "define": "getOwner()"
                },
                "onRemove": {
                    "type": "method",
                    "define": "onRemove()"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool enabled})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()"
                },
                "onAdd": {
                    "type": "method",
                    "define": "onAdd()"
                },
                "setName": {
                    "type": "method",
                    "define": "setName(${1:#string name})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "update": {
                    "type": "method",
                    "define": "update(${1:#float delta})"
                },
                "setOwner": {
                    "type": "method",
                    "define": "setOwner(${1:#cc.Node owner})"
                }
            },
            "ReuseGrid": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#int times})",
                    "detail": "brief Create an action with the number of times that the current grid will be reused.\nparam times Specify times the grid will be reused.\nreturn Return a pointer of ReuseGrid. When the creation failed, return nil.\n"
                },
                "initWithTimes": {
                    "type": "method",
                    "define": "initWithTimes(${1:#int times})",
                    "detail": "brief Initializes an action with the number of times that the current grid will be reused.\nparam times Specify times the grid will be reused.\nreturn If the initialization success, return true; otherwise, return false.\n"
                }
            },
            "ParticleFire": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a fire particle system.\nreturn An autoreleased ParticleFire object.\n"
                },
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a fire particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleFire object.\njs NA\n"
                }
            },
            "CameraBackgroundColorBrush": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#color4f_table color},${2:#float depth})",
                    "detail": "Create a color brush\nparam color Color used to clear the color buffer\nparam depth Depth used to clear the depth buffer\nreturn Created brush\n"
                },
                "setColor": {
                    "type": "method",
                    "define": "setColor(${1:#color4f_table color})",
                    "detail": "Set clear color\nparam color Color used to clear the color buffer\n"
                }
            },
            "RotateBy": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float deltaAngleZ_X},${3:#float deltaAngleZ_Y})",
                    "detail": "@overload self, float, float, float         \n@overload self, float, float         \n@overload self, float, vec3_table         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#float deltaAngleZ_X},${3:#float deltaAngleZ_Y})",
                    "detail": "@overload self, float, float, float         \n@overload self, float, float         \n@overload self, float, vec3_table         \n"
                }
            },
            "EaseElasticInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "1": "new"
            },
            "SimpleAudioEngine": {
                "1": "destroyInstance",
                "2": "getMusicVolume",
                "3": "isMusicPlaying",
                "4": "pauseMusic",
                "5": "playMusic",
                "6": "preloadMusic",
                "7": "resumeMusic",
                "8": "rewindMusic",
                "10": "stopMusic",
                "setEffectsVolume": {
                    "type": "method",
                    "define": "setEffectsVolume(${1:#float volume})",
                    "detail": "Set the volume of sound effects.\nparam volume must be within the range of 0.0 as the minimum and 1.0 as the maximum.\n"
                },
                "unloadEffect": {
                    "type": "method",
                    "define": "unloadEffect(${1:#char filePath})",
                    "detail": "Unload the preloaded effect from internal buffer.\nparam filePath The path of the effect file.\n"
                },
                "11": "willPlayMusic",
                "playEffect": {
                    "type": "method",
                    "define": "playEffect(${1:#char filePath},${2:#bool loop},${3:#float pitch},${4:#float pan},${5:#float gain})",
                    "detail": "Play sound effect with a file path, pitch, pan and gain.\nparam filePath The path of the effect file.\nparam loop Determines whether to loop the effect playing or not. The default value is false.\nparam pitch Frequency, normal value is 1.0. Will also change effect play time.\nparam pan   Stereo effect, in the range of [-1..1] where -1 enables only left channel.\nparam gain  Volume, in the range of [0..1]. The normal value is 1.\nreturn The sound id.\nnote Full support is under development, now there are limitations:\n- no pitch effect on Samsung Galaxy S2 with OpenSL backend enabled;\n- no pitch/pan/gain on win32.\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "Returns a shared instance of the SimpleAudioEngine.\njs NA\n"
                },
                "pauseAllEffects": {
                    "type": "method",
                    "define": "pauseAllEffects()",
                    "detail": "Pause all playing sound effect.\n"
                },
                "resumeAllEffects": {
                    "type": "method",
                    "define": "resumeAllEffects()",
                    "detail": "Resume all playing sound effect.\n"
                },
                "pauseEffect": {
                    "type": "method",
                    "define": "pauseEffect(${1:#unsigned int soundId})",
                    "detail": "Pause playing sound effect.\nparam soundId The return value of function playEffect.\n"
                },
                "getEffectsVolume": {
                    "type": "method",
                    "define": "getEffectsVolume()",
                    "detail": "The volume of the effects within the range of 0.0 as the minimum and 1.0 as the maximum.\n"
                },
                "9": "setMusicVolume",
                "stopAllEffects": {
                    "type": "method",
                    "define": "stopAllEffects()",
                    "detail": "Stop all playing sound effects.\n"
                },
                "preloadEffect": {
                    "type": "method",
                    "define": "preloadEffect(${1:#char filePath})",
                    "detail": "Preload a compressed audio file.\nThe compressed audio will be decoded to wave, then written into an internal buffer in SimpleAudioEngine.\nparam filePath The path of the effect file.\njs NA\n"
                },
                "stopEffect": {
                    "type": "method",
                    "define": "stopEffect(${1:#unsigned int soundId})",
                    "detail": "Stop playing sound effect.\nparam soundId The return value of function playEffect.\n"
                },
                "resumeEffect": {
                    "type": "method",
                    "define": "resumeEffect(${1:#unsigned int soundId})",
                    "detail": "Resume playing sound effect.\nparam soundId The return value of function playEffect.\n"
                }
            },
            "Spawn": {
                "1": "create",
                "2": "new",
                "initWithTwoActions": {
                    "type": "method",
                    "define": "initWithTwoActions(${1:#cc.FiniteTimeAction action1},${2:#cc.FiniteTimeAction action2})",
                    "detail": " initializes the Spawn action with the 2 actions to spawn \n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#array_table arrayOfActions})"
                }
            },
            "Technique": {
                "getPasses": {
                    "type": "method",
                    "define": "getPasses()",
                    "detail": " Returns the list of passes \n"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()",
                    "detail": " Returns the name of the Technique \n"
                },
                "addPass": {
                    "type": "method",
                    "define": "addPass(${1:#cc.Pass pass})",
                    "detail": " Adds a new pass to the Technique.\nOrder matters. First added, first rendered\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": " Returns a new clone of the Technique \n"
                },
                "getPassCount": {
                    "type": "method",
                    "define": "getPassCount()",
                    "detail": " Returns the number of Passes in the Technique \n"
                },
                "getPassByIndex": {
                    "type": "method",
                    "define": "getPassByIndex(${1:#int index})",
                    "detail": " Returns the Pass at given index \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Material parent})"
                },
                "createWithGLProgramState": {
                    "type": "method",
                    "define": "createWithGLProgramState(${1:#cc.Material parent},${2:#cc.GLProgramState state})",
                    "detail": " Creates a new Technique with a GLProgramState.\nMethod added to support legacy code\n"
                }
            },
            "EaseCircleActionIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "Hide": {
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Allocates and initializes the action.\nreturn An autoreleased Hide object.\n"
                },
                "1": "new"
            },
            "Camera": {
                "1": "new",
                "2": "unproject",
                "createPerspective": {
                    "type": "method",
                    "define": "createPerspective(${1:#float fieldOfView},${2:#float aspectRatio},${3:#float nearPlane},${4:#float farPlane})",
                    "detail": "Creates a perspective camera.\nparam fieldOfView The field of view for the perspective camera (normally in the range of 40-60 degrees).\nparam aspectRatio The aspect ratio of the camera (normally the width of the viewport divided by the height of the viewport).\nparam nearPlane The near plane distance.\nparam farPlane The far plane distance.\n"
                },
                "getNearPlane": {
                    "type": "method",
                    "define": "getNearPlane()",
                    "detail": "Get the frustum's near plane.\n"
                },
                "getCameraFlag": {
                    "type": "method",
                    "define": "getCameraFlag()",
                    "detail": "get & set Camera flag\n"
                },
                "getFarPlane": {
                    "type": "method",
                    "define": "getFarPlane()",
                    "detail": "Get the frustum's far plane.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " create default camera, the camera type depends on Director::getProjection, the depth of the default camera is 0 \n"
                },
                "getType": {
                    "type": "method",
                    "define": "getType()",
                    "detail": "Gets the type of camera.\nreturn The camera type.\n"
                },
                "restoreViewport": {
                    "type": "method",
                    "define": "restoreViewport()"
                },
                "getViewMatrix": {
                    "type": "method",
                    "define": "getViewMatrix()",
                    "detail": "Gets the camera's view matrix.\nreturn The camera view matrix.\n"
                },
                "initOrthographic": {
                    "type": "method",
                    "define": "initOrthographic(${1:#float zoomX},${2:#float zoomY},${3:#float nearPlane},${4:#float farPlane})"
                },
                "getRenderOrder": {
                    "type": "method",
                    "define": "getRenderOrder()",
                    "detail": "get rendered order\n"
                },
                "getDepth": {
                    "type": "method",
                    "define": "getDepth()",
                    "detail": "get depth, camera with larger depth is drawn on top of camera with smaller depth, the depth of camera with CameraFlag::DEFAULT is 0, user defined camera is -1 by default\n"
                },
                "setDefaultViewport": {
                    "type": "method",
                    "define": "setDefaultViewport(${1:#cc.experimental::Viewport vp})"
                },
                "project": {
                    "type": "method",
                    "define": "project(${1:#vec3_table src})"
                },
                "getDefaultViewport": {
                    "type": "method",
                    "define": "getDefaultViewport()"
                },
                "getDepthInView": {
                    "type": "method",
                    "define": "getDepthInView(${1:#mat4_table transform})",
                    "detail": "Get object depth towards camera\n"
                },
                "getBackgroundBrush": {
                    "type": "method",
                    "define": "getBackgroundBrush()",
                    "detail": "Get clear brush\n"
                },
                "restore": {
                    "type": "method",
                    "define": "restore()",
                    "detail": "Restore the FBO, RenderTargets and viewport.\n"
                },
                "applyFrameBufferObject": {
                    "type": "method",
                    "define": "applyFrameBufferObject()"
                },
                "apply": {
                    "type": "method",
                    "define": "apply()",
                    "detail": "Apply the FBO, RenderTargets and viewport.\n"
                },
                "setScene": {
                    "type": "method",
                    "define": "setScene(${1:#cc.Scene scene})",
                    "detail": "Set the scene,this method shall not be invoke manually\n"
                },
                "setFrameBufferObject": {
                    "type": "method",
                    "define": "setFrameBufferObject(${1:#cc.experimental::FrameBuffer fbo})",
                    "detail": "Set FBO, which will attach several render target for the rendered result.\n"
                },
                "restoreFrameBufferObject": {
                    "type": "method",
                    "define": "restoreFrameBufferObject()"
                },
                "setDepth": {
                    "type": "method",
                    "define": "setDepth(${1:#char depth})",
                    "detail": "set depth, camera with larger depth is drawn on top of camera with smaller depth, the depth of camera with CameraFlag::DEFAULT is 0, user defined camera is -1 by default\n"
                },
                "setCameraFlag": {
                    "type": "method",
                    "define": "setCameraFlag(${1:#int flag})"
                },
                "setBackgroundBrush": {
                    "type": "method",
                    "define": "setBackgroundBrush(${1:#cc.CameraBackgroundBrush clearBrush})",
                    "detail": "set the background brush. See CameraBackgroundBrush for more information.\nparam clearBrush Brush used to clear the background\n"
                },
                "setAdditionalProjection": {
                    "type": "method",
                    "define": "setAdditionalProjection(${1:#mat4_table mat})",
                    "detail": "set additional matrix for the projection matrix, it multiplies mat to projection matrix when called, used by WP8\n"
                },
                "getVisitingCamera": {
                    "type": "method",
                    "define": "getVisitingCamera()",
                    "detail": "Get the visiting camera , the visiting camera shall be set on Scene::render\n"
                },
                "projectGL": {
                    "type": "method",
                    "define": "projectGL(${1:#vec3_table src})"
                },
                "isViewProjectionUpdated": {
                    "type": "method",
                    "define": "isViewProjectionUpdated()",
                    "detail": "Whether or not the viewprojection matrix was updated since the last frame.\nreturn True if the viewprojection matrix was updated since the last frame.\n"
                },
                "getViewProjectionMatrix": {
                    "type": "method",
                    "define": "getViewProjectionMatrix()",
                    "detail": "get view projection matrix\n"
                },
                "isBrushValid": {
                    "type": "method",
                    "define": "isBrushValid()"
                },
                "initPerspective": {
                    "type": "method",
                    "define": "initPerspective(${1:#float fieldOfView},${2:#float aspectRatio},${3:#float nearPlane},${4:#float farPlane})"
                },
                "initDefault": {
                    "type": "method",
                    "define": "initDefault()",
                    "detail": " init camera \n"
                },
                "isVisibleInFrustum": {
                    "type": "method",
                    "define": "isVisibleInFrustum(${1:#cc.AABB aabb})",
                    "detail": "Is this aabb visible in frustum\n"
                },
                "clearBackground": {
                    "type": "method",
                    "define": "clearBackground()",
                    "detail": "Before rendering scene with this camera, the background need to be cleared. It clears the depth buffer with max depth by default. Use setBackgroundBrush to modify the default behavior\n"
                },
                "createOrthographic": {
                    "type": "method",
                    "define": "createOrthographic(${1:#float zoomX},${2:#float zoomY},${3:#float nearPlane},${4:#float farPlane})",
                    "detail": "Creates an orthographic camera.\nparam zoomX The zoom factor along the X-axis of the orthographic projection (the width of the ortho projection).\nparam zoomY The zoom factor along the Y-axis of the orthographic projection (the height of the ortho projection).\nparam nearPlane The near plane distance.\nparam farPlane The far plane distance.\n"
                },
                "getDefaultCamera": {
                    "type": "method",
                    "define": "getDefaultCamera()",
                    "detail": "Get the default camera of the current running scene.\n"
                },
                "getProjectionMatrix": {
                    "type": "method",
                    "define": "getProjectionMatrix()",
                    "detail": "Gets the camera's projection matrix.\nreturn The camera projection matrix.\n"
                },
                "setViewport": {
                    "type": "method",
                    "define": "setViewport(${1:#cc.experimental::Viewport vp})",
                    "detail": "Set Viewport for camera.\n"
                },
                "lookAt": {
                    "type": "method",
                    "define": "lookAt(${1:#vec3_table target},${2:#vec3_table up})",
                    "detail": "Make Camera looks at target\nparam target The target camera is point at\nparam up The up vector, usually it's Y axis\n"
                },
                "applyViewport": {
                    "type": "method",
                    "define": "applyViewport()"
                }
            },
            "MenuItemImage": {
                "1": "create",
                "2": "new",
                "setSelectedSpriteFrame": {
                    "type": "method",
                    "define": "setSelectedSpriteFrame(${1:#cc.SpriteFrame frame})",
                    "detail": " Sets the sprite frame for the selected image. \n"
                },
                "setDisabledSpriteFrame": {
                    "type": "method",
                    "define": "setDisabledSpriteFrame(${1:#cc.SpriteFrame frame})",
                    "detail": " Sets the sprite frame for the disabled image. \n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "initWithNormalImage": {
                    "type": "method",
                    "define": "initWithNormalImage(${1:#string normalImage},${2:#string selectedImage},${3:#string disabledImage},${4:#function callback})",
                    "detail": " Initializes a menu item with a normal, selected and disabled image with a callable object. \n"
                },
                "setNormalSpriteFrame": {
                    "type": "method",
                    "define": "setNormalSpriteFrame(${1:#cc.SpriteFrame frame})",
                    "detail": " Sets the sprite frame for the normal image. \n"
                }
            },
            "StopGrid": {
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "brief Create a StopGrid Action.\nreturn Return a pointer of StopGrid. When the creation failed, return nil.\n"
                },
                "1": "new"
            },
            "ParticleGalaxy": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a galaxy particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleGalaxy object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a galaxy particle system.\nreturn An autoreleased ParticleGalaxy object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "ResolutionPolicy": [
                "EXACT_FIT",
                "FIXED_HEIGHT",
                "FIXED_WIDTH",
                "NO_BORDER",
                "SHOW_ALL",
                "UNKNOWN"
            ],
            "MenuItemAtlasFont": {
                "1": "new",
                "initWithString": {
                    "type": "method",
                    "define": "initWithString(${1:#string value},${2:#string charMapFile},${3:#int itemWidth},${4:#int itemHeight},${5:#char startCharMap},${6:#function callback})",
                    "detail": " Initializes a menu item from a string and atlas with a target/selector. \n"
                }
            },
            "Speed": {
                "1": "new",
                "getInnerAction": {
                    "type": "method",
                    "define": "getInnerAction()",
                    "detail": " Return the interior action.\nreturn The interior action.\n"
                },
                "getSpeed": {
                    "type": "method",
                    "define": "getSpeed()",
                    "detail": " Return the speed.\nreturn The action speed.\n"
                },
                "setInnerAction": {
                    "type": "method",
                    "define": "setInnerAction(${1:#cc.ActionInterval action})",
                    "detail": " Replace the interior action.\nparam action The new action, it will replace the running action.\n"
                },
                "initWithAction": {
                    "type": "method",
                    "define": "initWithAction(${1:#cc.ActionInterval action},${2:#float speed})",
                    "detail": " Initializes the action. \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float speed})",
                    "detail": " Create the action and set the speed.\nparam action An action.\nparam speed The action speed.\n"
                },
                "setSpeed": {
                    "type": "method",
                    "define": "setSpeed(${1:#float speed})",
                    "detail": " Alter the speed of the inner function in runtime. \nparam speed Alter the speed of the inner function in runtime.\n"
                }
            },
            "PointLight": {
                "1": "new",
                "setRange": {
                    "type": "method",
                    "define": "setRange(${1:#float range})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#vec3_table position},${2:#color3b_table color},${3:#float range})",
                    "detail": "Creates a point light.\nparam position The light's position\nparam color The light's color.\nparam range The light's range.\nreturn The new point light.\n"
                },
                "getRange": {
                    "type": "method",
                    "define": "getRange()",
                    "detail": " get or set range \n"
                }
            },
            "Blink": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#int blinks})",
                    "detail": "Creates the action.\nparam duration Duration time, in seconds.\nparam blinks Blink times.\nreturn An autoreleased Blink object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#int blinks})",
                    "detail": "initializes the action \nparam duration in seconds\n"
                }
            },
            "Sprite3DMaterial": {
                "createWithFilename": {
                    "type": "method",
                    "define": "createWithFilename(${1:#string path})",
                    "detail": "Create material with file name, it creates material from cache if it is previously loaded\nparam path Path of material file\nreturn Created material\n"
                },
                "releaseBuiltInMaterial": {
                    "type": "method",
                    "define": "releaseBuiltInMaterial()",
                    "detail": "Release all built in materials\n"
                },
                "releaseCachedMaterial": {
                    "type": "method",
                    "define": "releaseCachedMaterial()",
                    "detail": "Release all cached materials\n"
                },
                "getMaterialType": {
                    "type": "method",
                    "define": "getMaterialType()",
                    "detail": "Get material type\nreturn Material type\n"
                },
                "createBuiltInMaterial": {
                    "type": "method",
                    "define": "createBuiltInMaterial(${1:#int type},${2:#bool skinned})",
                    "detail": "@overload self         \n@overload self, int, bool         \n"
                },
                "createWithGLStateProgram": {
                    "type": "method",
                    "define": "createWithGLStateProgram(${1:#cc.GLProgramState programState})",
                    "detail": "Create material with GLProgramState\nparam programState GLProgramState instance\nreturn Created material\n"
                }
            },
            "EventListenerFocus": {
                "1": "create",
                "2": "new",
                "3": "registerScriptHandler",
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "/ Overrides\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                }
            },
            "CCBAnimationManager": {
                "1": "new",
                "2": "setCallFuncForLuaCallbackNamed",
                "getDocumentCallbackNames": {
                    "type": "method",
                    "define": "getDocumentCallbackNames()"
                },
                "getContainerSize": {
                    "type": "method",
                    "define": "getContainerSize(${1:#cc.Node pNode})"
                },
                "actionForCallbackChannel": {
                    "type": "method",
                    "define": "actionForCallbackChannel(${1:#cc.CCBSequenceProperty channel})"
                },
                "getRootNode": {
                    "type": "method",
                    "define": "getRootNode()"
                },
                "addDocumentCallbackControlEvents": {
                    "type": "method",
                    "define": "addDocumentCallbackControlEvents(${1:#int eventType})"
                },
                "moveAnimationsFromNode": {
                    "type": "method",
                    "define": "moveAnimationsFromNode(${1:#cc.Node fromNode},${2:#cc.Node toNode})"
                },
                "addDocumentCallbackNode": {
                    "type": "method",
                    "define": "addDocumentCallbackNode(${1:#cc.Node node})"
                },
                "getDocumentCallbackControlEvents": {
                    "type": "method",
                    "define": "getDocumentCallbackControlEvents()"
                },
                "addDocumentOutletNode": {
                    "type": "method",
                    "define": "addDocumentOutletNode(${1:#cc.Node node})"
                },
                "getSequenceDuration": {
                    "type": "method",
                    "define": "getSequenceDuration(${1:#char pSequenceName})"
                },
                "setDocumentControllerName": {
                    "type": "method",
                    "define": "setDocumentControllerName(${1:#string name})"
                },
                "setBaseValue": {
                    "type": "method",
                    "define": "setBaseValue(${1:#cc.Value value},${2:#cc.Node pNode},${3:#string propName})"
                },
                "getAutoPlaySequenceId": {
                    "type": "method",
                    "define": "getAutoPlaySequenceId()"
                },
                "getSequences": {
                    "type": "method",
                    "define": "getSequences()"
                },
                "runAnimationsForSequenceIdTweenDuration": {
                    "type": "method",
                    "define": "runAnimationsForSequenceIdTweenDuration(${1:#int nSeqId},${2:#float fTweenDuraiton})"
                },
                "getDocumentOutletNodes": {
                    "type": "method",
                    "define": "getDocumentOutletNodes()"
                },
                "actionForSoundChannel": {
                    "type": "method",
                    "define": "actionForSoundChannel(${1:#cc.CCBSequenceProperty channel})"
                },
                "setRootContainerSize": {
                    "type": "method",
                    "define": "setRootContainerSize(${1:#size_table rootContainerSize})"
                },
                "getKeyframeCallbacks": {
                    "type": "method",
                    "define": "getKeyframeCallbacks()"
                },
                "runAnimationsForSequenceNamed": {
                    "type": "method",
                    "define": "runAnimationsForSequenceNamed(${1:#char pName})"
                },
                "setAutoPlaySequenceId": {
                    "type": "method",
                    "define": "setAutoPlaySequenceId(${1:#int autoPlaySequenceId})"
                },
                "getDocumentCallbackNodes": {
                    "type": "method",
                    "define": "getDocumentCallbackNodes()"
                },
                "setSequences": {
                    "type": "method",
                    "define": "setSequences(${1:#array_table seq})"
                },
                "setObject": {
                    "type": "method",
                    "define": "setObject(${1:#cc.Ref obj},${2:#cc.Node pNode},${3:#string propName})"
                },
                "runAnimationsForSequenceNamedTweenDuration": {
                    "type": "method",
                    "define": "runAnimationsForSequenceNamedTweenDuration(${1:#char pName},${2:#float fTweenDuration})"
                },
                "addDocumentCallbackName": {
                    "type": "method",
                    "define": "addDocumentCallbackName(${1:#string name})"
                },
                "getRunningSequenceName": {
                    "type": "method",
                    "define": "getRunningSequenceName()"
                },
                "setRootNode": {
                    "type": "method",
                    "define": "setRootNode(${1:#cc.Node pRootNode})"
                },
                "getDocumentControllerName": {
                    "type": "method",
                    "define": "getDocumentControllerName()"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "getSequenceId": {
                    "type": "method",
                    "define": "getSequenceId(${1:#char pSequenceName})"
                },
                "getLastCompletedSequenceName": {
                    "type": "method",
                    "define": "getLastCompletedSequenceName()"
                },
                "debug": {
                    "type": "method",
                    "define": "debug()"
                },
                "addDocumentOutletName": {
                    "type": "method",
                    "define": "addDocumentOutletName(${1:#string name})"
                },
                "getRootContainerSize": {
                    "type": "method",
                    "define": "getRootContainerSize()"
                },
                "getDocumentOutletNames": {
                    "type": "method",
                    "define": "getDocumentOutletNames()"
                }
            },
            "ParticleSystem3D": {
                "1": "getParticlePool",
                "2": "new",
                "removeAffector": {
                    "type": "method",
                    "define": "removeAffector(${1:#int index})",
                    "detail": "remove affector by index\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "override function\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool enabled})",
                    "detail": "Enables or disables the system.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "override function\n"
                },
                "resumeParticleSystem": {
                    "type": "method",
                    "define": "resumeParticleSystem()",
                    "detail": "resume particle\n"
                },
                "setKeepLocal": {
                    "type": "method",
                    "define": "setKeepLocal(${1:#bool keepLocal})"
                },
                "getAliveParticleCount": {
                    "type": "method",
                    "define": "getAliveParticleCount()",
                    "detail": "get alive particles count\n"
                },
                "pauseParticleSystem": {
                    "type": "method",
                    "define": "pauseParticleSystem()",
                    "detail": "pause particle\n"
                },
                "removeAllAffector": {
                    "type": "method",
                    "define": "removeAllAffector()",
                    "detail": "remove all particle affector\n"
                },
                "getRender": {
                    "type": "method",
                    "define": "getRender()",
                    "detail": "return particle render\n"
                },
                "stopParticleSystem": {
                    "type": "method",
                    "define": "stopParticleSystem()",
                    "detail": "stop particle\n"
                },
                "startParticleSystem": {
                    "type": "method",
                    "define": "startParticleSystem()",
                    "detail": "particle system play control\n"
                },
                "setRender": {
                    "type": "method",
                    "define": "setRender(${1:#cc.Particle3DRender render})",
                    "detail": "set particle render, can set your own particle render\n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()",
                    "detail": "is enabled\n"
                },
                "setParticleQuota": {
                    "type": "method",
                    "define": "setParticleQuota(${1:#unsigned int quota})",
                    "detail": "set particle quota\n"
                },
                "isKeepLocal": {
                    "type": "method",
                    "define": "isKeepLocal()"
                },
                "setEmitter": {
                    "type": "method",
                    "define": "setEmitter(${1:#cc.Particle3DEmitter emitter})",
                    "detail": "set emitter for particle system, can set your own particle emitter\n"
                },
                "getState": {
                    "type": "method",
                    "define": "getState()",
                    "detail": "get particle playing state\n"
                },
                "addAffector": {
                    "type": "method",
                    "define": "addAffector(${1:#cc.Particle3DAffector affector})",
                    "detail": "add particle affector\n"
                },
                "getParticleQuota": {
                    "type": "method",
                    "define": "getParticleQuota()",
                    "detail": "get particle quota\n"
                }
            },
            "LightType": [
                "AMBIENT",
                "DIRECTIONAL",
                "POINT",
                "SPOT"
            ],
            "Waves3D": {
                "1": "new",
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float amplitude})",
                    "detail": "brief Set the amplitude to the effect.\nparam amplitude The value of amplitude will be set.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of the effect.\nreturn Return the amplitude rate of the effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amplitudeRate})",
                    "detail": "brief Set the amplitude rate of the effect.\nparam amplitudeRate The value of amplitude rate will be set.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of the effect.\nreturn Return the amplitude of the effect.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude})",
                    "detail": "brief Initializes an action with duration, grid size, waves and amplitude.\nparam duration Specify the duration of the Waves3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the Waves3D action.\nparam amplitude Specify the amplitude of the Waves3D action.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude})",
                    "detail": "brief Create an action with duration, grid size, waves and amplitude.\nparam duration Specify the duration of the Waves3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the Waves3D action.\nparam amplitude Specify the amplitude of the Waves3D action.\nreturn If the creation success, return a pointer of Waves3D action; otherwise, return nil.\n"
                }
            },
            "ProgressTimer": {
                "1": "new",
                "getMidpoint": {
                    "type": "method",
                    "define": "getMidpoint()",
                    "detail": " Returns the Midpoint. \nreturn A Vec2.\n"
                },
                "getPercentage": {
                    "type": "method",
                    "define": "getPercentage()",
                    "detail": " Percentages are from 0 to 100.\nreturn Percentages.\n"
                },
                "getBarChangeRate": {
                    "type": "method",
                    "define": "getBarChangeRate()",
                    "detail": " Returns the BarChangeRate.\nreturn A barChangeRate.\n"
                },
                "setReverseDirection": {
                    "type": "method",
                    "define": "setReverseDirection(${1:#bool value})",
                    "detail": " Set the Reverse direction.\nparam value If value is false it will clockwise,if is true it will Anti-clockwise.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Sprite sp})",
                    "detail": " Creates a progress timer with the sprite as the shape the timer goes through.\nparam sp The sprite as the shape the timer goes through.\nreturn A ProgressTimer.\n"
                },
                "getType": {
                    "type": "method",
                    "define": "getType()",
                    "detail": " Change the percentage to change progress. \nreturn A Type\n"
                },
                "setBarChangeRate": {
                    "type": "method",
                    "define": "setBarChangeRate(${1:#vec2_table barChangeRate})",
                    "detail": "This allows the bar type to move the component at a specific rate.\nSet the component to 0 to make sure it stays at 100%.\nFor example you want a left to right bar but not have the height stay 100%.\nSet the rate to be Vec2(0,1); and set the midpoint to = Vec2(0,.5f).\nparam barChangeRate A Vec2.\n"
                },
                "setType": {
                    "type": "method",
                    "define": "setType(${1:#int type})",
                    "detail": " Set the ProgressTimer type. \nparam type Is an Type.\n"
                },
                "setSprite": {
                    "type": "method",
                    "define": "setSprite(${1:#cc.Sprite sprite})",
                    "detail": " Set the sprite as the shape. \nparam sprite The sprite as the shape.\n"
                },
                "setMidpoint": {
                    "type": "method",
                    "define": "setMidpoint(${1:#vec2_table point})",
                    "detail": "Midpoint is used to modify the progress start position.\nIf you're using radials type then the midpoint changes the center point.\nIf you're using bar type then the midpoint changes the bar growth.\nit expands from the center but clamps to the sprites edge so:\nyou want a left to right then set the midpoint all the way to Vec2(0,y).\nyou want a right to left then set the midpoint all the way to Vec2(1,y).\nyou want a bottom to top then set the midpoint all the way to Vec2(x,0).\nyou want a top to bottom then set the midpoint all the way to Vec2(x,1).\nparam point A Vec2 point.\n"
                },
                "initWithSprite": {
                    "type": "method",
                    "define": "initWithSprite(${1:#cc.Sprite sp})",
                    "detail": " Initializes a progress timer with the sprite as the shape the timer goes through \n"
                },
                "setPercentage": {
                    "type": "method",
                    "define": "setPercentage(${1:#float percentage})",
                    "detail": " Set the initial percentage values. \nparam percentage The initial percentage values.\n"
                },
                "getSprite": {
                    "type": "method",
                    "define": "getSprite()",
                    "detail": " The image to show the progress percentage, retain. \nreturn A sprite.\n"
                },
                "isReverseDirection": {
                    "type": "method",
                    "define": "isReverseDirection()",
                    "detail": " Return the Reverse direction.\nreturn If the direction is Anti-clockwise,it will return true.\n"
                }
            },
            "JumpTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#vec2_table position},${3:#float height},${4:#int jumps})",
                    "detail": "Creates the action.\nparam duration Duration time, in seconds.\nparam position The jumping destination position.\nparam height The jumping height.\nparam jumps The jumping times.\nreturn An autoreleased JumpTo object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#vec2_table position},${3:#float height},${4:#int jumps})",
                    "detail": "initializes the action\nparam duration In seconds.\n"
                }
            },
            "PolygonInfo": {
                "1": "collector",
                "2": "new",
                "setQuads": {
                    "type": "method",
                    "define": "setQuads(${1:#cc.V3F_C4B_T2F_Quad quads},${2:#int numberOfQuads})",
                    "detail": "set the data to be a pointer to a number of Quads\nthe member verts will not be released when this PolygonInfo destructs\nas the verts memory are managed by other objects\nparam quad  a pointer to the V3F_C4B_T2F_Quad quads\n"
                },
                "getFilename": {
                    "type": "method",
                    "define": "getFilename()"
                },
                "getRect": {
                    "type": "method",
                    "define": "getRect()"
                },
                "getArea": {
                    "type": "method",
                    "define": "getArea()",
                    "detail": "get sum of all triangle area size\nreturn sum of all triangle area size\n"
                },
                "setQuad": {
                    "type": "method",
                    "define": "setQuad(${1:#cc.V3F_C4B_T2F_Quad quad})",
                    "detail": "set the data to be a pointer to a quad\nthe member verts will not be released when this PolygonInfo destructs\nas the verts memory are managed by other objects\nparam quad  a pointer to the V3F_C4B_T2F_Quad object\n"
                },
                "getVertCount": {
                    "type": "method",
                    "define": "getVertCount()",
                    "detail": "get vertex count\nreturn number of vertices\n"
                },
                "setTriangles": {
                    "type": "method",
                    "define": "setTriangles(${1:#cc.TrianglesCommand::Triangles triangles})",
                    "detail": "set the data to be a pointer to a triangles\nthe member verts will not be released when this PolygonInfo destructs\nas the verts memory are managed by other objects\nparam triangles  a pointer to the TrianglesCommand::Triangles object\n"
                },
                "setRect": {
                    "type": "method",
                    "define": "setRect(${1:#rect_table rect})"
                },
                "getTrianglesCount": {
                    "type": "method",
                    "define": "getTrianglesCount()",
                    "detail": "get triangles count\nreturn number of triangles\n"
                },
                "setFilename": {
                    "type": "method",
                    "define": "setFilename(${1:#string filename})"
                }
            },
            "Follow": {
                "createWithOffset": {
                    "type": "method",
                    "define": "createWithOffset(${1:#cc.Node followedNode},${2:#float xOffset},${3:#float yOffset},${4:#rect_table rect})",
                    "detail": "Creates the action with a set boundary or with no boundary with offsets.\nparam followedNode  The node to be followed.\nparam rect  The boundary. If \\p rect is equal to Rect::ZERO, it'll work\nwith no boundary.\nparam xOffset The horizontal offset from the center of the screen from which the\nnode  is to be followed.It can be positive,negative or zero.If\nset to zero the node will be horizontally centered followed.\nparam yOffset The vertical offset from the center of the screen from which the\nnode is to be followed.It can be positive,negative or zero.\nIf set to zero the node will be vertically centered followed.\nIf both xOffset and yOffset are set to zero,then the node will be horizontally and vertically centered followed.\n"
                },
                "initWithTargetAndOffset": {
                    "type": "method",
                    "define": "initWithTargetAndOffset(${1:#cc.Node followedNode},${2:#float xOffset},${3:#float yOffset},${4:#rect_table rect})",
                    "detail": "Initializes the action with a set boundary or with no boundary with offsets.\nparam followedNode  The node to be followed.\nparam rect  The boundary. If \\p rect is equal to Rect::ZERO, it'll work\nwith no boundary.\nparam xOffset The horizontal offset from the center of the screen from which the\nnode  is to be followed.It can be positive,negative or zero.If\nset to zero the node will be horizontally centered followed.\nparam yOffset The vertical offset from the center of the screen from which the\nnode is to be followed.It can be positive,negative or zero.\nIf set to zero the node will be vertically centered followed.\nIf both xOffset and yOffset are set to zero,then the node will be horizontally and vertically centered followed.\n"
                },
                "setBoundarySet": {
                    "type": "method",
                    "define": "setBoundarySet(${1:#bool value})",
                    "detail": " Alter behavior - turn on/off boundary. \nparam value Turn on/off boundary.\n"
                },
                "isBoundarySet": {
                    "type": "method",
                    "define": "isBoundarySet()",
                    "detail": " Return boundarySet.\nreturn Return boundarySet.\n"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node followedNode},${2:#rect_table rect})",
                    "detail": "Creates the action with a set boundary or with no boundary.\nparam followedNode  The node to be followed.\nparam rect  The boundary. If \\p rect is equal to Rect::ZERO, it'll work\nwith no boundary.\n"
                },
                "initWithTarget": {
                    "type": "method",
                    "define": "initWithTarget(${1:#cc.Node followedNode},${2:#rect_table rect})",
                    "detail": "Initializes the action with a set boundary or with no boundary.\nparam followedNode  The node to be followed.\nparam rect  The boundary. If \\p rect is equal to Rect::ZERO, it'll work\nwith no boundary.\n"
                }
            },
            "326": "pIsSegmentIntersect",
            "ClippingNode": {
                "setAlphaThreshold": {
                    "type": "method",
                    "define": "setAlphaThreshold(${1:#float alphaThreshold})",
                    "detail": " Set the alpha threshold. \nparam alphaThreshold The alpha threshold.\n"
                },
                "isInverted": {
                    "type": "method",
                    "define": "isInverted()",
                    "detail": " Inverted. If this is set to true,\nthe stencil is inverted, so the content is drawn where the stencil is NOT drawn.\nThis default to false.\nreturn If the clippingNode is Inverted, it will be return true.\n"
                },
                "setStencil": {
                    "type": "method",
                    "define": "setStencil(${1:#cc.Node stencil})",
                    "detail": " Set the Node to use as a stencil to do the clipping.\nparam stencil The Node to use as a stencil to do the clipping.\n"
                },
                "hasContent": {
                    "type": "method",
                    "define": "hasContent()",
                    "detail": " If stencil has no children it will not be drawn.\nIf you have custom stencil-based node with stencil drawing mechanics other then children-based,\nthen this method should return true every time you wish stencil to be visited.\nBy default returns true if has any children attached.\nreturn If you have custom stencil-based node with stencil drawing mechanics other then children-based,\nthen this method should return true every time you wish stencil to be visited.\nBy default returns true if has any children attached.\njs NA\n"
                },
                "getAlphaThreshold": {
                    "type": "method",
                    "define": "getAlphaThreshold()",
                    "detail": " The alpha threshold.\nThe content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold.\nShould be a float between 0 and 1.\nThis default to 1 (so alpha test is disabled).\nreturn The alpha threshold value,Should be a float between 0 and 1.\n"
                },
                "getStencil": {
                    "type": "method",
                    "define": "getStencil()",
                    "detail": " The Node to use as a stencil to do the clipping.\nThe stencil node will be retained.\nThis default to nil.\nreturn The stencil node.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": " Initializes a clipping node without a stencil.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node stencil})",
                    "detail": "@overload self, cc.Node         \n@overload self         \n"
                },
                "setInverted": {
                    "type": "method",
                    "define": "setInverted(${1:#bool inverted})",
                    "detail": " Set the ClippingNode whether or not invert.\nparam inverted A bool Type,to set the ClippingNode whether or not invert.\n"
                }
            },
            "OBB": [
                "collector",
                "containPoint",
                "getCorners",
                "intersects",
                "new",
                "reset",
                "set",
                "transform"
            ],
            "322": "pGetDistance",
            "MenuItemSprite": {
                "1": "create",
                "2": "new",
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool bEnabled})",
                    "detail": " Enables or disables the item. \n"
                },
                "unselected": {
                    "type": "method",
                    "define": "unselected()",
                    "detail": " The item was unselected. \n"
                },
                "setSelectedImage": {
                    "type": "method",
                    "define": "setSelectedImage(${1:#cc.Node image})",
                    "detail": " Sets the image used when the item is selected. \n"
                },
                "getNormalImage": {
                    "type": "method",
                    "define": "getNormalImage()",
                    "detail": " Gets the image used when the item is not selected. \n"
                },
                "getDisabledImage": {
                    "type": "method",
                    "define": "getDisabledImage()",
                    "detail": " Gets the image used when the item is disabled. \n"
                },
                "selected": {
                    "type": "method",
                    "define": "selected()",
                    "detail": "The item was selected (not activated), similar to \"mouse-over\".\nsince v0.99.5\n"
                },
                "getSelectedImage": {
                    "type": "method",
                    "define": "getSelectedImage()",
                    "detail": " Gets the image used when the item is selected. \n"
                },
                "setNormalImage": {
                    "type": "method",
                    "define": "setNormalImage(${1:#cc.Node image})",
                    "detail": " Sets the image used when the item is not selected. \n"
                },
                "setDisabledImage": {
                    "type": "method",
                    "define": "setDisabledImage(${1:#cc.Node image})",
                    "detail": " Sets the image used when the item is disabled. \n"
                },
                "initWithNormalSprite": {
                    "type": "method",
                    "define": "initWithNormalSprite(${1:#cc.Node normalSprite},${2:#cc.Node selectedSprite},${3:#cc.Node disabledSprite},${4:#function callback})",
                    "detail": " Initializes a menu item with a normal, selected and disabled image with a callable object. \n"
                }
            },
            "Animate3D": {
                "1": "new",
                "setWeight": {
                    "type": "method",
                    "define": "setWeight(${1:#float weight})"
                },
                "removeFromMap": {
                    "type": "method",
                    "define": "removeFromMap()"
                },
                "setSpeed": {
                    "type": "method",
                    "define": "setSpeed(${1:#float speed})"
                },
                "getSpeed": {
                    "type": "method",
                    "define": "getSpeed()",
                    "detail": "get & set speed, negative speed means playing reverse \n"
                },
                "initWithFrames": {
                    "type": "method",
                    "define": "initWithFrames(${1:#cc.Animation3D animation},${2:#int startFrame},${3:#int endFrame},${4:#float frameRate})"
                },
                "getWeight": {
                    "type": "method",
                    "define": "getWeight()",
                    "detail": "get & set blend weight, weight must positive\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Animation3D animation},${2:#float fromTime},${3:#float duration})",
                    "detail": "@overload self, cc.Animation3D, float, float         \n@overload self, cc.Animation3D         \n"
                },
                "getOriginInterval": {
                    "type": "method",
                    "define": "getOriginInterval()"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#cc.Animation3D animation},${2:#float fromTime},${3:#float duration})",
                    "detail": "@overload self, cc.Animation3D, float, float         \n@overload self, cc.Animation3D         \n"
                },
                "getQuality": {
                    "type": "method",
                    "define": "getQuality()",
                    "detail": "get animate quality\n"
                },
                "setKeyFrameUserInfo": {
                    "type": "method",
                    "define": "setKeyFrameUserInfo(${1:#int keyFrame},${2:#map_table userInfo})"
                },
                "getTransitionTime": {
                    "type": "method",
                    "define": "getTransitionTime()",
                    "detail": " get animate transition time between 3d animations \n"
                },
                "setOriginInterval": {
                    "type": "method",
                    "define": "setOriginInterval(${1:#float interval})",
                    "detail": "get & set origin interval\n"
                },
                "setQuality": {
                    "type": "method",
                    "define": "setQuality(${1:#int quality})",
                    "detail": "set animate quality\n"
                },
                "createWithFrames": {
                    "type": "method",
                    "define": "createWithFrames(${1:#cc.Animation3D animation},${2:#int startFrame},${3:#int endFrame},${4:#float frameRate})",
                    "detail": "create Animate3D by frame section, [startFrame, endFrame)\nparam animation used to generate animate3D\nparam startFrame\nparam endFrame\nparam frameRate default is 30 per second\nreturn Animate3D created using animate\n"
                },
                "setTransitionTime": {
                    "type": "method",
                    "define": "setTransitionTime(${1:#float transTime})",
                    "detail": " set animate transition time between 3d animations \n"
                }
            },
            "334": "pRotate",
            "WHITE": [
                "b",
                "g",
                "r"
            ],
            "FadeTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#unsigned char opacity})",
                    "detail": "Creates an action with duration and opacity.\nparam duration Duration time, in seconds.\nparam opacity A certain opacity, the range is from 0 to 255.\nreturn An autoreleased FadeTo object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#unsigned char opacity})",
                    "detail": "initializes the action with duration and opacity \nparam duration in seconds\n"
                }
            },
            "330": "pMul",
            "TransitionSlideInL": {
                "1": "new",
                "action": {
                    "type": "method",
                    "define": "action()",
                    "detail": " Returns the action that will be performed by the incoming and outgoing scene.\nreturn The action that will be performed by the incoming and outgoing scene.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionSlideInL object.\n"
                },
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})"
                }
            },
            "328": "pLerp",
            "GLProgramState": {
                "getVertexAttribCount": {
                    "type": "method",
                    "define": "getVertexAttribCount()",
                    "detail": "Get the number of vertex attributes.\n"
                },
                "applyUniforms": {
                    "type": "method",
                    "define": "applyUniforms()",
                    "detail": "Apply user defined uniforms.\n"
                },
                "1": "setVertexAttribPointer",
                "setUniformVec4v": {
                    "type": "method",
                    "define": "setUniformVec4v(${1:#string uniformName},${2:#int size},${3:#vec4_table pointer})",
                    "detail": "@overload self, int, int, vec4_table         \n@overload self, string, int, vec4_table         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.GLProgram glprogram})",
                    "detail": " returns a new instance of GLProgramState for a given GLProgram \n"
                },
                "setUniformVec4": {
                    "type": "method",
                    "define": "setUniformVec4(${1:#string uniformName},${2:#vec4_table value})",
                    "detail": "@overload self, int, vec4_table         \n@overload self, string, vec4_table         \n"
                },
                "setGLProgram": {
                    "type": "method",
                    "define": "setGLProgram(${1:#cc.GLProgram glprogram})",
                    "detail": "@{ \nSetter and Getter of the owner GLProgram binded in this program state.\n"
                },
                "getOrCreateWithGLProgramName": {
                    "type": "method",
                    "define": "getOrCreateWithGLProgramName(${1:#string glProgramName},${2:#cc.Texture2D texture})",
                    "detail": "@overload self, string, cc.Texture2D         \n@overload self, string         \n"
                },
                "applyAutoBinding": {
                    "type": "method",
                    "define": "applyAutoBinding(${1:#string uniformName},${2:#string autoBinding})",
                    "detail": "Applies the specified custom auto-binding.\nparam uniformName Name of the shader uniform.\nparam autoBinding Name of the auto binding.\n"
                },
                "setUniformVec3v": {
                    "type": "method",
                    "define": "setUniformVec3v(${1:#string uniformName},${2:#int size},${3:#vec3_table pointer})",
                    "detail": "@overload self, int, int, vec3_table         \n@overload self, string, int, vec3_table         \n"
                },
                "setUniformInt": {
                    "type": "method",
                    "define": "setUniformInt(${1:#string uniformName},${2:#int value})",
                    "detail": "@overload self, int, int         \n@overload self, string, int         \n"
                },
                "getOrCreateWithShaders": {
                    "type": "method",
                    "define": "getOrCreateWithShaders(${1:#string vertexShader},${2:#string fragShader},${3:#string compileTimeDefines})",
                    "detail": " gets-or-creates an instance of GLProgramState for given shaders \n"
                },
                "setNodeBinding": {
                    "type": "method",
                    "define": "setNodeBinding(${1:#cc.Node node})",
                    "detail": "Sets the node that this render state is bound to.\nThe specified node is used to apply auto-bindings for the render state.\nThis is typically set to the node of the model that a material is\napplied to.\nparam node The node to use for applying auto-bindings.\n"
                },
                "setUniformVec2v": {
                    "type": "method",
                    "define": "setUniformVec2v(${1:#string uniformName},${2:#int size},${3:#vec2_table pointer})",
                    "detail": "@overload self, int, int, vec2_table         \n@overload self, string, int, vec2_table         \n"
                },
                "getOrCreateWithGLProgram": {
                    "type": "method",
                    "define": "getOrCreateWithGLProgram(${1:#cc.GLProgram glprogram})",
                    "detail": " gets-or-creates an instance of GLProgramState for a given GLProgram \n"
                },
                "setUniformMat4": {
                    "type": "method",
                    "define": "setUniformMat4(${1:#string uniformName},${2:#mat4_table value})",
                    "detail": "@overload self, int, mat4_table         \n@overload self, string, mat4_table         \n"
                },
                "applyGLProgram": {
                    "type": "method",
                    "define": "applyGLProgram(${1:#mat4_table modelView})",
                    "detail": "Apply GLProgram, and built in uniforms.\nparam modelView The applied modelView matrix to shader.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": " Returns a new copy of the GLProgramState. The GLProgram is reused \n"
                },
                "applyAttributes": {
                    "type": "method",
                    "define": "applyAttributes()",
                    "detail": "Apply attributes.\nparam applyAttribFlags Call GL::enableVertexAttribs(_vertexAttribsFlags) or not.\n"
                },
                "getNodeBinding": {
                    "type": "method",
                    "define": "getNodeBinding()",
                    "detail": "Returns the Node bound to the GLProgramState\n"
                },
                "setUniformTexture": {
                    "type": "method",
                    "define": "setUniformTexture(${1:#string uniformName},${2:#cc.Texture2D texture})",
                    "detail": "@overload self, int, cc.Texture2D         \n@overload self, string, cc.Texture2D         \n"
                },
                "setUniformVec2": {
                    "type": "method",
                    "define": "setUniformVec2(${1:#string uniformName},${2:#vec2_table value})",
                    "detail": "@overload self, int, vec2_table         \n@overload self, string, vec2_table         \n"
                },
                "apply": {
                    "type": "method",
                    "define": "apply(${1:#mat4_table modelView})",
                    "detail": "Apply GLProgram, attributes and uniforms.\nparam modelView The applied modelView matrix to shader.\n"
                },
                "setUniformFloat": {
                    "type": "method",
                    "define": "setUniformFloat(${1:#string uniformName},${2:#float value})",
                    "detail": "@overload self, int, float         \n@overload self, string, float         \n"
                },
                "getUniformCount": {
                    "type": "method",
                    "define": "getUniformCount()",
                    "detail": "Get the number of user defined uniform count.\n"
                },
                "setParameterAutoBinding": {
                    "type": "method",
                    "define": "setParameterAutoBinding(${1:#string uniformName},${2:#string autoBinding})",
                    "detail": "Sets a uniform auto-binding.\nThis method parses the passed in autoBinding string and attempts to convert it\nto an enumeration value. If it matches to one of the predefined strings, it will create a\ncallback to get the correct value at runtime.\nparam uniformName The name of the material parameter to store an auto-binding for.\nparam autoBinding A string matching one of the built-in AutoBinding enum constants.\n"
                },
                "getGLProgram": {
                    "type": "method",
                    "define": "getGLProgram()"
                },
                "setUniformVec3": {
                    "type": "method",
                    "define": "setUniformVec3(${1:#string uniformName},${2:#vec3_table value})",
                    "detail": "@overload self, int, vec3_table         \n@overload self, string, vec3_table         \n"
                },
                "setUniformFloatv": {
                    "type": "method",
                    "define": "setUniformFloatv(${1:#string uniformName},${2:#int size},${3:#float pointer})",
                    "detail": "@overload self, int, int, float         \n@overload self, string, int, float         \n"
                },
                "getVertexAttribsFlags": {
                    "type": "method",
                    "define": "getVertexAttribsFlags()",
                    "detail": " Get the flag of vertex attribs used by OR operation.\n"
                }
            },
            "Ref": {
                "release": {
                    "type": "method",
                    "define": "release()",
                    "detail": "Releases the ownership immediately.\nThis decrements the Ref's reference count.\nIf the reference count reaches 0 after the decrement, this Ref is\ndestructed.\nsee retain, autorelease\njs NA\n"
                },
                "retain": {
                    "type": "method",
                    "define": "retain()",
                    "detail": "Retains the ownership.\nThis increases the Ref's reference count.\nsee release, autorelease\njs NA\n"
                },
                "getReferenceCount": {
                    "type": "method",
                    "define": "getReferenceCount()",
                    "detail": "Returns the Ref's current reference count.\nreturns The Ref's reference count.\njs NA\n"
                }
            },
            "340": "quaternion_createFromAxisAngle",
            "338": "pUnrotate",
            "336": "pSub",
            "Liquid": {
                "1": "new",
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float amplitude})",
                    "detail": "brief Set the amplitude to the effect.\nparam amplitude The value of amplitude will be set.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of the effect.\nreturn Return the amplitude rate of the effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amplitudeRate})",
                    "detail": "brief Set the amplitude rate of the effect.\nparam amplitudeRate The value of amplitude rate will be set.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of the effect.\nreturn Return the amplitude of the effect.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude})",
                    "detail": "brief Initializes the action with amplitude, grid size, waves count and duration.\nparam duration Specify the duration of the Liquid action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the Liquid action.\nparam amplitude Specify the amplitude of the Liquid action.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude})",
                    "detail": "brief Create the action with amplitude, grid size, waves count and duration.\nparam duration Specify the duration of the Liquid action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the Liquid action.\nparam amplitude Specify the amplitude of the Liquid action.\nreturn If the creation success, return a pointer of Liquid action; otherwise, return nil.\n"
                }
            },
            "350": "rectIntersection",
            "348": "rectGetMinX",
            "MotionStreak": {
                "1": "new",
                "reset": {
                    "type": "method",
                    "define": "reset()",
                    "detail": " Remove all living segments of the ribbon.\n"
                },
                "isStartingPositionInitialized": {
                    "type": "method",
                    "define": "isStartingPositionInitialized()",
                    "detail": " Is the starting position initialized or not.\nreturn True if the starting position is initialized.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "js NA\nlua NA\n"
                },
                "initWithFade": {
                    "type": "method",
                    "define": "initWithFade(${1:#float fade},${2:#float minSeg},${3:#float stroke},${4:#color3b_table color},${5:#string path})",
                    "detail": "@overload self, float, float, float, color3b_table, cc.Texture2D         \n@overload self, float, float, float, color3b_table, string         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float timeToFade},${2:#float minSeg},${3:#float strokeWidth},${4:#color3b_table strokeColor},${5:#string imagePath})",
                    "detail": "@overload self, float, float, float, color3b_table, cc.Texture2D         \n@overload self, float, float, float, color3b_table, string         \n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "js NA\nlua NA\n"
                },
                "getStroke": {
                    "type": "method",
                    "define": "getStroke()",
                    "detail": " Get stroke.\nreturn float stroke.\n"
                },
                "tintWithColor": {
                    "type": "method",
                    "define": "tintWithColor(${1:#color3b_table colors})",
                    "detail": " Color used for the tint.\nparam colors The color used for the tint.\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})"
                },
                "setStroke": {
                    "type": "method",
                    "define": "setStroke(${1:#float stroke})",
                    "detail": " Set stroke.\nparam stroke The width of stroke.\n"
                },
                "setStartingPositionInitialized": {
                    "type": "method",
                    "define": "setStartingPositionInitialized(${1:#bool bStartingPositionInitialized})",
                    "detail": " Sets the starting position initialized or not.\nparam bStartingPositionInitialized True if initialized the starting position.\n"
                },
                "isFastMode": {
                    "type": "method",
                    "define": "isFastMode()",
                    "detail": " When fast mode is enabled, new points are added faster but with lower precision. \nreturn True if fast mode is enabled.\n"
                },
                "setFastMode": {
                    "type": "method",
                    "define": "setFastMode(${1:#bool bFastMode})",
                    "detail": " Sets fast mode or not.\nparam bFastMode True if enabled fast mode.\n"
                }
            },
            "346": "rectGetMidX",
            "LayerMultiplex": {
                "1": "create",
                "2": "new",
                "addLayer": {
                    "type": "method",
                    "define": "addLayer(${1:#cc.Layer layer})",
                    "detail": " Add a certain layer to LayerMultiplex.\nparam layer A layer need to be added to the LayerMultiplex.\n"
                },
                "initWithArray": {
                    "type": "method",
                    "define": "initWithArray(${1:#array_table arrayOfLayers})",
                    "detail": " initializes a MultiplexLayer with an array of layers\nsince v2.1\n"
                },
                "switchToAndReleaseMe": {
                    "type": "method",
                    "define": "switchToAndReleaseMe(${1:#int n})",
                    "detail": " release the current layer and switches to another layer indexed by n.\nThe current (old) layer will be removed from it's parent with 'cleanup=true'.\nparam n The layer indexed by n will display.\n"
                },
                "switchTo": {
                    "type": "method",
                    "define": "switchTo(${1:#int n})",
                    "detail": " Switches to a certain layer indexed by n.\nThe current (old) layer will be removed from it's parent with 'cleanup=true'.\nparam n The layer indexed by n will display.\n"
                }
            },
            "Menu": {
                "1": "alignItemsInColumns",
                "2": "alignItemsInRows",
                "3": "create",
                "4": "new",
                "initWithArray": {
                    "type": "method",
                    "define": "initWithArray(${1:#array_table arrayOfItems})",
                    "detail": " initializes a Menu with a NSArray of MenuItem objects \n"
                },
                "alignItemsHorizontally": {
                    "type": "method",
                    "define": "alignItemsHorizontally()",
                    "detail": " Align items horizontally. \n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()",
                    "detail": "Determines if the menu is enabled.\nsee `setEnabled(bool)`.\nreturn whether the menu is enabled or not.\n"
                },
                "alignItemsVertically": {
                    "type": "method",
                    "define": "alignItemsVertically()",
                    "detail": " Align items vertically. \n"
                },
                "alignItemsVerticallyWithPadding": {
                    "type": "method",
                    "define": "alignItemsVerticallyWithPadding(${1:#float padding})",
                    "detail": " Align items vertically with padding.\nsince v0.7.2\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool value})",
                    "detail": "Set whether the menu is visible. If set false, interacting with the menu\nwill have no effect.\nThe default value is true, a menu is default to visible.\nparam value true if menu is to be enabled, false if menu is to be disabled.\n"
                },
                "alignItemsHorizontallyWithPadding": {
                    "type": "method",
                    "define": "alignItemsHorizontallyWithPadding(${1:#float padding})",
                    "detail": " Align items horizontally with padding.\nsince v0.7.2\n"
                }
            },
            "Shaky3D": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float initWithDuration},${2:#size_table gridSize},${3:#int range},${4:#bool shakeZ})",
                    "detail": "brief Create the action with a range, shake Z vertices, a grid and duration.\nparam initWithDuration Specify the duration of the Shaky3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam range Specify the range of the shaky effect.\nparam shakeZ Specify whether shake on the z axis.\nreturn If the creation success, return a pointer of Shaky3D action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#int range},${4:#bool shakeZ})",
                    "detail": "brief Initializes the action with a range, shake Z vertices, grid size and duration.\nparam duration Specify the duration of the Shaky3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam range Specify the range of the shaky effect.\nparam shakeZ Specify whether shake on the z axis.\nreturn If the Initialization success, return true; otherwise, return false.\n"
                }
            },
            "utils": [
                "captureScreen",
                "findChildren"
            ],
            "356": "vec3",
            "BezierTo": {
                "1": "create",
                "2": "new",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#cc._ccBezierConfig c})",
                    "detail": "param t In seconds.\n"
                }
            },
            "352": "rectUnion",
            "354": "tex2F",
            "ParticleData": {
                "1": "new",
                "release": {
                    "type": "method",
                    "define": "release()"
                },
                "copyParticle": {
                    "type": "method",
                    "define": "copyParticle(${1:#int p1},${2:#int p2})"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#int count})"
                },
                "getMaxCount": {
                    "type": "method",
                    "define": "getMaxCount()"
                }
            },
            "Place": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#vec2_table pos})",
                    "detail": " Creates a Place action with a position.\nparam pos  A certain position.\nreturn  An autoreleased Place object.\n"
                },
                "initWithPosition": {
                    "type": "method",
                    "define": "initWithPosition(${1:#vec2_table pos})",
                    "detail": " Initializes a Place action with a position \n"
                }
            },
            "PHYSICSSHAPE_MATERIAL_DEFAULT": [
                "density",
                "friction",
                "restitution"
            ],
            "360": "vec3normalize",
            "LabelAtlas": {
                "1": "_create",
                "2": "new",
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string label})"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()"
                },
                "initWithString": {
                    "type": "method",
                    "define": "initWithString(${1:#string string},${2:#cc.Texture2D texture},${3:#int itemWidth},${4:#int itemHeight},${5:#int startCharMap})",
                    "detail": "@overload self, string, string         \n@overload self, string, string, int, int, int         \n@overload self, string, cc.Texture2D, int, int, int         \n"
                }
            },
            "362": "vec4",
            "FadeIn": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float d})",
                    "detail": "Creates the action.\nparam d Duration time, in seconds.\nreturn An autoreleased FadeIn object.\n"
                },
                "setReverseAction": {
                    "type": "method",
                    "define": "setReverseAction(${1:#cc.FadeTo ac})",
                    "detail": "js NA\n"
                }
            },
            "Animate": {
                "1": "new",
                "initWithAnimation": {
                    "type": "method",
                    "define": "initWithAnimation(${1:#cc.Animation animation})",
                    "detail": " initializes the action with an Animation and will restore the original frame when the animation is over \n"
                },
                "getCurrentFrameIndex": {
                    "type": "method",
                    "define": "getCurrentFrameIndex()",
                    "detail": "Gets the index of sprite frame currently displayed.\nreturn int  the index of sprite frame currently displayed.\n"
                },
                "setAnimation": {
                    "type": "method",
                    "define": "setAnimation(${1:#cc.Animation animation})",
                    "detail": " Sets the Animation object to be animated \nparam animation certain animation.\n"
                },
                "getAnimation": {
                    "type": "method",
                    "define": "getAnimation()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Animation animation})",
                    "detail": " Creates the action with an Animation and will restore the original frame when the animation is over.\nparam animation A certain animation.\nreturn An autoreleased Animate object.\n"
                }
            },
            "TransitionRotoZoom": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionRotoZoom object.\n"
                },
                "1": "new"
            },
            "TargetedAction": {
                "1": "new",
                "setForcedTarget": {
                    "type": "method",
                    "define": "setForcedTarget(${1:#cc.Node forcedTarget})",
                    "detail": " Sets the target that the action will be forced to run with.\nparam forcedTarget The target that the action will be forced to run with.\n"
                },
                "getForcedTarget": {
                    "type": "method",
                    "define": "getForcedTarget()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "initWithTarget": {
                    "type": "method",
                    "define": "initWithTarget(${1:#cc.Node target},${2:#cc.FiniteTimeAction action})",
                    "detail": " Init an action with the specified action and forced target \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node target},${2:#cc.FiniteTimeAction action})",
                    "detail": " Create an action with the specified action and forced target.\nparam target The target needs to override.\nparam action The action needs to override.\nreturn An autoreleased TargetedAction object.\n"
                }
            },
            "MATRIX_STACK_TYPE": [
                "MODELVIEW",
                "PROJECTION",
                "TEXTURE"
            ],
            "TableView": {
                "1": "create",
                "2": "new",
                "3": "registerScriptHandler",
                "4": "setDataSource",
                "5": "setDelegate",
                "getVerticalFillOrder": {
                    "type": "method",
                    "define": "getVerticalFillOrder()"
                },
                "dequeueCell": {
                    "type": "method",
                    "define": "dequeueCell()",
                    "detail": "Dequeues a free cell if available. nil if not.\nreturn free cell\n"
                },
                "cellAtIndex": {
                    "type": "method",
                    "define": "cellAtIndex(${1:#int idx})",
                    "detail": "Returns an existing cell at a given index. Returns nil if a cell is nonexistent at the moment of query.\nparam idx index\nreturn a cell at a given index\n"
                },
                "reloadData": {
                    "type": "method",
                    "define": "reloadData()",
                    "detail": "reloads data from data source.  the view will be refreshed.\n"
                },
                "initWithViewSize": {
                    "type": "method",
                    "define": "initWithViewSize(${1:#size_table size},${2:#cc.Node container})"
                },
                "6": "unregisterScriptHandler",
                "updateCellAtIndex": {
                    "type": "method",
                    "define": "updateCellAtIndex(${1:#int idx})",
                    "detail": "Updates the content of the cell at a given index.\nparam idx index to find a cell\n"
                },
                "scrollViewDidZoom": {
                    "type": "method",
                    "define": "scrollViewDidZoom(${1:#cc.ScrollView view})"
                },
                "removeCellAtIndex": {
                    "type": "method",
                    "define": "removeCellAtIndex(${1:#int idx})",
                    "detail": "Removes a cell at a given index\nparam idx index to find a cell\n"
                },
                "scrollViewDidScroll": {
                    "type": "method",
                    "define": "scrollViewDidScroll(${1:#cc.ScrollView view})"
                },
                "insertCellAtIndex": {
                    "type": "method",
                    "define": "insertCellAtIndex(${1:#int idx})",
                    "detail": "Inserts a new cell at a given index\nparam idx location to insert\n"
                },
                "_updateContentSize": {
                    "type": "method",
                    "define": "_updateContentSize()"
                },
                "setVerticalFillOrder": {
                    "type": "method",
                    "define": "setVerticalFillOrder(${1:#int order})",
                    "detail": "determines how cell is ordered and filled in the view.\n"
                }
            },
            "Device": {
                "getDPI": {
                    "type": "method",
                    "define": "getDPI()",
                    "detail": "Gets the DPI of device\nreturn The DPI of device.\n"
                },
                "setAccelerometerInterval": {
                    "type": "method",
                    "define": "setAccelerometerInterval(${1:#float interval})",
                    "detail": "Sets the interval of accelerometer.\n"
                },
                "setKeepScreenOn": {
                    "type": "method",
                    "define": "setKeepScreenOn(${1:#bool keepScreenOn})",
                    "detail": "Controls whether the screen should remain on.\nparam keepScreenOn One flag indicating that the screen should remain on.\n"
                },
                "vibrate": {
                    "type": "method",
                    "define": "vibrate(${1:#float duration})",
                    "detail": "Vibrate for the specified amount of time.\nIf vibrate is not supported, then invoking this method has no effect.\nSome platforms limit to a maximum duration of 5 seconds.\nDuration is ignored on iOS due to API limitations.\nparam duration The duration in seconds.\n"
                },
                "setAccelerometerEnabled": {
                    "type": "method",
                    "define": "setAccelerometerEnabled(${1:#bool isEnabled})",
                    "detail": "To enable or disable accelerometer.\n"
                }
            },
            "MoveTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#vec2_table position})",
                    "detail": "@overload self, float, vec3_table         \n@overload self, float, vec2_table         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#vec2_table position})",
                    "detail": "@overload self, float, vec3_table         \n@overload self, float, vec2_table         \n"
                }
            },
            "SplitCols": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#unsigned int cols})",
                    "detail": "brief Create the action with the number of columns and the duration.\nparam duration Specify the duration of the SplitCols action. It's a value in seconds.\nparam cols Specify the columns count should be split.\nreturn If the creation success, return a pointer of SplitCols action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#unsigned int cols})",
                    "detail": "brief Initializes the action with the number columns and the duration.\nparam duration Specify the duration of the SplitCols action. It's a value in seconds.\nparam cols Specify the columns count should be split.\nreturn If the creation success, return true; otherwise, return false.\n"
                }
            },
            "GLView": {
                "1": "endToLua",
                "2": "getAllTouches",
                "getResolutionPolicy": {
                    "type": "method",
                    "define": "getResolutionPolicy()",
                    "detail": " Returns the current Resolution policy.\nreturn The current Resolution policy.\n"
                },
                "setScissorInPoints": {
                    "type": "method",
                    "define": "setScissorInPoints(${1:#float x},${2:#float y},${3:#float w},${4:#float h})",
                    "detail": "Set Scissor rectangle with points.\nparam x Set the points of x.\nparam y Set the points of y.\nparam w Set the width of  the view port\nparam h Set the Height of the view port.\n"
                },
                "getScissorRect": {
                    "type": "method",
                    "define": "getScissorRect()",
                    "detail": "Get the current scissor rectangle.\nreturn The current scissor rectangle.\n"
                },
                "getViewPortRect": {
                    "type": "method",
                    "define": "getViewPortRect()",
                    "detail": "Get the opengl view port rectangle.\nreturn Return the opengl view port rectangle.\n"
                },
                "getRetinaFactor": {
                    "type": "method",
                    "define": "getRetinaFactor()",
                    "detail": " Get retina factor.\nreturn The retina factor.\n"
                },
                "swapBuffers": {
                    "type": "method",
                    "define": "swapBuffers()",
                    "detail": " Exchanges the front and back buffers, subclass must implement this method. \n"
                },
                "setViewName": {
                    "type": "method",
                    "define": "setViewName(${1:#string viewname})",
                    "detail": " Set the view name. \nparam viewname A string will be set to the view as name.\n"
                },
                "setViewPortInPoints": {
                    "type": "method",
                    "define": "setViewPortInPoints(${1:#float x},${2:#float y},${3:#float w},${4:#float h})",
                    "detail": "Set opengl view port rectangle with points.\nparam x Set the points of x.\nparam y Set the points of y.\nparam w Set the width of  the view port\nparam h Set the Height of the view port.\n"
                },
                "getScaleY": {
                    "type": "method",
                    "define": "getScaleY()",
                    "detail": "Get scale factor of the vertical direction.\nreturn Scale factor of the vertical direction.\n"
                },
                "isRetinaDisplay": {
                    "type": "method",
                    "define": "isRetinaDisplay()",
                    "detail": " Returns whether or not the view is in Retina Display mode.\nreturn Returns whether or not the view is in Retina Display mode.\n"
                },
                "setDesignResolutionSize": {
                    "type": "method",
                    "define": "setDesignResolutionSize(${1:#float width},${2:#float height},${3:#int resolutionPolicy})",
                    "detail": "Set the design resolution size.\nparam width Design resolution width.\nparam height Design resolution height.\nparam resolutionPolicy The resolution policy desired, you may choose:\n[1] EXACT_FIT Fill screen by stretch-to-fit: if the design resolution ratio of width to height is different from the screen resolution ratio, your game view will be stretched.\n[2] NO_BORDER Full screen without black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two areas of your game view will be cut.\n[3] SHOW_ALL  Full screen with black border: if the design resolution ratio of width to height is different from the screen resolution ratio, two black borders will be shown.\n"
                },
                "setFrameSize": {
                    "type": "method",
                    "define": "setFrameSize(${1:#float width},${2:#float height})",
                    "detail": "Set the frame size of EGL view.\nparam width The width of the fram size.\nparam height The height of the fram size.\n"
                },
                "setContentScaleFactor": {
                    "type": "method",
                    "define": "setContentScaleFactor(${1:#float})",
                    "detail": " Only works on ios platform. Set Content Scale of the Factor. \n"
                },
                "windowShouldClose": {
                    "type": "method",
                    "define": "windowShouldClose()",
                    "detail": " When the window is closed, it will return false if the platforms is Ios or Android.\nIf the platforms is windows or Mac,it will return true.\nreturn In ios and android it will return false,if in windows or Mac it will return true.\n"
                },
                "isScissorEnabled": {
                    "type": "method",
                    "define": "isScissorEnabled()",
                    "detail": "Get whether GL_SCISSOR_TEST is enable.\nreturn Whether GL_SCISSOR_TEST is enable.\n"
                },
                "setFrameZoomFactor": {
                    "type": "method",
                    "define": "setFrameZoomFactor(${1:#float})",
                    "detail": " Set zoom factor for frame. This methods are for\ndebugging big resolution (e.g.new ipad) app on desktop.\nparam zoomFactor The zoom factor for frame.\n"
                },
                "getViewName": {
                    "type": "method",
                    "define": "getViewName()",
                    "detail": " Get the view name.\nreturn The view name.\n"
                },
                "getFrameZoomFactor": {
                    "type": "method",
                    "define": "getFrameZoomFactor()",
                    "detail": " Get zoom factor for frame. This methods are for\ndebugging big resolution (e.g.new ipad) app on desktop.\nreturn The zoom factor for frame.\n"
                },
                "getGLContextAttrs": {
                    "type": "method",
                    "define": "getGLContextAttrs()",
                    "detail": " Return the OpenGL context attrs. \nreturn Return the OpenGL context attrs.\n"
                },
                "setGLContextAttrs": {
                    "type": "method",
                    "define": "setGLContextAttrs(${1:#GLContextAttrs glContextAttrs})",
                    "detail": " Static method and member so that we can modify it on all platforms before create OpenGL context. \nparam glContextAttrs The OpenGL context attrs.\n"
                },
                "getContentScaleFactor": {
                    "type": "method",
                    "define": "getContentScaleFactor()",
                    "detail": " Only works on ios platform. Get Content Scale of the Factor. \n"
                },
                "getVisibleSize": {
                    "type": "method",
                    "define": "getVisibleSize()",
                    "detail": "Get the visible area size of opengl viewport.\nreturn The visible area size of opengl viewport.\n"
                },
                "getScaleX": {
                    "type": "method",
                    "define": "getScaleX()",
                    "detail": "Get scale factor of the horizontal direction.\nreturn Scale factor of the horizontal direction.\n"
                },
                "getVisibleRect": {
                    "type": "method",
                    "define": "getVisibleRect()",
                    "detail": "Get the visible rectangle of opengl viewport.\nreturn The visible rectangle of opengl viewport.\n"
                },
                "renderScene": {
                    "type": "method",
                    "define": "renderScene(${1:#cc.Scene scene},${2:#cc.Renderer renderer})",
                    "detail": "Renders a Scene with a Renderer\nThis method is called directly by the Director\n"
                },
                "getVR": {
                    "type": "method",
                    "define": "getVR()"
                },
                "setVR": {
                    "type": "method",
                    "define": "setVR(${1:#cc.VRIRenderer vrrenderer})",
                    "detail": "Sets a VR renderer. \nif `vrrenderer` is `nullptr` VR will be disabled\n"
                },
                "getFrameSize": {
                    "type": "method",
                    "define": "getFrameSize()",
                    "detail": "Get the frame size of EGL view.\nIn general, it returns the screen size since the EGL view is a fullscreen view.\nreturn The frame size of EGL view.\n"
                },
                "getVisibleOrigin": {
                    "type": "method",
                    "define": "getVisibleOrigin()",
                    "detail": "Get the visible origin point of opengl viewport.\nreturn The visible origin point of opengl viewport.\n"
                },
                "pollEvents": {
                    "type": "method",
                    "define": "pollEvents()",
                    "detail": " Polls the events. \n"
                },
                "isOpenGLReady": {
                    "type": "method",
                    "define": "isOpenGLReady()",
                    "detail": " Get whether opengl render system is ready, subclass must implement this method. \n"
                },
                "getDesignResolutionSize": {
                    "type": "method",
                    "define": "getDesignResolutionSize()",
                    "detail": " Get design resolution size.\nDefault resolution size is the same as 'getFrameSize'.\nreturn The design resolution size.\n"
                },
                "setCursorVisible": {
                    "type": "method",
                    "define": "setCursorVisible(${1:#bool})",
                    "detail": "Hide or Show the mouse cursor if there is one.\nparam isVisible Hide or Show the mouse cursor if there is one.\n"
                },
                "setIMEKeyboardState": {
                    "type": "method",
                    "define": "setIMEKeyboardState(${1:#bool open})",
                    "detail": " Open or close IME keyboard , subclass must implement this method. \nparam open Open or close IME keyboard.\n"
                }
            },
            "264": "UNIFORM_SIN_TIME",
            "266": "UNIFORM_TIME",
            "268": "USE_L_A88_LABELS",
            "270": "V2F_C4B_T2F_Quad",
            "258": "UNIFORM_P_MATRIX",
            "260": "UNIFORM_RANDOM01",
            "Grid3D": {
                "1": "new",
                "setNeedDepthTestForBlit": {
                    "type": "method",
                    "define": "setNeedDepthTestForBlit(${1:#bool neededDepthTest})",
                    "detail": "@{\nGetter and Setter for depth test state when blit.\njs NA\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table gridSize},${2:#cc.Texture2D texture},${3:#bool flipped},${4:#rect_table rect})",
                    "detail": "@overload self, size_table, rect_table         \n@overload self, size_table         \n@overload self, size_table, cc.Texture2D, bool         \n@overload self, size_table, cc.Texture2D, bool, rect_table         \n"
                },
                "getNeedDepthTestForBlit": {
                    "type": "method",
                    "define": "getNeedDepthTestForBlit()"
                }
            },
            "262": "UNIFORM_SAMPLER",
            "TMXTiledMap": {
                "1": "getLayerNum",
                "2": "getResourceFile",
                "3": "initWithTMXFile",
                "4": "initWithXML",
                "5": "new",
                "getLayer": {
                    "type": "method",
                    "define": "getLayer(${1:#string layerName})",
                    "detail": " Return the FastTMXLayer for the specific layer. \nreturn Return the FastTMXLayer for the specific layer.\n"
                },
                "setTileSize": {
                    "type": "method",
                    "define": "setTileSize(${1:#size_table tileSize})",
                    "detail": " Set the tiles's size property measured in pixels. \nparam tileSize The tiles's size property measured in pixels.\n"
                },
                "setMapOrientation": {
                    "type": "method",
                    "define": "setMapOrientation(${1:#int mapOrientation})",
                    "detail": " Set map orientation. \nparam mapOrientation The map orientation.\n"
                },
                "getProperty": {
                    "type": "method",
                    "define": "getProperty(${1:#string propertyName})",
                    "detail": " Return the value for the specific property name.\nreturn Return the value for the specific property name.\n"
                },
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})",
                    "detail": " Set properties. \nparam properties An ValueMap Properties.\n"
                },
                "setObjectGroups": {
                    "type": "method",
                    "define": "setObjectGroups(${1:#array_table groups})",
                    "detail": " Set object groups. \nparam groups An object groups.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string tmxFile})",
                    "detail": " Creates a TMX Tiled Map with a TMX file.\nreturn An autorelease object.\n"
                },
                "getObjectGroup": {
                    "type": "method",
                    "define": "getObjectGroup(${1:#string groupName})",
                    "detail": " Return the TMXObjectGroup for the specific group. \nreturn Return the TMXObjectGroup for the specific group.\n"
                },
                "getObjectGroups": {
                    "type": "method",
                    "define": "getObjectGroups()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "createWithXML": {
                    "type": "method",
                    "define": "createWithXML(${1:#string tmxString},${2:#string resourcePath})",
                    "detail": " Initializes a TMX Tiled Map with a TMX formatted XML string and a path to TMX resources. \nparam tmxString A TMX formatted XML string.\nparam resourcePath A path to TMX resources.\nreturn An autorelease object.\n"
                },
                "getPropertiesForGID": {
                    "type": "method",
                    "define": "getPropertiesForGID(${1:#int GID})",
                    "detail": " Return properties dictionary for tile GID.\nreturn Return properties dictionary for tile GID.\n"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()",
                    "detail": " Get properties.\nreturn Properties.\n"
                },
                "setMapSize": {
                    "type": "method",
                    "define": "setMapSize(${1:#size_table mapSize})",
                    "detail": " Set the map's size property measured in tiles.\nparam mapSize The map's size property measured in tiles.\n"
                },
                "getMapSize": {
                    "type": "method",
                    "define": "getMapSize()",
                    "detail": " The map's size property measured in tiles. \nreturn The map's size property measured in tiles.\n"
                },
                "getMapOrientation": {
                    "type": "method",
                    "define": "getMapOrientation()",
                    "detail": " Get map orientation. \nreturn The map orientation.\n"
                },
                "getTileSize": {
                    "type": "method",
                    "define": "getTileSize()",
                    "detail": " The tiles's size property measured in pixels.\nreturn The tiles's size property measured in pixels.\n"
                }
            },
            "TransitionSceneOriented": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene},${3:#int orientation})",
                    "detail": " Creates a transition with duration, incoming scene and orientation.\nparam t Duration time, in seconds.\nparam scene A given scene.\nparam orientation A given orientation: LeftOver, RightOver, UpOver, DownOver.\nreturn A autoreleased TransitionSceneOriented object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#cc.Scene scene},${3:#int orientation})",
                    "detail": " initializes a transition with duration and incoming scene \n"
                }
            },
            "Terrain": {
                "1": "create",
                "2": "getHeight",
                "3": "new",
                "getTerrainSize": {
                    "type": "method",
                    "define": "getTerrainSize()",
                    "detail": "get the terrain's size\n"
                },
                "initProperties": {
                    "type": "method",
                    "define": "initProperties()",
                    "detail": "initialize all Properties which terrain need \n"
                },
                "convertToTerrainSpace": {
                    "type": "method",
                    "define": "convertToTerrainSpace(${1:#vec2_table worldSpace})",
                    "detail": "Convert a world Space position (X,Z) to terrain space position (X,Z)\n"
                },
                "resetHeightMap": {
                    "type": "method",
                    "define": "resetHeightMap(${1:#string heightMap})",
                    "detail": "reset the heightmap data.\n"
                },
                "initWithTerrainData": {
                    "type": "method",
                    "define": "initWithTerrainData(${1:#cc.Terrain::TerrainData parameter},${2:#int fixedType})"
                },
                "setMaxDetailMapAmount": {
                    "type": "method",
                    "define": "setMaxDetailMapAmount(${1:#int maxValue})",
                    "detail": "set the MaxDetailAmount.\n"
                },
                "setIsEnableFrustumCull": {
                    "type": "method",
                    "define": "setIsEnableFrustumCull(${1:#bool boolValue})",
                    "detail": "Switch frustum Culling Flag\nNote frustum culling will remarkable improve your terrain rendering performance. \n"
                },
                "getMinHeight": {
                    "type": "method",
                    "define": "getMinHeight()",
                    "detail": "get the terrain's minimal height.\n"
                },
                "getHeightData": {
                    "type": "method",
                    "define": "getHeightData()",
                    "detail": "get the terrain's height data\n"
                },
                "setSkirtHeightRatio": {
                    "type": "method",
                    "define": "setSkirtHeightRatio(${1:#float ratio})",
                    "detail": "set the skirt height ratio\n"
                },
                "initTextures": {
                    "type": "method",
                    "define": "initTextures()",
                    "detail": "initialize alphaMap ,detailMaps textures\n"
                },
                "getMaxHeight": {
                    "type": "method",
                    "define": "getMaxHeight()",
                    "detail": "get the terrain's maximal height.\n"
                },
                "setLightDir": {
                    "type": "method",
                    "define": "setLightDir(${1:#vec3_table lightDir})",
                    "detail": "set directional light for the terrain\nparam lightDir The direction of directional light, Note that lightDir is in the terrain's local space. Most of the time terrain is placed at (0,0,0) and without rotation, so lightDir is also in the world space.\n"
                },
                "setLightMap": {
                    "type": "method",
                    "define": "setLightMap(${1:#string fileName})",
                    "detail": " set light map texture \n"
                },
                "getNormal": {
                    "type": "method",
                    "define": "getNormal(${1:#int pixelX},${2:#int pixelY})",
                    "detail": "get the normal of the specified position in terrain\nreturn the normal vector of the specified position of the terrain.\nnote the fast normal calculation may not get precise normal vector.\n"
                },
                "setLODDistance": {
                    "type": "method",
                    "define": "setLODDistance(${1:#float lod1},${2:#float lod2},${3:#float lod3})",
                    "detail": "Set threshold distance of each LOD level,must equal or greater than the chunk size\nNote when invoke initHeightMap, the LOD distance will be automatic calculated.\n"
                },
                "reload": {
                    "type": "method",
                    "define": "reload()"
                },
                "getImageHeight": {
                    "type": "method",
                    "define": "getImageHeight(${1:#int pixelX},${2:#int pixelY})",
                    "detail": "get height from the raw height filed\n"
                },
                "setDetailMap": {
                    "type": "method",
                    "define": "setDetailMap(${1:#unsigned int index},${2:#cc.Terrain::DetailMap detailMap})",
                    "detail": "set the Detail Map \n"
                },
                "setAlphaMap": {
                    "type": "method",
                    "define": "setAlphaMap(${1:#cc.Texture2D newAlphaMapTexture})",
                    "detail": " set the alpha map\n"
                },
                "initHeightMap": {
                    "type": "method",
                    "define": "initHeightMap(${1:#string heightMap})",
                    "detail": "initialize heightMap data \n"
                },
                "setDrawWire": {
                    "type": "method",
                    "define": "setDrawWire(${1:#bool boolValue})",
                    "detail": "show the wireline instead of the surface,Debug Use only.\nNote only support desktop platform\n"
                }
            },
            "ScrollView": {
                "1": "getContainer",
                "2": "getContentOffset",
                "3": "getViewSize",
                "4": "getZoomScale",
                "5": "hasVisibleParents",
                "6": "initWithViewSize",
                "7": "isBounceable",
                "8": "isClippingToBounds",
                "9": "isDragging",
                "10": "isNodeVisible",
                "11": "isTouchEnabled",
                "12": "isTouchMoved",
                "13": "maxContainerOffset",
                "14": "minContainerOffset",
                "15": "new",
                "16": "pause",
                "17": "registerScriptHandler",
                "18": "resume",
                "19": "setBounceable",
                "20": "setClippingToBounds",
                "21": "setContainer",
                "22": "setContentOffset",
                "23": "setContentOffsetInDuration",
                "24": "setDelegate",
                "25": "setMaxScale",
                "26": "setMinScale",
                "27": "setTouchEnabled",
                "28": "setViewSize",
                "29": "setZoomScale",
                "30": "setZoomScaleInDuration",
                "31": "stopAnimatedContentOffset",
                "32": "unregisterScriptHandler",
                "33": "updateInset",
                "34": "updateTweenAction",
                "getDirection": {
                    "type": "method",
                    "define": "getDirection()",
                    "detail": "Query scroll direction of scrollview.\nsee `Direction`      Direction::VERTICAL means vertical scroll, Direction::HORIZONTAL means horizontal scroll\nreturn Scrollview scroll direction.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Create an empty ScrollView.\nreturn A ScrollView instance.\n"
                },
                "setDirection": {
                    "type": "method",
                    "define": "setDirection(${1:#int dir})",
                    "detail": "Changes scroll direction of scrollview.\nsee `Direction`\nparam dir Scroll direction enum.\n"
                }
            },
            "ActionManager": {
                "1": "new",
                "removeAction": {
                    "type": "method",
                    "define": "removeAction(${1:#cc.Action action})",
                    "detail": " Removes an action given an action reference.\nparam action    A certain target.\n"
                },
                "pauseTarget": {
                    "type": "method",
                    "define": "pauseTarget(${1:#cc.Node target})",
                    "detail": " Pauses the target: all running actions and newly added actions will be paused.\nparam target    A certain target.\n"
                },
                "removeActionsByFlags": {
                    "type": "method",
                    "define": "removeActionsByFlags(${1:#unsigned int flags},${2:#cc.Node target})",
                    "detail": " Removes all actions matching at least one bit in flags and the target.\nparam flags     The flag field to match the actions' flags based on bitwise AND.\nparam target    A certain target.\njs NA\n"
                },
                "removeAllActions": {
                    "type": "method",
                    "define": "removeAllActions()",
                    "detail": " Removes all actions from all the targets.\n"
                },
                "resumeTarget": {
                    "type": "method",
                    "define": "resumeTarget(${1:#cc.Node target})",
                    "detail": " Resumes the target. All queued actions will be resumed.\nparam target    A certain target.\n"
                },
                "addAction": {
                    "type": "method",
                    "define": "addAction(${1:#cc.Action action},${2:#cc.Node target},${3:#bool paused})",
                    "detail": " Adds an action with a target. \nIf the target is already present, then the action will be added to the existing target.\nIf the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.\nWhen the target is paused, the queued actions won't be 'ticked'.\nparam action    A certain action.\nparam target    The target which need to be added an action.\nparam paused    Is the target paused or not.\n"
                },
                "pauseAllRunningActions": {
                    "type": "method",
                    "define": "pauseAllRunningActions()",
                    "detail": " Pauses all running actions, returning a list of targets whose actions were paused.\nreturn  A list of targets whose actions were paused.\n"
                },
                "getNumberOfRunningActionsInTarget": {
                    "type": "method",
                    "define": "getNumberOfRunningActionsInTarget(${1:#cc.Node target})",
                    "detail": " Returns the numbers of actions that are running in a certain target. \nComposable actions are counted as 1 action. Example:\n- If you are running 1 Sequence of 7 actions, it will return 1.\n- If you are running 7 Sequences of 2 actions, it will return 7.\nparam target    A certain target.\nreturn  The numbers of actions that are running in a certain target.\njs NA\n"
                },
                "getNumberOfRunningActionsInTargetByTag": {
                    "type": "method",
                    "define": "getNumberOfRunningActionsInTargetByTag(${1:#cc.Node target},${2:#int tag})",
                    "detail": " Returns the numbers of actions that are running in a\ncertain target with a specific tag.\nLike getNumberOfRunningActionsInTarget Composable actions\nare counted as 1 action. Example:\n- If you are running 1 Sequence of 7 actions, it will return 1.\n- If you are running 7 Sequences of 2 actions, it will return 7.\nparam target    A certain target.\nparam tag       Tag that will be searched.\nreturn  The numbers of actions that are running in a certain target\nwith a specific tag.\nsee getNumberOfRunningActionsInTarget\njs NA\n"
                },
                "getActionByTag": {
                    "type": "method",
                    "define": "getActionByTag(${1:#int tag},${2:#cc.Node target})",
                    "detail": " Gets an action given its tag an a target.\nparam tag       The action's tag.\nparam target    A certain target.\nreturn  The Action the with the given tag.\n"
                },
                "removeAllActionsFromTarget": {
                    "type": "method",
                    "define": "removeAllActionsFromTarget(${1:#cc.Node target})",
                    "detail": " Removes all actions from a certain target.\nAll the actions that belongs to the target will be removed.\nparam target    A certain target.\n"
                },
                "removeAllActionsByTag": {
                    "type": "method",
                    "define": "removeAllActionsByTag(${1:#int tag},${2:#cc.Node target})",
                    "detail": " Removes all actions given its tag and the target.\nparam tag       The actions' tag.\nparam target    A certain target.\njs NA\n"
                },
                "resumeTargets": {
                    "type": "method",
                    "define": "resumeTargets(${1:#array_table targetsToResume})",
                    "detail": " Resume a set of targets (convenience function to reverse a pauseAllRunningActions call).\nparam targetsToResume   A set of targets need to be resumed.\n"
                },
                "update": {
                    "type": "method",
                    "define": "update(${1:#float dt})",
                    "detail": " Main loop of ActionManager.\nparam dt    In seconds.\n"
                },
                "removeActionByTag": {
                    "type": "method",
                    "define": "removeActionByTag(${1:#int tag},${2:#cc.Node target})",
                    "detail": " Removes an action given its tag and the target.\nparam tag       The action's tag.\nparam target    A certain target.\n"
                }
            },
            "284": "VERTEX_ATTRIB_TEX_COORDS",
            "CallFunc": {
                "1": "create",
                "2": "new",
                "getTargetCallback": {
                    "type": "method",
                    "define": "getTargetCallback()",
                    "detail": " Get the selector target.\nreturn The selector target.\n"
                },
                "execute": {
                    "type": "method",
                    "define": "execute()",
                    "detail": " Executes the callback.\n"
                },
                "setTargetCallback": {
                    "type": "method",
                    "define": "setTargetCallback(${1:#cc.Ref sel})",
                    "detail": " Set the selector target.\nparam sel The selector target.\n"
                }
            },
            "EaseQuadraticActionIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "FlipX": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#bool x})",
                    "detail": " Create the action.\nparam x Flips the sprite horizontally if true.\nreturn  An autoreleased FlipX object.\n"
                },
                "initWithFlipX": {
                    "type": "method",
                    "define": "initWithFlipX(${1:#bool x})",
                    "detail": " init the action \n"
                }
            },
            "TMXObjectGroup": {
                "1": "new",
                "getObject": {
                    "type": "method",
                    "define": "getObject(${1:#string objectName})",
                    "detail": " Return the dictionary for the specific object name.\nIt will return the 1st object found on the array for the given name.\nreturn Return the dictionary for the specific object name.\n"
                },
                "getPositionOffset": {
                    "type": "method",
                    "define": "getPositionOffset()",
                    "detail": " Gets the offset position of child objects. \nreturn The offset position of child objects.\n"
                },
                "getGroupName": {
                    "type": "method",
                    "define": "getGroupName()",
                    "detail": " Get the group name. \nreturn The group name.\n"
                },
                "setGroupName": {
                    "type": "method",
                    "define": "setGroupName(${1:#string groupName})",
                    "detail": " Set the group name. \nparam groupName A string,it is used to set the group name.\n"
                },
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})",
                    "detail": " Sets the list of properties.\nparam properties The list of properties.\n"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "getObjects": {
                    "type": "method",
                    "define": "getObjects()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "setObjects": {
                    "type": "method",
                    "define": "setObjects(${1:#array_table objects})",
                    "detail": " Sets the array of the objects.\nparam objects The array of the objects.\n"
                },
                "getProperty": {
                    "type": "method",
                    "define": "getProperty(${1:#string propertyName})",
                    "detail": " Return the value for the specific property name. \nparam propertyName The specific property name.\nreturn Return the value for the specific property name.\njs NA\n"
                },
                "setPositionOffset": {
                    "type": "method",
                    "define": "setPositionOffset(${1:#vec2_table offset})",
                    "detail": " Sets the offset position of child objects. \nparam offset The offset position of child objects.\n"
                }
            },
            "274": "V3F_C4B_T2F_Quad",
            "361": "vec3sub",
            "276": "VERTEX_ATTRIB_FLAG_COLOR",
            "TransitionEaseScene": {
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})",
                    "detail": " Returns the Ease action that will be performed on a linear action.\nsince v0.8.2\nparam action A given interval action.\nreturn The Ease action that will be performed on a linear action.\n"
                }
            },
            "TintBy": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#short deltaRed},${3:#short deltaGreen},${4:#short deltaBlue})",
                    "detail": "Creates an action with duration and color.\nparam duration Duration time, in seconds.\nparam deltaRed Delta red color.\nparam deltaGreen Delta green color.\nparam deltaBlue Delta blue color.\nreturn An autoreleased TintBy object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#short deltaRed},${3:#short deltaGreen},${4:#short deltaBlue})",
                    "detail": " initializes the action with duration and color \n"
                }
            },
            "Pass": {
                "getHash": {
                    "type": "method",
                    "define": "getHash()"
                },
                "setVertexAttribBinding": {
                    "type": "method",
                    "define": "setVertexAttribBinding(${1:#cc.VertexAttribBinding binding})",
                    "detail": "Sets a vertex attribute binding for this pass.\nWhen a mesh binding is set, the VertexAttribBinding will be automatically\nbound when the bind() method is called for the pass.\nparam binding The VertexAttribBinding to set (or NULL to remove an existing binding).\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "Returns a clone (deep-copy) of this instance \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Technique parent})"
                },
                "getVertexAttributeBinding": {
                    "type": "method",
                    "define": "getVertexAttributeBinding()",
                    "detail": "Returns the vertex attribute binding for this pass.\nreturn The vertex attribute binding for this pass.\n"
                },
                "bind": {
                    "type": "method",
                    "define": "bind(${1:#mat4_table modelView},${2:#bool bindAttributes})",
                    "detail": "@overload self, mat4_table, bool         \n@overload self, mat4_table         \n"
                },
                "unbind": {
                    "type": "method",
                    "define": "unbind()",
                    "detail": " Unbinds the Pass.\nThis method must be called AFTER calling the actual draw call\n"
                },
                "getGLProgramState": {
                    "type": "method",
                    "define": "getGLProgramState()",
                    "detail": " Returns the GLProgramState \n"
                },
                "createWithGLProgramState": {
                    "type": "method",
                    "define": "createWithGLProgramState(${1:#cc.Technique parent},${2:#cc.GLProgramState programState})",
                    "detail": " Creates a Pass with a GLProgramState.\n"
                }
            },
            "358": "vec3dot",
            "294": "WEBSOCKET_STATE_CLOSING",
            "FiniteTimeAction": {
                "getDuration": {
                    "type": "method",
                    "define": "getDuration()",
                    "detail": " Get duration in seconds of the action. \nreturn The duration in seconds of the action.\n"
                },
                "setDuration": {
                    "type": "method",
                    "define": "setDuration(${1:#float duration})",
                    "detail": " Set duration in seconds of the action. \nparam duration In seconds of the action.\n"
                }
            },
            "292": "WEBSOCKET_OPEN",
            "EaseQuadraticActionInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "290": "WEBSOCKET_ERROR",
            "TiledGrid3D": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table gridSize},${2:#cc.Texture2D texture},${3:#bool flipped},${4:#rect_table rect})",
                    "detail": "@overload self, size_table, rect_table         \n@overload self, size_table         \n@overload self, size_table, cc.Texture2D, bool         \n@overload self, size_table, cc.Texture2D, bool, rect_table         \n"
                },
                "1": "new"
            },
            "TransitionZoomFlipY": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene s},${3:#int o})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, int         \n"
                },
                "1": "new"
            },
            "TintTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#unsigned char red},${3:#unsigned char green},${4:#unsigned char blue})",
                    "detail": "@overload self, float, color3b_table         \n@overload self, float, unsigned char, unsigned char, unsigned char         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#unsigned char red},${3:#unsigned char green},${4:#unsigned char blue})",
                    "detail": " initializes the action with duration and color \n"
                }
            },
            "302": "Z_COMPRESSION_BZIP2",
            "TransitionFlipY": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene s},${3:#int o})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, int         \n"
                },
                "1": "new"
            },
            "Scheduler": {
                "1": "new",
                "2": "scheduleScriptFunc",
                "3": "unscheduleScriptEntry",
                "removeAllFunctionsToBePerformedInCocosThread": {
                    "type": "method",
                    "define": "removeAllFunctionsToBePerformedInCocosThread()",
                    "detail": "Remove all pending functions queued to be performed with Scheduler::performFunctionInCocosThread\nFunctions unscheduled in this manner will not be executed\nThis function is thread safe\nsince v3.14\njs NA\n"
                },
                "getTimeScale": {
                    "type": "method",
                    "define": "getTimeScale()",
                    "detail": "Gets the time scale of schedule callbacks.\nsee Scheduler::setTimeScale()\n"
                },
                "setTimeScale": {
                    "type": "method",
                    "define": "setTimeScale(${1:#float timeScale})",
                    "detail": " Modifies the time of all scheduled callbacks.\nYou can use this property to create a 'slow motion' or 'fast forward' effect.\nDefault is 1.0. To create a 'slow motion' effect, use values below 1.0.\nTo create a 'fast forward' effect, use values higher than 1.0.\nsince v0.8\nwarning It will affect EVERY scheduled selector / action.\n"
                }
            },
            "TransitionFlipX": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene s},${3:#int o})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, int         \n"
                },
                "1": "new"
            },
            "CSLoader": {
                "1": "createNode",
                "2": "createNode2",
                "3": "createTimeline",
                "4": "new",
                "createNodeWithVisibleSize": {
                    "type": "method",
                    "define": "createNodeWithVisibleSize(${1:#string filename},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "getJsonPath": {
                    "type": "method",
                    "define": "getJsonPath()"
                },
                "createNodeFromJson": {
                    "type": "method",
                    "define": "createNodeFromJson(${1:#string filename})"
                },
                "setJsonPath": {
                    "type": "method",
                    "define": "setJsonPath(${1:#string jsonPath})"
                },
                "createNodeWithFlatBuffersForSimulator": {
                    "type": "method",
                    "define": "createNodeWithFlatBuffersForSimulator(${1:#string filename})"
                },
                "createNodeWithFlatBuffersFile": {
                    "type": "method",
                    "define": "createNodeWithFlatBuffersFile(${1:#string filename})"
                },
                "loadNodeWithContent": {
                    "type": "method",
                    "define": "loadNodeWithContent(${1:#string content})"
                },
                "setRecordJsonPath": {
                    "type": "method",
                    "define": "setRecordJsonPath(${1:#bool record})"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "isRecordJsonPath": {
                    "type": "method",
                    "define": "isRecordJsonPath()"
                },
                "loadNodeWithFile": {
                    "type": "method",
                    "define": "loadNodeWithFile(${1:#string fileName})"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()"
                },
                "bindCallback": {
                    "type": "method",
                    "define": "bindCallback(${1:#string callbackName},${2:#string callbackType},${3:#ccui.Widget sender},${4:#cc.Node handler})"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()"
                }
            },
            "TransitionFadeTR": {
                "1": "new",
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})"
                },
                "actionWithSize": {
                    "type": "method",
                    "define": "actionWithSize(${1:#size_table size})",
                    "detail": " Returns the action that will be performed with size.\nparam size A given size.\nreturn The action that will be performed.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionFadeTR object.\n"
                }
            },
            "296": "WEBSOCKET_STATE_OPEN",
            "EventListenerMouse": {
                "1": "create",
                "2": "new",
                "3": "registerScriptHandler",
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "/ Overrides\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                }
            },
            "FlipX3D": {
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration})",
                    "detail": "brief Initializes an action with duration.\nparam duration Specify the duration of the FlipX3D action. It's a value in seconds.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration})",
                    "detail": "brief Create the action with duration.\nparam duration Specify the duration of the FilpX3D action. It's a value in seconds.\nreturn If the creation success, return a pointer of FilpX3D action; otherwise, return nil.\n"
                },
                "initWithSize": {
                    "type": "method",
                    "define": "initWithSize(${1:#size_table gridSize},${2:#float duration})",
                    "detail": "brief Initializes an action with duration and grid size.\nparam gridSize Specify the grid size of the FlipX3D action.\nparam duration Specify the duration of the FlipX3D action. It's a value in seconds.\nreturn If the initialization success, return true; otherwise, return false.\n"
                }
            },
            "345": "rectGetMaxY",
            "308": "c4b",
            "344": "rectGetMaxX",
            "306": "blendFunc",
            "MenuItem": {
                "1": "new",
                "2": "registerScriptTapHandler",
                "isSelected": {
                    "type": "method",
                    "define": "isSelected()",
                    "detail": " Returns whether or not the item is selected. \n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()",
                    "detail": " Returns whether or not the item is enabled. \n"
                },
                "unselected": {
                    "type": "method",
                    "define": "unselected()",
                    "detail": " The item was unselected. \n"
                },
                "selected": {
                    "type": "method",
                    "define": "selected()",
                    "detail": " The item was selected (not activated), similar to \"mouse-over\". \n"
                },
                "3": "unregisterScriptTapHandler",
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool value})",
                    "detail": " Enables or disables the item. \n"
                },
                "rect": {
                    "type": "method",
                    "define": "rect()",
                    "detail": " Returns the outside box. \n"
                },
                "activate": {
                    "type": "method",
                    "define": "activate()",
                    "detail": " Activate the item. \n"
                }
            },
            "304": "Z_COMPRESSION_NONE",
            "TransitionMoveInT": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionMoveInT object.\n"
                },
                "1": "new"
            },
            "318": "pFromSize",
            "EaseRateAction": {
                "getRate": {
                    "type": "method",
                    "define": "getRate()",
                    "detail": "brief Get the rate value of the ease rate action.\nreturn Return the rate value of the ease rate action.\n"
                },
                "initWithAction": {
                    "type": "method",
                    "define": "initWithAction(${1:#cc.ActionInterval pAction},${2:#float fRate})",
                    "detail": "brief Initializes the action with the inner action and the rate parameter.\nparam pAction The pointer of the inner action.\nparam fRate The value of the rate parameter.\nreturn Return true when the initialization success, otherwise return false.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "setRate": {
                    "type": "method",
                    "define": "setRate(${1:#float rate})",
                    "detail": "brief Set the rate value for the ease rate action.\nparam rate The value will be set.\n"
                }
            },
            "TMXMapInfo": {
                "1": "new",
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})"
                },
                "setLayerAttribs": {
                    "type": "method",
                    "define": "setLayerAttribs(${1:#int layerAttribs})"
                },
                "getCurrentString": {
                    "type": "method",
                    "define": "getCurrentString()"
                },
                "getParentElement": {
                    "type": "method",
                    "define": "getParentElement()",
                    "detail": "/ parent element\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string tmxFile})",
                    "detail": " creates a TMX Format with a tmx file \n"
                },
                "parseXMLString": {
                    "type": "method",
                    "define": "parseXMLString(${1:#string xmlString})"
                },
                "setTileSize": {
                    "type": "method",
                    "define": "setTileSize(${1:#size_table tileSize})"
                },
                "setTilesets": {
                    "type": "method",
                    "define": "setTilesets(${1:#array_table tilesets})"
                },
                "getExternalTilesetFileName": {
                    "type": "method",
                    "define": "getExternalTilesetFileName()"
                },
                "getTilesets": {
                    "type": "method",
                    "define": "getTilesets()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "isStoringCharacters": {
                    "type": "method",
                    "define": "isStoringCharacters()",
                    "detail": "/ is storing characters?\n"
                },
                "setParentElement": {
                    "type": "method",
                    "define": "setParentElement(${1:#int element})"
                },
                "setObjectGroups": {
                    "type": "method",
                    "define": "setObjectGroups(${1:#array_table groups})"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "setMapSize": {
                    "type": "method",
                    "define": "setMapSize(${1:#size_table mapSize})"
                },
                "getParentGID": {
                    "type": "method",
                    "define": "getParentGID()",
                    "detail": "/ parent GID\n"
                },
                "getStaggerIndex": {
                    "type": "method",
                    "define": "getStaggerIndex()",
                    "detail": "/ map stagger index\n"
                },
                "getObjectGroups": {
                    "type": "method",
                    "define": "getObjectGroups()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "getLayers": {
                    "type": "method",
                    "define": "getLayers()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "setTileProperties": {
                    "type": "method",
                    "define": "setTileProperties(${1:#map_table tileProperties})"
                },
                "parseXMLFile": {
                    "type": "method",
                    "define": "parseXMLFile(${1:#string xmlFilename})",
                    "detail": " initializes parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file \n"
                },
                "setTMXFileName": {
                    "type": "method",
                    "define": "setTMXFileName(${1:#string fileName})"
                },
                "setStaggerIndex": {
                    "type": "method",
                    "define": "setStaggerIndex(${1:#int staggerIndex})"
                },
                "setOrientation": {
                    "type": "method",
                    "define": "setOrientation(${1:#int orientation})"
                },
                "setHexSideLength": {
                    "type": "method",
                    "define": "setHexSideLength(${1:#int hexSideLength})"
                },
                "getTileSize": {
                    "type": "method",
                    "define": "getTileSize()",
                    "detail": "/ tiles width & height\n"
                },
                "setStaggerAxis": {
                    "type": "method",
                    "define": "setStaggerAxis(${1:#int staggerAxis})"
                },
                "setParentGID": {
                    "type": "method",
                    "define": "setParentGID(${1:#int gid})"
                },
                "getHexSideLength": {
                    "type": "method",
                    "define": "getHexSideLength()",
                    "detail": "/ map hexsidelength\n"
                },
                "setLayers": {
                    "type": "method",
                    "define": "setLayers(${1:#array_table layers})"
                },
                "getLayerAttribs": {
                    "type": "method",
                    "define": "getLayerAttribs()",
                    "detail": "/ layer attribs\n"
                },
                "initWithXML": {
                    "type": "method",
                    "define": "initWithXML(${1:#string tmxString},${2:#string resourcePath})",
                    "detail": " initializes a TMX format with an XML string and a TMX resource path \n"
                },
                "setStoringCharacters": {
                    "type": "method",
                    "define": "setStoringCharacters(${1:#bool storingCharacters})"
                },
                "getTMXFileName": {
                    "type": "method",
                    "define": "getTMXFileName()"
                },
                "setCurrentString": {
                    "type": "method",
                    "define": "setCurrentString(${1:#string currentString})"
                },
                "getOrientation": {
                    "type": "method",
                    "define": "getOrientation()",
                    "detail": "/ map orientation\n"
                },
                "getStaggerAxis": {
                    "type": "method",
                    "define": "getStaggerAxis()",
                    "detail": "/ map staggeraxis\n"
                },
                "createWithXML": {
                    "type": "method",
                    "define": "createWithXML(${1:#string tmxString},${2:#string resourcePath})",
                    "detail": " creates a TMX Format with an XML string and a TMX resource path \n"
                },
                "getTileProperties": {
                    "type": "method",
                    "define": "getTileProperties()"
                },
                "initWithTMXFile": {
                    "type": "method",
                    "define": "initWithTMXFile(${1:#string tmxFile})",
                    "detail": " initializes a TMX format with a  tmx file \n"
                },
                "getMapSize": {
                    "type": "method",
                    "define": "getMapSize()",
                    "detail": "/ map width & height\n"
                }
            },
            "342": "rectContainsPoint",
            "DirectionLight": {
                "1": "new",
                "setDirection": {
                    "type": "method",
                    "define": "setDirection(${1:#vec3_table dir})",
                    "detail": "Sets the Direction in parent.\nparam dir The Direction in parent.\n"
                },
                "getDirection": {
                    "type": "method",
                    "define": "getDirection()",
                    "detail": "Returns the Direction in parent.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#vec3_table direction},${2:#color3b_table color})",
                    "detail": "Creates a direction light.\nparam direction The light's direction\nparam color The light's color.\nreturn The new direction light.\n"
                },
                "getDirectionInWorld": {
                    "type": "method",
                    "define": "getDirectionInWorld()",
                    "detail": "Returns direction in world.\n"
                }
            },
            "ToggleVisibility": {
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Allocates and initializes the action.\nreturn An autoreleased ToggleVisibility object.\n"
                },
                "1": "new"
            },
            "ControlSlider": {
                "1": "new",
                "locationFromTouch": {
                    "type": "method",
                    "define": "locationFromTouch(${1:#cc.Touch touch})"
                },
                "setMaximumAllowedValue": {
                    "type": "method",
                    "define": "setMaximumAllowedValue(${1:#float var})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Sprite backgroundSprite},${2:#cc.Sprite pogressSprite},${3:#cc.Sprite thumbSprite},${4:#cc.Sprite selectedThumbSprite})",
                    "detail": "@overload self, cc.Sprite, cc.Sprite, cc.Sprite         \n@overload self, char, char, char         \n@overload self, char, char, char, char         \n@overload self, cc.Sprite, cc.Sprite, cc.Sprite, cc.Sprite         \n"
                },
                "setValue": {
                    "type": "method",
                    "define": "setValue(${1:#float val})"
                },
                "setMaximumValue": {
                    "type": "method",
                    "define": "setMaximumValue(${1:#float val})"
                },
                "getProgressSprite": {
                    "type": "method",
                    "define": "getProgressSprite()"
                },
                "getBackgroundSprite": {
                    "type": "method",
                    "define": "getBackgroundSprite()"
                },
                "initWithSprites": {
                    "type": "method",
                    "define": "initWithSprites(${1:#cc.Sprite backgroundSprite},${2:#cc.Sprite progressSprite},${3:#cc.Sprite thumbSprite},${4:#cc.Sprite selectedThumbSprite})",
                    "detail": "@overload self, cc.Sprite, cc.Sprite, cc.Sprite, cc.Sprite         \n@overload self, cc.Sprite, cc.Sprite, cc.Sprite         \n"
                },
                "getMaximumAllowedValue": {
                    "type": "method",
                    "define": "getMaximumAllowedValue()"
                },
                "getSelectedThumbSprite": {
                    "type": "method",
                    "define": "getSelectedThumbSprite()"
                },
                "setMinimumValue": {
                    "type": "method",
                    "define": "setMinimumValue(${1:#float val})"
                },
                "setThumbSprite": {
                    "type": "method",
                    "define": "setThumbSprite(${1:#cc.Sprite var})"
                },
                "getMaximumValue": {
                    "type": "method",
                    "define": "getMaximumValue()"
                },
                "getMinimumValue": {
                    "type": "method",
                    "define": "getMinimumValue()"
                },
                "setProgressSprite": {
                    "type": "method",
                    "define": "setProgressSprite(${1:#cc.Sprite var})"
                },
                "setMinimumAllowedValue": {
                    "type": "method",
                    "define": "setMinimumAllowedValue(${1:#float var})"
                },
                "setSelectedThumbSprite": {
                    "type": "method",
                    "define": "setSelectedThumbSprite(${1:#cc.Sprite var})"
                },
                "getValue": {
                    "type": "method",
                    "define": "getValue()"
                },
                "getMinimumAllowedValue": {
                    "type": "method",
                    "define": "getMinimumAllowedValue()"
                },
                "setBackgroundSprite": {
                    "type": "method",
                    "define": "setBackgroundSprite(${1:#cc.Sprite var})"
                },
                "getThumbSprite": {
                    "type": "method",
                    "define": "getThumbSprite()"
                }
            },
            "TransitionMoveInL": {
                "1": "new",
                "action": {
                    "type": "method",
                    "define": "action()",
                    "detail": " Returns the action that will be performed. \nreturn The action that will be performed.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionMoveInL object.\n"
                },
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})"
                }
            },
            "339": "quaternion",
            "TransitionJumpZoom": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionJumpZoom object.\n"
                },
                "1": "new"
            },
            "335": "pRotateByAngle",
            "TransitionCrossFade": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionCrossFade object.\n"
                },
                "1": "new"
            },
            "333": "pProject",
            "332": "pPerp",
            "DrawPrimitives": [
                "drawCardinalSpline",
                "drawCatmullRom",
                "drawCircle",
                "drawColor4B",
                "drawColor4F",
                "drawCubicBezier",
                "drawLine",
                "drawPoint",
                "drawPoints",
                "drawPoly",
                "drawQuadBezier",
                "drawRect",
                "drawSolidCircle",
                "drawSolidPoly",
                "drawSolidRect",
                "setPointSize"
            ],
            "FadeOutBLTiles": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize})",
                    "detail": "brief Create the action with the grid size and the duration.\nparam duration Specify the duration of the FadeOutBLTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nreturn If the creation success, return a pointer of FadeOutBLTiles action; otherwise, return nil.\n"
                },
                "1": "new"
            },
            "Texture2D": {
                "1": "new",
                "2": "setTexParameters",
                "getPixelsWide": {
                    "type": "method",
                    "define": "getPixelsWide()",
                    "detail": " Gets the width of the texture in pixels. \n"
                },
                "getPixelsHigh": {
                    "type": "method",
                    "define": "getPixelsHigh()",
                    "detail": " Gets the height of the texture in pixels. \n"
                },
                "initWithString": {
                    "type": "method",
                    "define": "initWithString(${1:#char text},${2:#string fontName},${3:#float fontSize},${4:#size_table dimensions},${5:#int hAlignment},${6:#int vAlignment},${7:#bool enableWrap},${8:#int overflow})",
                    "detail": "@overload self, char, cc.FontDefinition         \n@overload self, char, string, float, size_table, int, int, bool, int         \n"
                },
                "setAlphaTexture": {
                    "type": "method",
                    "define": "setAlphaTexture(${1:#cc.Texture2D alphaTexture})"
                },
                "getDefaultAlphaPixelFormat": {
                    "type": "method",
                    "define": "getDefaultAlphaPixelFormat()",
                    "detail": " Returns the alpha pixel format.\nsince v0.8\n"
                },
                "getStringForFormat": {
                    "type": "method",
                    "define": "getStringForFormat()",
                    "detail": " Returns the pixel format.\nsince v2.0\n"
                },
                "getGLProgram": {
                    "type": "method",
                    "define": "getGLProgram()",
                    "detail": " Get a shader program from the texture.\n"
                },
                "setGLProgram": {
                    "type": "method",
                    "define": "setGLProgram(${1:#cc.GLProgram program})",
                    "detail": " Set a shader program to the texture.\nIt's used by drawAtPoint and drawInRect\n"
                },
                "getPath": {
                    "type": "method",
                    "define": "getPath()"
                },
                "initWithImage": {
                    "type": "method",
                    "define": "initWithImage(${1:#cc.Image image},${2:#int format})",
                    "detail": "@overload self, cc.Image, int         \n@overload self, cc.Image         \n"
                },
                "hasPremultipliedAlpha": {
                    "type": "method",
                    "define": "hasPremultipliedAlpha()",
                    "detail": " Whether or not the texture has their Alpha premultiplied. \n"
                },
                "drawInRect": {
                    "type": "method",
                    "define": "drawInRect(${1:#rect_table rect})",
                    "detail": " Draws a texture inside a rect.\n"
                },
                "getContentSizeInPixels": {
                    "type": "method",
                    "define": "getContentSizeInPixels()",
                    "detail": " Get content size. \n"
                },
                "getContentSize": {
                    "type": "method",
                    "define": "getContentSize()",
                    "detail": " Get the texture content size.\n"
                },
                "getMaxS": {
                    "type": "method",
                    "define": "getMaxS()",
                    "detail": " Gets max S. \n"
                },
                "hasMipmaps": {
                    "type": "method",
                    "define": "hasMipmaps()",
                    "detail": " Whether or not the texture has mip maps.\n"
                },
                "setMaxS": {
                    "type": "method",
                    "define": "setMaxS(${1:#float maxS})",
                    "detail": " Sets max S. \n"
                },
                "getAlphaTexture": {
                    "type": "method",
                    "define": "getAlphaTexture()"
                },
                "generateMipmap": {
                    "type": "method",
                    "define": "generateMipmap()",
                    "detail": " Generates mipmap images for the texture.\nIt only works if the texture size is POT (power of 2).\nsince v0.99.0\n"
                },
                "setMaxT": {
                    "type": "method",
                    "define": "setMaxT(${1:#float maxT})",
                    "detail": " Sets max T. \n"
                },
                "getAlphaTextureName": {
                    "type": "method",
                    "define": "getAlphaTextureName()"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()",
                    "detail": " Gets the texture name. \n"
                },
                "setDefaultAlphaPixelFormat": {
                    "type": "method",
                    "define": "setDefaultAlphaPixelFormat(${1:#int format})",
                    "detail": " sets the default pixel format for UIImagescontains alpha channel.\nparam format\nIf the UIImage contains alpha channel, then the options are:\n- generate 32-bit textures: Texture2D::PixelFormat::RGBA8888 (default one)\n- generate 24-bit textures: Texture2D::PixelFormat::RGB888\n- generate 16-bit textures: Texture2D::PixelFormat::RGBA4444\n- generate 16-bit textures: Texture2D::PixelFormat::RGB5A1\n- generate 16-bit textures: Texture2D::PixelFormat::RGB565\n- generate 8-bit textures: Texture2D::PixelFormat::A8 (only use it if you use just 1 color)\nHow does it work ?\n- If the image is an RGBA (with Alpha) then the default pixel format will be used (it can be a 8-bit, 16-bit or 32-bit texture)\n- If the image is an RGB (without Alpha) then: If the default pixel format is RGBA8888 then a RGBA8888 (32-bit) will be used. Otherwise a RGB565 (16-bit texture) will be used.\nThis parameter is not valid for PVR / PVR.CCZ images.\nsince v0.8\n"
                },
                "getBitsPerPixelForFormat": {
                    "type": "method",
                    "define": "getBitsPerPixelForFormat(${1:#int format})",
                    "detail": "@overload self, int         \n@overload self         \n"
                },
                "getMaxT": {
                    "type": "method",
                    "define": "getMaxT()",
                    "detail": " Gets max T. \n"
                },
                "releaseGLTexture": {
                    "type": "method",
                    "define": "releaseGLTexture()",
                    "detail": " Release only the gl texture.\njs NA\nlua NA\n"
                },
                "drawAtPoint": {
                    "type": "method",
                    "define": "drawAtPoint(${1:#vec2_table point})",
                    "detail": "Drawing extensions to make it easy to draw basic quads using a Texture2D object.\nThese functions require GL_TEXTURE_2D and both GL_VERTEX_ARRAY and GL_TEXTURE_COORD_ARRAY client states to be enabled.\nDraws a texture at a given point. \n"
                },
                "getDescription": {
                    "type": "method",
                    "define": "getDescription()",
                    "detail": "Get texture name, dimensions and coordinates message by a string.\njs NA\nlua NA\n"
                },
                "getPixelFormat": {
                    "type": "method",
                    "define": "getPixelFormat()",
                    "detail": " Gets the pixel format of the texture. \n"
                },
                "setAntiAliasTexParameters": {
                    "type": "method",
                    "define": "setAntiAliasTexParameters()",
                    "detail": " Sets antialias texture parameters:\n- GL_TEXTURE_MIN_FILTER = GL_LINEAR\n- GL_TEXTURE_MAG_FILTER = GL_LINEAR\nwarning Calling this method could allocate additional texture memory.\nsince v0.8\n"
                },
                "setAliasTexParameters": {
                    "type": "method",
                    "define": "setAliasTexParameters()",
                    "detail": " Sets alias texture parameters:\n- GL_TEXTURE_MIN_FILTER = GL_NEAREST\n- GL_TEXTURE_MAG_FILTER = GL_NEAREST\nwarning Calling this method could allocate additional texture memory.\nsince v0.8\n"
                }
            },
            "331": "pNormalize",
            "329": "pMidpoint",
            "AttachNode": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Bone3D attachBone})",
                    "detail": "creates an AttachNode\nparam attachBone The bone to which the AttachNode is going to attach, the attacheBone must be a bone of the AttachNode's parent\n"
                },
                "1": "new"
            },
            "AmbientLight": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#color3b_table color})",
                    "detail": "Creates a ambient light.\nparam color The light's color.\nreturn The new ambient light.\n"
                },
                "1": "new"
            },
            "327": "pLengthSQ",
            "TransitionProgressOutIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgressOutIn object.\n"
                },
                "1": "new"
            },
            "ParticleSystemQuad": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Creates a Particle Emitter with a number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleSystemQuad object.\n"
                },
                "setTextureWithRect": {
                    "type": "method",
                    "define": "setTextureWithRect(${1:#cc.Texture2D texture},${2:#rect_table rect})",
                    "detail": " Sets a new texture with a rect. The rect is in Points.\nsince v0.99.4\njs NA\nlua NA\nparam texture A given texture.\n8 @param rect A given rect, in points.\n"
                },
                "listenRendererRecreated": {
                    "type": "method",
                    "define": "listenRendererRecreated(${1:#cc.EventCustom event})",
                    "detail": " Listen the event that renderer was recreated on Android/WP8.\njs NA\nlua NA\nparam event the event that renderer was recreated on Android/WP8.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#map_table dictionary})",
                    "detail": "@overload self, string         \n@overload self         \n@overload self, map_table         \n"
                },
                "setDisplayFrame": {
                    "type": "method",
                    "define": "setDisplayFrame(${1:#cc.SpriteFrame spriteFrame})",
                    "detail": " Sets a new SpriteFrame as particle.\nWARNING: this method is experimental. Use setTextureWithRect instead.\nparam spriteFrame A given sprite frame as particle texture.\nsince v0.99.4\n"
                }
            },
            "ParticleSun": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a sun particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleSun object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a sun particle system.\nreturn An autoreleased ParticleSun object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "EventTouch": {
                "1": "new",
                "setEventCode": {
                    "type": "method",
                    "define": "setEventCode(${1:#int eventCode})",
                    "detail": " Set the event code.\nparam eventCode A given EventCode.\n"
                },
                "getEventCode": {
                    "type": "method",
                    "define": "getEventCode()",
                    "detail": " Get event code.\nreturn The code of the event.\n"
                }
            },
            "EaseSineIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "EaseQuarticActionOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "LayerColor": {
                "changeHeight": {
                    "type": "method",
                    "define": "changeHeight(${1:#float h})",
                    "detail": " Change height in Points.\nparam h The height of layer.\n"
                },
                "changeWidthAndHeight": {
                    "type": "method",
                    "define": "changeWidthAndHeight(${1:#float w},${2:#float h})",
                    "detail": " Change width and height in Points.\nparam w The width of layer.\nparam h The Height of layer.\nsince v0.8\n"
                },
                "1": "new",
                "initWithColor": {
                    "type": "method",
                    "define": "initWithColor(${1:#color4b_table color},${2:#float width},${3:#float height})",
                    "detail": "@overload self, color4b_table         \n@overload self, color4b_table, float, float         \n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "code\nWhen this function bound into js or lua,the parameter will be changed\nIn js: var setBlendFunc(var src, var dst)\nIn lua: local setBlendFunc(local src, local dst)\nendcode\n"
                },
                "changeWidth": {
                    "type": "method",
                    "define": "changeWidth(${1:#float w})",
                    "detail": " Change width in Points.\nparam w The width of layer.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#color4b_table color},${2:#float width},${3:#float height})",
                    "detail": "@overload self, color4b_table, float, float         \n@overload self         \n@overload self, color4b_table         \n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": " BlendFunction. Conforms to BlendProtocol protocol \nlua NA\n"
                }
            },
            "324": "pGetLength",
            "Label": {
                "1": "createWithTTF",
                "enableShadow": {
                    "type": "method",
                    "define": "enableShadow()",
                    "detail": "Enable shadow effect to Label.\ntodo Support blur for shadow effect.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                },
                "requestSystemFontRefresh": {
                    "type": "method",
                    "define": "requestSystemFontRefresh()",
                    "detail": "warning This method is not recommended for game developers.\n"
                },
                "setAlignment": {
                    "type": "method",
                    "define": "setAlignment(${1:#int hAlignment},${2:#int vAlignment})",
                    "detail": "@overload self, int, int         \n@overload self, int         \n"
                },
                "getTextColor": {
                    "type": "method",
                    "define": "getTextColor()",
                    "detail": " Returns the text color of the Label.\n"
                },
                "getTTFConfig": {
                    "type": "method",
                    "define": "getTTFConfig()",
                    "detail": "Returns the TTF configuration object used by the Label.\nsee `TTFConfig`\n"
                },
                "enableWrap": {
                    "type": "method",
                    "define": "enableWrap(${1:#bool enable})",
                    "detail": "Toggle wrap option of the label.\nNote: System font doesn't support manually toggle wrap.\nparam enable Set true to enable wrap and false to disable wrap.\n"
                },
                "setBMFontFilePath": {
                    "type": "method",
                    "define": "setBMFontFilePath(${1:#string bmfontFilePath},${2:#vec2_table imageOffset},${3:#float fontSize})",
                    "detail": " Sets a new bitmap font to Label \n"
                },
                "getTextAlignment": {
                    "type": "method",
                    "define": "getTextAlignment()",
                    "detail": " Returns the Label's text horizontal alignment.\n"
                },
                "enableStrikethrough": {
                    "type": "method",
                    "define": "enableStrikethrough()",
                    "detail": "Enables strikethrough.\nUnderline and Strikethrough cannot be enabled at the same time.\nStrikethrough is like an underline but at the middle of the glyph\n"
                },
                "enableGlow": {
                    "type": "method",
                    "define": "enableGlow(${1:#color4b_table glowColor})",
                    "detail": "Enable glow effect to Label.\nwarning Limiting use to only when the Label created with true type font.\n"
                },
                "setCharMap": {
                    "type": "method",
                    "define": "setCharMap(${1:#string charMapFile},${2:#int itemWidth},${3:#int itemHeight},${4:#int startCharMap})",
                    "detail": "@overload self, cc.Texture2D, int, int, int         \n@overload self, string, int, int, int         \n@overload self, string         \n"
                },
                "getEffectColor": {
                    "type": "method",
                    "define": "getEffectColor()",
                    "detail": "Return current effect color value.\n"
                },
                "getHeight": {
                    "type": "method",
                    "define": "getHeight()"
                },
                "setLineHeight": {
                    "type": "method",
                    "define": "setLineHeight(${1:#float height})",
                    "detail": " Sets the line height of the Label.\nwarning Not support system font.\nsince v3.2.0\n"
                },
                "setMaxLineWidth": {
                    "type": "method",
                    "define": "setMaxLineWidth(${1:#float maxLineWidth})",
                    "detail": "Makes the Label at most this line untransformed width.\nThe Label's max line width be used for force line breaks if the value not equal zero.\n"
                },
                "setSystemFontName": {
                    "type": "method",
                    "define": "setSystemFontName(${1:#string font})",
                    "detail": "Sets a new system font to Label.\nparam font A font file or a font family name.\nwarning\n"
                },
                "getShadowBlurRadius": {
                    "type": "method",
                    "define": "getShadowBlurRadius()",
                    "detail": "Return the shadow effect blur radius.\n"
                },
                "setLineBreakWithoutSpace": {
                    "type": "method",
                    "define": "setLineBreakWithoutSpace(${1:#bool breakWithoutSpace})",
                    "detail": "Specify what happens when a line is too long for Label.\nparam breakWithoutSpace Lines are automatically broken between words if this value is false.\n"
                },
                "getWidth": {
                    "type": "method",
                    "define": "getWidth()"
                },
                "getLineHeight": {
                    "type": "method",
                    "define": "getLineHeight()",
                    "detail": "Returns the line height of this Label.\nwarning Not support system font.\nsince v3.2.0\n"
                },
                "enableBold": {
                    "type": "method",
                    "define": "enableBold()",
                    "detail": "Enable bold rendering\n"
                },
                "getHorizontalAlignment": {
                    "type": "method",
                    "define": "getHorizontalAlignment()",
                    "detail": " Returns the Label's text horizontal alignment.\n"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string text})",
                    "detail": " Sets the text that this Label is to display.\n"
                },
                "setTextColor": {
                    "type": "method",
                    "define": "setTextColor(${1:#color4b_table color})",
                    "detail": "Sets the text color of Label.\nThe text color is different from the color of Node.\nwarning Limiting use to only when the Label created with true type font or system font.\n"
                },
                "updateContent": {
                    "type": "method",
                    "define": "updateContent()",
                    "detail": " Update content immediately.\n"
                },
                "enableUnderline": {
                    "type": "method",
                    "define": "enableUnderline()",
                    "detail": "Enable underline\n"
                },
                "setDimensions": {
                    "type": "method",
                    "define": "setDimensions(${1:#float width},${2:#float height})",
                    "detail": " Sets the untransformed size of the Label in a more efficient way. \n"
                },
                "getMaxLineWidth": {
                    "type": "method",
                    "define": "getMaxLineWidth()"
                },
                "getSystemFontName": {
                    "type": "method",
                    "define": "getSystemFontName()",
                    "detail": " Returns the system font used by the Label.\n"
                },
                "isWrapEnabled": {
                    "type": "method",
                    "define": "isWrapEnabled()",
                    "detail": "Query the wrap is enabled or not.\nNote: System font will always return true.\n"
                },
                "setSystemFontSize": {
                    "type": "method",
                    "define": "setSystemFontSize(${1:#float fontSize})"
                },
                "getOverflow": {
                    "type": "method",
                    "define": "getOverflow()",
                    "detail": "Query the label's Overflow type.\nreturn see `Overflow`\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "setClipMarginEnabled": {
                    "type": "method",
                    "define": "setClipMarginEnabled(${1:#bool clipEnabled})",
                    "detail": " Clips upper and lower margin to reduce height of Label.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Allocates and initializes a Label, with default settings.\nreturn An automatically released Label object.\n"
                },
                "setOverflow": {
                    "type": "method",
                    "define": "setOverflow(${1:#int overflow})",
                    "detail": "Change the label's Overflow type, currently only TTF and BMFont support all the valid Overflow type.\nChar Map font supports all the Overflow type except for SHRINK, because we can't measure it's font size.\nSystem font only support Overflow::Normal and Overflow::RESIZE_HEIGHT.\nparam overflow   see `Overflow`\n"
                },
                "getBMFontSize": {
                    "type": "method",
                    "define": "getBMFontSize()",
                    "detail": "Return the user define BMFont size.\nreturn The BMFont size in float value.\n"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()",
                    "detail": " Return the text the Label is currently displaying.\n"
                },
                "createWithCharMap": {
                    "type": "method",
                    "define": "createWithCharMap(${1:#string charMapFile},${2:#int itemWidth},${3:#int itemHeight},${4:#int startCharMap})",
                    "detail": "@overload self, cc.Texture2D, int, int, int         \n@overload self, string, int, int, int         \n@overload self, string         \n"
                },
                "getShadowOffset": {
                    "type": "method",
                    "define": "getShadowOffset()",
                    "detail": "Return shadow effect offset value.\n"
                },
                "getLetter": {
                    "type": "method",
                    "define": "getLetter(${1:#int lettetIndex})",
                    "detail": "Provides a way to treat each character like a Sprite.\nwarning No support system font.\n"
                },
                "getLineSpacing": {
                    "type": "method",
                    "define": "getLineSpacing()"
                },
                "disableEffect": {
                    "type": "method",
                    "define": "disableEffect(${1:#int effect})",
                    "detail": "@overload self, int         \n@overload self         \n"
                },
                "setAdditionalKerning": {
                    "type": "method",
                    "define": "setAdditionalKerning(${1:#float space})",
                    "detail": "Sets the additional kerning of the Label.\nwarning Not support system font.\nsince v3.2.0\n"
                },
                "isClipMarginEnabled": {
                    "type": "method",
                    "define": "isClipMarginEnabled()"
                },
                "initWithTTF": {
                    "type": "method",
                    "define": "initWithTTF(${1:#string text},${2:#string fontFilePath},${3:#float fontSize},${4:#size_table dimensions},${5:#int hAlignment},${6:#int vAlignment})",
                    "detail": "@overload self, cc._ttfConfig, string, int, int         \n@overload self, string, string, float, size_table, int, int         \n"
                },
                "getVerticalAlignment": {
                    "type": "method",
                    "define": "getVerticalAlignment()",
                    "detail": " Returns the Label's text vertical alignment.\n"
                },
                "getOutlineSize": {
                    "type": "method",
                    "define": "getOutlineSize()",
                    "detail": "Return the outline effect size value.\n"
                },
                "setBMFontSize": {
                    "type": "method",
                    "define": "setBMFontSize(${1:#float fontSize})",
                    "detail": "Change font size of label type BMFONT\nNote: This function only scale the BMFONT letter to mimic the font size change effect.\nparam fontSize The desired font size in float.\n"
                },
                "setLineSpacing": {
                    "type": "method",
                    "define": "setLineSpacing(${1:#float height})"
                },
                "getBMFontFilePath": {
                    "type": "method",
                    "define": "getBMFontFilePath()",
                    "detail": " Returns the bitmap font used by the Label.\n"
                },
                "setHorizontalAlignment": {
                    "type": "method",
                    "define": "setHorizontalAlignment(${1:#int hAlignment})",
                    "detail": " Sets the Label's text horizontal alignment.\n"
                },
                "getFontAtlas": {
                    "type": "method",
                    "define": "getFontAtlas()"
                },
                "setVerticalAlignment": {
                    "type": "method",
                    "define": "setVerticalAlignment(${1:#int vAlignment})",
                    "detail": " Sets the Label's text vertical alignment.\n"
                },
                "setWidth": {
                    "type": "method",
                    "define": "setWidth(${1:#float width})",
                    "detail": "Makes the Label exactly this untransformed width.\nThe Label's width be used for text align if the value not equal zero.\n"
                },
                "enableOutline": {
                    "type": "method",
                    "define": "enableOutline(${1:#color4b_table outlineColor},${2:#int outlineSize})",
                    "detail": "Enable outline effect to Label.\nwarning Limiting use to only when the Label created with true type font or system font.\n"
                },
                "getAdditionalKerning": {
                    "type": "method",
                    "define": "getAdditionalKerning()",
                    "detail": "Returns the additional kerning of the Label.\nwarning Not support system font.\nsince v3.2.0\n"
                },
                "getLabelEffectType": {
                    "type": "method",
                    "define": "getLabelEffectType()",
                    "detail": "Return current effect type.\n"
                },
                "getStringNumLines": {
                    "type": "method",
                    "define": "getStringNumLines()",
                    "detail": "Return the number of lines of text.\n"
                },
                "createWithBMFont": {
                    "type": "method",
                    "define": "createWithBMFont(${1:#string bmfontPath},${2:#string text},${3:#int hAlignment},${4:#int maxLineWidth},${5:#vec2_table imageOffset})",
                    "detail": "Allocates and initializes a Label, with a bitmap font file.\nparam bmfontPath A bitmap font file, it's a FNT format.\nparam text The initial text.\nparam hAlignment Text horizontal alignment.\nparam maxLineWidth The max line width.\nparam imageOffset\nreturn An automatically released Label object.\nsee setBMFontFilePath setMaxLineWidth\n"
                },
                "getStringLength": {
                    "type": "method",
                    "define": "getStringLength()",
                    "detail": "Return length of string.\n"
                },
                "getDimensions": {
                    "type": "method",
                    "define": "getDimensions()"
                },
                "getShadowColor": {
                    "type": "method",
                    "define": "getShadowColor()",
                    "detail": "Return the shadow effect color value.\n"
                },
                "setTTFConfig": {
                    "type": "method",
                    "define": "setTTFConfig(${1:#cc._ttfConfig ttfConfig})",
                    "detail": "Sets a new TTF configuration to Label.\nsee `TTFConfig`\n"
                },
                "isShadowEnabled": {
                    "type": "method",
                    "define": "isShadowEnabled()",
                    "detail": "Return whether the shadow effect is enabled.\n"
                },
                "enableItalics": {
                    "type": "method",
                    "define": "enableItalics()",
                    "detail": "Enable italics rendering\n"
                },
                "getSystemFontSize": {
                    "type": "method",
                    "define": "getSystemFontSize()",
                    "detail": " Returns the bitmap font path used by the Label.\n"
                },
                "setHeight": {
                    "type": "method",
                    "define": "setHeight(${1:#float height})",
                    "detail": "Makes the Label exactly this untransformed height.\nThe Label's height be used for text align if the value not equal zero.\nThe text will display incomplete if the size of Label is not large enough to display all text.\n"
                },
                "removeAllChildrenWithCleanup": {
                    "type": "method",
                    "define": "removeAllChildrenWithCleanup(${1:#bool cleanup})"
                },
                "createWithSystemFont": {
                    "type": "method",
                    "define": "createWithSystemFont(${1:#string text},${2:#string font},${3:#float fontSize},${4:#size_table dimensions},${5:#int hAlignment},${6:#int vAlignment})",
                    "detail": "Allocates and initializes a Label, base on platform-dependent API.\nparam text The initial text.\nparam font A font file or a font family name.\nparam fontSize The font size. This value must be > 0.\nparam dimensions\nparam hAlignment The text horizontal alignment.\nparam vAlignment The text vertical alignment.\nwarning It will generate texture by the platform-dependent code.\nreturn An automatically released Label object.\n"
                }
            },
            "323": "pGetIntersectPoint",
            "SplitRows": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#unsigned int rows})",
                    "detail": "brief Create the action with the number of rows and the duration.\nparam duration Specify the duration of the SplitRows action. It's a value in seconds.\nparam rows Specify the rows count should be split.\nreturn If the creation success, return a pointer of SplitRows action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#unsigned int rows})",
                    "detail": "brief Initializes the action with the number rows and the duration.\nparam duration Specify the duration of the SplitRows action. It's a value in seconds.\nparam rows Specify the rows count should be split.\nreturn If the creation success, return true; otherwise, return false.\n"
                }
            },
            "321": "pGetClampPoint",
            "320": "pGetAngle",
            "EaseQuinticActionInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "LayerGradient": {
                "1": "new",
                "setStartOpacity": {
                    "type": "method",
                    "define": "setStartOpacity(${1:#unsigned char startOpacity})",
                    "detail": " Returns the start opacity of the gradient.\nparam startOpacity The start opacity, from 0 to 255.\n"
                },
                "getStartColor": {
                    "type": "method",
                    "define": "getStartColor()",
                    "detail": " Returns the start color of the gradient.\nreturn The start color.\n"
                },
                "getEndOpacity": {
                    "type": "method",
                    "define": "getEndOpacity()",
                    "detail": " Returns the end opacity of the gradient.\nreturn The end opacity.\n"
                },
                "isCompressedInterpolation": {
                    "type": "method",
                    "define": "isCompressedInterpolation()",
                    "detail": " Get the compressedInterpolation\nreturn The interpolation will be compressed if true.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#color4b_table start},${2:#color4b_table end},${3:#vec2_table v})",
                    "detail": "@overload self, color4b_table, color4b_table         \n@overload self         \n@overload self, color4b_table, color4b_table, vec2_table         \n"
                },
                "setStartColor": {
                    "type": "method",
                    "define": "setStartColor(${1:#color3b_table startColor})",
                    "detail": " Sets the start color of the gradient.\nparam startColor The start color.\n"
                },
                "setVector": {
                    "type": "method",
                    "define": "setVector(${1:#vec2_table alongVector})",
                    "detail": " Sets the directional vector that will be used for the gradient.\nThe default value is vertical direction (0,-1). \nparam alongVector The direction of gradient.\n"
                },
                "setEndColor": {
                    "type": "method",
                    "define": "setEndColor(${1:#color3b_table endColor})",
                    "detail": " Sets the end color of the gradient.\nparam endColor The end color.\n"
                },
                "getEndColor": {
                    "type": "method",
                    "define": "getEndColor()",
                    "detail": " Returns the end color of the gradient.\nreturn The end color.\n"
                },
                "getStartOpacity": {
                    "type": "method",
                    "define": "getStartOpacity()",
                    "detail": " Returns the start opacity of the gradient.\nreturn The start opacity.\n"
                },
                "getVector": {
                    "type": "method",
                    "define": "getVector()",
                    "detail": " Returns the directional vector used for the gradient.\nreturn The direction of gradient.\n"
                },
                "setCompressedInterpolation": {
                    "type": "method",
                    "define": "setCompressedInterpolation(${1:#bool compressedInterpolation})",
                    "detail": " Whether or not the interpolation will be compressed in order to display all the colors of the gradient both in canonical and non canonical vectors.\nDefault: true.\nparam compressedInterpolation The interpolation will be compressed if true.\n"
                },
                "initWithColor": {
                    "type": "method",
                    "define": "initWithColor(${1:#color4b_table start},${2:#color4b_table end},${3:#vec2_table v})",
                    "detail": "@overload self, color4b_table, color4b_table, vec2_table         \n@overload self, color4b_table, color4b_table         \n"
                },
                "setEndOpacity": {
                    "type": "method",
                    "define": "setEndOpacity(${1:#unsigned char endOpacity})",
                    "detail": " Returns the end opacity of the gradient.\nparam endOpacity The end opacity, from 0 to 255.\n"
                }
            },
            "EventCustom": {
                "getEventName": {
                    "type": "method",
                    "define": "getEventName()",
                    "detail": " Gets event name.\nreturn The name of the event.\n"
                },
                "1": "new"
            },
            "RemoveSelf": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create the action.\nparam isNeedCleanUp Is need to clean up, the default value is true.\nreturn An autoreleased RemoveSelf object.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#bool isNeedCleanUp})",
                    "detail": " init the action \n"
                }
            },
            "316": "pDot",
            "315": "pDistanceSQ",
            "314": "pCross",
            "BLUE": [
                "b",
                "g",
                "r"
            ],
            "EaseQuarticActionInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "EaseBackInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "Node": {
                "1": "enumerateChildren",
                "2": "getPosition",
                "3": "new",
                "4": "registerScriptHandler",
                "5": "removeAllChildren",
                "6": "removeFromParent",
                "7": "scheduleUpdateWithPriorityLua",
                "8": "setAdditionalTransform",
                "9": "setAnchorPoint",
                "10": "setAutoBatchEnabled",
                "11": "setContentSize",
                "12": "setRotationQuat",
                "13": "unregisterScriptHandler",
                "14": "unscheduleUpdate",
                "visit": {
                    "type": "method",
                    "define": "visit(${1:#cc.Renderer renderer},${2:#mat4_table parentTransform},${3:#unsigned int parentFlags})",
                    "detail": "@overload self         \n@overload self, cc.Renderer, mat4_table, unsigned int         \n"
                },
                "convertTouchToNodeSpace": {
                    "type": "method",
                    "define": "convertTouchToNodeSpace(${1:#cc.Touch touch})",
                    "detail": "convenience methods which take a Touch instead of Vec2.\nparam touch A given touch.\nreturn A point in world space coordinates.\n"
                },
                "setGLProgram": {
                    "type": "method",
                    "define": "setGLProgram(${1:#cc.GLProgram glprogram})",
                    "detail": "Sets the shader program for this node\nSince v2.0, each rendering node must set its shader program.\nIt should be set in initialize phase.\ncode\nnode->setGLProgram(GLProgramCache::getInstance()->getProgram(GLProgram::SHADER_NAME_POSITION_TEXTURE_COLOR));\nendcode\nparam glprogram The shader program.\n"
                },
                "setonEnterTransitionDidFinishCallback": {
                    "type": "method",
                    "define": "setonEnterTransitionDidFinishCallback(${1:#function callback})",
                    "detail": "Set the callback of event EnterTransitionDidFinish.\nparam callback A std::function<void()> callback.\n"
                },
                "setVisible": {
                    "type": "method",
                    "define": "setVisible(${1:#bool visible})",
                    "detail": "Sets whether the node is visible.\nThe default value is true, a node is default to visible.\nparam visible   true if the node is visible, false if the node is hidden.\n"
                },
                "setPositionZ": {
                    "type": "method",
                    "define": "setPositionZ(${1:#float positionZ})",
                    "detail": "Sets the 'z' coordinate in the position. It is the OpenGL Z vertex value.\nThe OpenGL depth buffer and depth testing are disabled by default. You need to turn them on.\nIn order to use this property correctly.\n`setPositionZ()` also sets the `setGlobalZValue()` with the positionZ as value.\nsee `setGlobalZValue()`\nparam positionZ  OpenGL Z vertex of this node.\njs setVertexZ\n"
                },
                "stopActionByTag": {
                    "type": "method",
                    "define": "stopActionByTag(${1:#int tag})",
                    "detail": "Removes an action from the running action list by its tag.\nparam tag   A tag that indicates the action to be removed.\n"
                },
                "getScaleY": {
                    "type": "method",
                    "define": "getScaleY()",
                    "detail": "Returns the scale factor on Y axis of this node\nsee `setScaleY(float)`\nreturn The scale factor on Y axis.\n"
                },
                "getDisplayedColor": {
                    "type": "method",
                    "define": "getDisplayedColor()",
                    "detail": "Query node's displayed color.\nreturn A Color3B color value.\n"
                },
                "setScaleX": {
                    "type": "method",
                    "define": "setScaleX(${1:#float scaleX})",
                    "detail": "Sets the scale (x) of the node.\nIt is a scaling factor that multiplies the width of the node and its children.\nparam scaleX   The scale factor on X axis.\nwarning The physics body doesn't support this.\n"
                },
                "reorderChild": {
                    "type": "method",
                    "define": "reorderChild(${1:#cc.Node child},${2:#int localZOrder})",
                    "detail": "Reorders a child according to a new z value.\nparam child     An already added child node. It MUST be already added.\nparam localZOrder Z order for drawing priority. Please refer to setLocalZOrder(int).\n"
                },
                "setPhysicsBody": {
                    "type": "method",
                    "define": "setPhysicsBody(${1:#cc.PhysicsBody physicsBody})"
                },
                "setCascadeOpacityEnabled": {
                    "type": "method",
                    "define": "setCascadeOpacityEnabled(${1:#bool cascadeOpacityEnabled})",
                    "detail": "Change node's cascadeOpacity property.\nparam cascadeOpacityEnabled True to enable cascadeOpacity, false otherwise.\n"
                },
                "setTag": {
                    "type": "method",
                    "define": "setTag(${1:#int tag})",
                    "detail": "Changes the tag that is used to identify the node easily.\nPlease refer to getTag for the sample code.\nparam tag   A integer that identifies the node.\nPlease use `setName()` instead.\n"
                },
                "setScaleZ": {
                    "type": "method",
                    "define": "setScaleZ(${1:#float scaleZ})",
                    "detail": "Changes the scale factor on Z axis of this node\nThe Default value is 1.0 if you haven't changed it before.\nparam scaleZ   The scale factor on Z axis.\nwarning The physics body doesn't support this.\n"
                },
                "isCascadeColorEnabled": {
                    "type": "method",
                    "define": "isCascadeColorEnabled()",
                    "detail": "Query whether cascadeColor is enabled or not.\nreturn Whether cascadeColor is enabled or not.\n"
                },
                "setOnExitCallback": {
                    "type": "method",
                    "define": "setOnExitCallback(${1:#function callback})",
                    "detail": "Set the callback of event onExit.\nparam callback A std::function<void()> callback.\n"
                },
                "getNumberOfRunningActions": {
                    "type": "method",
                    "define": "getNumberOfRunningActions()",
                    "detail": "Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).\nComposable actions are counted as 1 action. Example:\nIf you are running 1 Sequence of 7 actions, it will return 1.\nIf you are running 7 Sequences of 2 actions, it will return 7.\nreturn The number of actions that are running plus the ones that are schedule to run.\n"
                },
                "setonExitTransitionDidStartCallback": {
                    "type": "method",
                    "define": "setonExitTransitionDidStartCallback(${1:#function callback})",
                    "detail": "Set the callback of event ExitTransitionDidStart.\nparam callback A std::function<void()> callback.\n"
                },
                "setScheduler": {
                    "type": "method",
                    "define": "setScheduler(${1:#cc.Scheduler scheduler})",
                    "detail": "Sets a Scheduler object that is used to schedule all \"updates\" and timers.\nwarning If you set a new Scheduler, then previously created timers/update are going to be removed.\nparam scheduler     A Scheduler object that is used to schedule all \"update\" and timers.\n"
                },
                "setSkewY": {
                    "type": "method",
                    "define": "setSkewY(${1:#float skewY})",
                    "detail": "Changes the Y skew angle of the node in degrees.\nThe difference between `setRotationalSkew()` and `setSkew()` is that the first one simulate Flash's skew functionality\nwhile the second one uses the real skew function.\nThis angle describes the shear distortion in the Y direction.\nThus, it is the angle between the X coordinate and the bottom edge of the shape.\nThe default skewY angle is 0. Positive values distort the node in a CCW direction.\nparam skewY    The Y skew angle of the node in degrees.\nwarning The physics body doesn't support this.\n"
                },
                "setNormalizedPosition": {
                    "type": "method",
                    "define": "setNormalizedPosition(${1:#vec2_table position})"
                },
                "setSkewX": {
                    "type": "method",
                    "define": "setSkewX(${1:#float skewX})",
                    "detail": "Changes the X skew angle of the node in degrees.\nThe difference between `setRotationalSkew()` and `setSkew()` is that the first one simulate Flash's skew functionality\nwhile the second one uses the real skew function.\nThis angle describes the shear distortion in the X direction.\nThus, it is the angle between the Y coordinate and the left edge of the shape\nThe default skewX angle is 0. Positive values distort the node in a CW direction.\nparam skewX The X skew angle of the node in degrees.\nwarning The physics body doesn't support this.\n"
                },
                "getScheduler": {
                    "type": "method",
                    "define": "getScheduler()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "isOpacityModifyRGB": {
                    "type": "method",
                    "define": "isOpacityModifyRGB()",
                    "detail": "If node opacity will modify the RGB color value, then you should override this method and return true.\nreturn A boolean value, true indicates that opacity will modify color; false otherwise.\n"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#float x},${2:#float y})",
                    "detail": "@overload self, float, float         \n@overload self, vec2_table         \n"
                },
                "getParentToNodeAffineTransform": {
                    "type": "method",
                    "define": "getParentToNodeAffineTransform()"
                },
                "getPositionZ": {
                    "type": "method",
                    "define": "getPositionZ()",
                    "detail": "Gets position Z coordinate of this node.\nsee setPositionZ(float)\nreturn The position Z coordinate of this node.\njs getVertexZ\n"
                },
                "getComponent": {
                    "type": "method",
                    "define": "getComponent(${1:#string name})",
                    "detail": "/ @{/ @name component functions\nGets a component by its name.\nparam name A given name of component.\nreturn The Component by name.\n"
                },
                "getRotation3D": {
                    "type": "method",
                    "define": "getRotation3D()",
                    "detail": "Returns the rotation (X,Y,Z) in degrees.\nreturn The rotation of the node in 3d.\njs NA\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Allocates and initializes a node.\nreturn A initialized node which is marked as \"autorelease\".\n"
                },
                "getWorldToNodeAffineTransform": {
                    "type": "method",
                    "define": "getWorldToNodeAffineTransform()"
                },
                "getSkewX": {
                    "type": "method",
                    "define": "getSkewX()",
                    "detail": "Returns the X skew angle of the node in degrees.\nsee `setSkewX(float)`\nreturn The X skew angle of the node in degrees.\n"
                },
                "getPositionY": {
                    "type": "method",
                    "define": "getPositionY()",
                    "detail": " Gets the y coordinate of the node in its parent's coordinate system.\nreturn The y coordinate of the node.\n"
                },
                "getChildByTag": {
                    "type": "method",
                    "define": "getChildByTag(${1:#int tag})",
                    "detail": "Gets a child from the container with its tag.\nparam tag   An identifier to find the child node.\nreturn a Node object whose tag equals to the input parameter.\nPlease use `getChildByName()` instead.\n"
                },
                "setNodeToParentTransform": {
                    "type": "method",
                    "define": "setNodeToParentTransform(${1:#mat4_table transform})",
                    "detail": "Sets the transformation matrix manually.\nparam transform A given transformation matrix.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "cleanup": {
                    "type": "method",
                    "define": "cleanup()",
                    "detail": "Stops all running actions and schedulers\n"
                },
                "getRotation": {
                    "type": "method",
                    "define": "getRotation()",
                    "detail": "Returns the rotation of the node in degrees.\nsee `setRotation(float)`\nreturn The rotation of the node in degrees.\n"
                },
                "removeChildByName": {
                    "type": "method",
                    "define": "removeChildByName(${1:#string name},${2:#bool cleanup})",
                    "detail": "Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.\nparam name       A string that identifies a child node.\nparam cleanup   True if all running actions and callbacks on the child node will be cleanup, false otherwise.\n"
                },
                "runAction": {
                    "type": "method",
                    "define": "runAction(${1:#cc.Action action})",
                    "detail": "Executes an action, and returns the action that is executed.\nThis node becomes the action's target. Refer to Action::getTarget().\nwarning Actions don't retain their target.\nparam action An Action pointer.\n"
                },
                "setPositionY": {
                    "type": "method",
                    "define": "setPositionY(${1:#float y})",
                    "detail": " Sets the y coordinate of the node in its parent's coordinate system.\nparam y The y coordinate of the node.\n"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()",
                    "detail": " Returns a string that is used to identify the node.\nreturn A string that identifies the node.\nsince v3.2\n"
                },
                "removeChild": {
                    "type": "method",
                    "define": "removeChild(${1:#cc.Node child},${2:#bool cleanup})",
                    "detail": "Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.\nparam child     The child node which will be removed.\nparam cleanup   True if all running actions and callbacks on the child node will be cleanup, false otherwise.\n"
                },
                "setCascadeColorEnabled": {
                    "type": "method",
                    "define": "setCascadeColorEnabled(${1:#bool cascadeColorEnabled})",
                    "detail": "If you want node's color affect the children node's color, then set it to true.\nOtherwise, set it to false.\nparam cascadeColorEnabled A boolean value.\n"
                },
                "isCascadeOpacityEnabled": {
                    "type": "method",
                    "define": "isCascadeOpacityEnabled()",
                    "detail": "Whether cascadeOpacity is enabled or not.\nreturn A boolean value.\n"
                },
                "getBoundingBox": {
                    "type": "method",
                    "define": "getBoundingBox()",
                    "detail": "Returns an AABB (axis-aligned bounding-box) in its parent's coordinate system.\nreturn An AABB (axis-aligned bounding-box) in its parent's coordinate system\n"
                },
                "setRotation3D": {
                    "type": "method",
                    "define": "setRotation3D(${1:#vec3_table rotation})",
                    "detail": "Sets the rotation (X,Y,Z) in degrees.\nUseful for 3d rotations.\nwarning The physics body doesn't support this.\nparam rotation The rotation of the node in 3d.\njs NA\n"
                },
                "setEventDispatcher": {
                    "type": "method",
                    "define": "setEventDispatcher(${1:#cc.EventDispatcher dispatcher})",
                    "detail": " Set event dispatcher for scene.\nparam dispatcher The event dispatcher of scene.\n"
                },
                "getNodeToWorldAffineTransform": {
                    "type": "method",
                    "define": "getNodeToWorldAffineTransform()"
                },
                "getEventDispatcher": {
                    "type": "method",
                    "define": "getEventDispatcher()",
                    "detail": " Get the event dispatcher of scene.\nreturn The event dispatcher of scene.\n"
                },
                "getActionByTag": {
                    "type": "method",
                    "define": "getActionByTag(${1:#int tag})",
                    "detail": "Gets an action from the running action list by its tag.\nsee `setTag(int)`, `getTag()`.\nreturn The action object with the given tag.\n"
                },
                "convertToNodeSpace": {
                    "type": "method",
                    "define": "convertToNodeSpace(${1:#vec2_table worldPoint})",
                    "detail": "Converts a Vec2 to node (local) space coordinates. The result is in Points.\nparam worldPoint A given coordinate.\nreturn A point in node (local) space coordinates.\n"
                },
                "getOpacity": {
                    "type": "method",
                    "define": "getOpacity()",
                    "detail": "Return the node's opacity.\nreturn A GLubyte value.\n"
                },
                "getPositionX": {
                    "type": "method",
                    "define": "getPositionX()",
                    "detail": " Gets the x coordinate of the node in its parent's coordinate system.\nreturn The x coordinate of the node.\n"
                },
                "getPositionNormalized": {
                    "type": "method",
                    "define": "getPositionNormalized()",
                    "detail": " Returns the normalized position.\nreturn The normalized position.\n"
                },
                "pause": {
                    "type": "method",
                    "define": "pause()",
                    "detail": "Pauses all scheduled selectors, actions and event listeners.\nThis method is called internally by onExit.\n"
                },
                "getNodeToWorldTransform": {
                    "type": "method",
                    "define": "getNodeToWorldTransform()",
                    "detail": "Returns the world affine transform matrix. The matrix is in Pixels.\nreturn transformation matrix, in pixels.\n"
                },
                "getPhysicsBody": {
                    "type": "method",
                    "define": "getPhysicsBody()"
                },
                "getGLProgram": {
                    "type": "method",
                    "define": "getGLProgram()",
                    "detail": "/ @{/ @name GLProgram\nReturn the GLProgram (shader) currently used for this node.\nreturn The GLProgram (shader) currently used for this node.\n"
                },
                "getTag": {
                    "type": "method",
                    "define": "getTag()",
                    "detail": "Returns a tag that is used to identify the node easily.\nreturn An integer that identifies the node.\nPlease use `getTag()` instead.\n"
                },
                "getSkewY": {
                    "type": "method",
                    "define": "getSkewY()",
                    "detail": "Returns the Y skew angle of the node in degrees.\nsee `setSkewY(float)`\nreturn The Y skew angle of the node in degrees.\n"
                },
                "getNormalizedPosition": {
                    "type": "method",
                    "define": "getNormalizedPosition()"
                },
                "setParent": {
                    "type": "method",
                    "define": "setParent(${1:#cc.Node parent})",
                    "detail": "Sets the parent node.\nparam parent    A pointer to the parent node.\n"
                },
                "updateDisplayedColor": {
                    "type": "method",
                    "define": "updateDisplayedColor(${1:#color3b_table parentColor})",
                    "detail": "Update node's displayed color with its parent color.\nparam parentColor A Color3B color value.\n"
                },
                "removeComponent": {
                    "type": "method",
                    "define": "removeComponent(${1:#string name})",
                    "detail": "@overload self, cc.Component         \n@overload self, string         \n"
                },
                "setPositionX": {
                    "type": "method",
                    "define": "setPositionX(${1:#float x})",
                    "detail": "Gets/Sets x or y coordinate individually for position.\nThese methods are used in Lua and Javascript Bindings\nSets the x coordinate of the node in its parent's coordinate system.\nparam x The x coordinate of the node.\n"
                },
                "getDescription": {
                    "type": "method",
                    "define": "getDescription()",
                    "detail": "Gets the description string. It makes debugging easier.\nreturn A string\njs NA\nlua NA\n"
                },
                "setPositionNormalized": {
                    "type": "method",
                    "define": "setPositionNormalized(${1:#vec2_table position})",
                    "detail": " Sets the position (x,y) using values between 0 and 1.\nThe positions in pixels is calculated like the following:\ncode pseudo code\nvoid setNormalizedPosition(Vec2 pos) {\nSize s = getParent()->getContentSize();\n_position = pos * s;\n}\nendcode\nparam position The normalized position (x,y) of the node, using value between 0 and 1.\n"
                },
                "getPosition3D": {
                    "type": "method",
                    "define": "getPosition3D()",
                    "detail": "Returns the position (X,Y,Z) in its parent's coordinate system.\nreturn The position (X, Y, and Z) in its parent's coordinate system.\njs NA\n"
                },
                "getChildrenCount": {
                    "type": "method",
                    "define": "getChildrenCount()",
                    "detail": "Returns the amount of children.\nreturn The amount of children.\n"
                },
                "setScale": {
                    "type": "method",
                    "define": "setScale(${1:#float scaleX},${2:#float scaleY})",
                    "detail": "@overload self, float, float         \n@overload self, float         \n"
                },
                "addChild": {
                    "type": "method",
                    "define": "addChild(${1:#cc.Node child},${2:#int localZOrder},${3:#string name})",
                    "detail": "@overload self, cc.Node, int         \n@overload self, cc.Node         \n@overload self, cc.Node, int, int         \n@overload self, cc.Node, int, string         \n"
                },
                "getNodeToParentTransform": {
                    "type": "method",
                    "define": "getNodeToParentTransform(${1:#cc.Node ancestor})",
                    "detail": "@overload self, cc.Node         \n@overload self         \n"
                },
                "setRotationSkewY": {
                    "type": "method",
                    "define": "setRotationSkewY(${1:#float rotationY})",
                    "detail": "Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.\nThe difference between `setRotationalSkew()` and `setSkew()` is that the first one simulate Flash's skew functionality,\nwhile the second one uses the real skew function.\n0 is the default rotation angle.\nPositive values rotate node clockwise, and negative values for anti-clockwise.\nparam rotationY    The Y rotation in degrees.\nwarning The physics body doesn't support this.\njs setRotationY\n"
                },
                "draw": {
                    "type": "method",
                    "define": "draw(${1:#cc.Renderer renderer},${2:#mat4_table transform},${3:#unsigned int flags})",
                    "detail": "@overload self         \n@overload self, cc.Renderer, mat4_table, unsigned int         \n"
                },
                "resume": {
                    "type": "method",
                    "define": "resume()",
                    "detail": "Resumes all scheduled selectors, actions and event listeners.\nThis method is called internally by onEnter.\n"
                },
                "sortAllChildren": {
                    "type": "method",
                    "define": "sortAllChildren()",
                    "detail": "Sorts the children array once before drawing, instead of every time when a child is added or reordered.\nThis approach can improves the performance massively.\nnote Don't call this manually unless a child added needs to be removed in the same frame.\n"
                },
                "getContentSize": {
                    "type": "method",
                    "define": "getContentSize()",
                    "detail": "Returns the untransformed size of the node.\nsee `setContentSize(const Size&)`\nreturn The untransformed size of the node.\n"
                },
                "getAnchorPoint": {
                    "type": "method",
                    "define": "getAnchorPoint()",
                    "detail": "Returns the anchor point in percent.\nsee `setAnchorPoint(const Vec2&)`\nreturn The anchor point of node.\n"
                },
                "getAnchorPointInPoints": {
                    "type": "method",
                    "define": "getAnchorPointInPoints()",
                    "detail": "Returns the anchorPoint in absolute pixels.\nwarning You can only read it. If you wish to modify it, use anchorPoint instead.\nsee `getAnchorPoint()`\nreturn The anchor point in absolute pixels.\n"
                },
                "getRotationSkewY": {
                    "type": "method",
                    "define": "getRotationSkewY()",
                    "detail": "Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.\nsee `setRotationSkewY(float)`\nreturn The Y rotation in degrees.\njs getRotationY\n"
                },
                "convertToNodeSpaceAR": {
                    "type": "method",
                    "define": "convertToNodeSpaceAR(${1:#vec2_table worldPoint})",
                    "detail": "Converts a Vec2 to node (local) space coordinates. The result is in Points.\ntreating the returned/received node point as anchor relative.\nparam worldPoint A given coordinate.\nreturn A point in node (local) space coordinates, anchor relative.\n"
                },
                "setGLProgramState": {
                    "type": "method",
                    "define": "setGLProgramState(${1:#cc.GLProgramState glProgramState})",
                    "detail": "Set the GLProgramState for this node.\nparam glProgramState The GLProgramState for this node.\n"
                },
                "getScale": {
                    "type": "method",
                    "define": "getScale()",
                    "detail": "Gets the scale factor of the node,  when X and Y have the same scale factor.\nwarning Assert when `_scaleX != _scaleY`\nsee setScale(float)\nreturn The scale factor of the node.\n"
                },
                "setPosition3D": {
                    "type": "method",
                    "define": "setPosition3D(${1:#vec3_table position})",
                    "detail": "Sets the position (X, Y, and Z) in its parent's coordinate system.\nparam position The position (X, Y, and Z) in its parent's coordinate system.\njs NA\n"
                },
                "setLocalZOrder": {
                    "type": "method",
                    "define": "setLocalZOrder(${1:#int localZOrder})",
                    "detail": "LocalZOrder is the 'key' used to sort the node relative to its siblings.\nThe Node's parent will sort all its children based on the LocalZOrder value.\nIf two nodes have the same LocalZOrder, then the node that was added first to the children's array will be in front of the other node in the array.\nAlso, the Scene Graph is traversed using the \"In-Order\" tree traversal algorithm ( http:en.wikipedia.org/wiki/Tree_traversal#In-order )\nAnd Nodes that have LocalZOrder values < 0 are the \"left\" subtree\nWhile Nodes with LocalZOrder >=0 are the \"right\" subtree.\nsee `setGlobalZOrder`\nsee `setVertexZ`\nparam localZOrder The local Z order value.\n"
                },
                "convertToWorldSpaceAR": {
                    "type": "method",
                    "define": "convertToWorldSpaceAR(${1:#vec2_table nodePoint})",
                    "detail": "Converts a local Vec2 to world space coordinates.The result is in Points.\ntreating the returned/received node point as anchor relative.\nparam nodePoint A given coordinate.\nreturn A point in world space coordinates, anchor relative.\n"
                },
                "updateTransform": {
                    "type": "method",
                    "define": "updateTransform()",
                    "detail": "Calls children's updateTransform() method recursively.\nThis method is moved from Sprite, so it's no longer specific to Sprite.\nAs the result, you apply SpriteBatchNode's optimization on your customed Node.\ne.g., `batchNode->addChild(myCustomNode)`, while you can only addChild(sprite) before.\n"
                },
                "setRotation": {
                    "type": "method",
                    "define": "setRotation(${1:#float rotation})",
                    "detail": "Sets the rotation (angle) of the node in degrees.\n0 is the default rotation angle.\nPositive values rotate node clockwise, and negative values for anti-clockwise.\nparam rotation     The rotation of the node in degrees.\n"
                },
                "stopAction": {
                    "type": "method",
                    "define": "stopAction(${1:#cc.Action action})",
                    "detail": "Stops and removes an action from the running action list.\nparam action    The action object to be removed.\n"
                },
                "convertToWorldSpace": {
                    "type": "method",
                    "define": "convertToWorldSpace(${1:#vec2_table nodePoint})",
                    "detail": "Converts a Vec2 to world space coordinates. The result is in Points.\nparam nodePoint A given coordinate.\nreturn A point in world space coordinates.\n"
                },
                "update": {
                    "type": "method",
                    "define": "update(${1:#float delta})",
                    "detail": "Update method will be called automatically every frame if \"scheduleUpdate\" is called, and the node is \"live\".\nparam delta In seconds.\n"
                },
                "stopAllActionsByTag": {
                    "type": "method",
                    "define": "stopAllActionsByTag(${1:#int tag})",
                    "detail": "Removes all actions from the running action list by its tag.\nparam tag   A tag that indicates the action to be removed.\n"
                },
                "setUserObject": {
                    "type": "method",
                    "define": "setUserObject(${1:#cc.Ref userObject})",
                    "detail": "Returns a user assigned Object.\nSimilar to UserData, but instead of holding a void* it holds an object.\nThe UserObject will be retained once in this method,\nand the previous UserObject (if existed) will be released.\nThe UserObject will be released in Node's destructor.\nparam userObject    A user assigned Object.\n"
                },
                "stopAllActions": {
                    "type": "method",
                    "define": "stopAllActions()",
                    "detail": "Stops and removes all actions from the running action list .\n"
                },
                "getNumberOfRunningActionsByTag": {
                    "type": "method",
                    "define": "getNumberOfRunningActionsByTag(${1:#int tag})",
                    "detail": "Returns the numbers of actions that are running plus the ones that are\nschedule to run (actions in actionsToAdd and actions arrays) with a\nspecific tag.\nComposable actions are counted as 1 action. Example:\nIf you are running 1 Sequence of 7 actions, it will return 1.\nIf you are running 7 Sequences of 2 actions, it will return 7.\nparam  tag The tag that will be searched.\nreturn The number of actions that are running plus the\nones that are schedule to run with specific tag.\n"
                },
                "isIgnoreAnchorPointForPosition": {
                    "type": "method",
                    "define": "isIgnoreAnchorPointForPosition()",
                    "detail": "Gets whether the anchor point will be (0,0) when you position this node.\nsee `setIgnoreAnchorPointForPosition(bool)`\nreturn true if the anchor point will be (0,0) when you position this node.\n"
                },
                "getLocalZOrder": {
                    "type": "method",
                    "define": "getLocalZOrder()",
                    "detail": "Gets the local Z order of this node.\nsee `setLocalZOrder(int)`\nreturn The local (relative to its siblings) Z order.\n"
                },
                "isScheduled": {
                    "type": "method",
                    "define": "isScheduled(${1:#string key})",
                    "detail": "Checks whether a lambda function is scheduled.\nparam key      key of the callback\nreturn Whether the lambda function selector is scheduled.\njs NA\nlua NA\n"
                },
                "setRotationSkewX": {
                    "type": "method",
                    "define": "setRotationSkewX(${1:#float rotationX})",
                    "detail": "Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew.\nThe difference between `setRotationalSkew()` and `setSkew()` is that the first one simulate Flash's skew functionality,\nwhile the second one uses the real skew function.\n0 is the default rotation angle.\nPositive values rotate node clockwise, and negative values for anti-clockwise.\nparam rotationX    The X rotation in degrees which performs a horizontal rotational skew.\nwarning The physics body doesn't support this.\njs setRotationX\n"
                },
                "addComponent": {
                    "type": "method",
                    "define": "addComponent(${1:#cc.Component component})",
                    "detail": "Adds a component.\nparam component A given component.\nreturn True if added success.\n"
                },
                "getParent": {
                    "type": "method",
                    "define": "getParent()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "setOnEnterCallback": {
                    "type": "method",
                    "define": "setOnEnterCallback(${1:#function callback})",
                    "detail": "Set the callback of event onEnter.\nparam callback A std::function<void()> callback.\n"
                },
                "getParentToNodeTransform": {
                    "type": "method",
                    "define": "getParentToNodeTransform()",
                    "detail": "Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates.\nThe matrix is in Pixels.\nreturn The transformation matrix.\n"
                },
                "getScene": {
                    "type": "method",
                    "define": "getScene()",
                    "detail": " Returns the Scene that contains the Node.\nIt returns `nullptr` if the node doesn't belong to any Scene.\nThis function recursively calls parent->getScene() until parent is a Scene object. The results are not cached. It is that the user caches the results in case this functions is being used inside a loop.\nreturn The Scene that contains the node.\n"
                },
                "setName": {
                    "type": "method",
                    "define": "setName(${1:#string name})",
                    "detail": " Changes the name that is used to identify the node easily.\nparam name A string that identifies the node.\nsince v3.2\n"
                },
                "getChildren": {
                    "type": "method",
                    "define": "getChildren()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "getScaleX": {
                    "type": "method",
                    "define": "getScaleX()",
                    "detail": "Returns the scale factor on X axis of this node\nsee setScaleX(float)\nreturn The scale factor on X axis.\n"
                },
                "removeAllComponents": {
                    "type": "method",
                    "define": "removeAllComponents()",
                    "detail": "Removes all components\n"
                },
                "setColor": {
                    "type": "method",
                    "define": "setColor(${1:#color3b_table color})",
                    "detail": "Change the color of node.\nparam color A Color3B color value.\n"
                },
                "getGlobalZOrder": {
                    "type": "method",
                    "define": "getGlobalZOrder()",
                    "detail": "Returns the Node's Global Z Order.\nsee `setGlobalZOrder(int)`\nreturn The node's global Z order\n"
                },
                "stopActionsByFlags": {
                    "type": "method",
                    "define": "stopActionsByFlags(${1:#unsigned int flags})",
                    "detail": "Removes all actions from the running action list by its flags.\nparam flags   A flag field that removes actions based on bitwise AND.\n"
                },
                "getDisplayedOpacity": {
                    "type": "method",
                    "define": "getDisplayedOpacity()",
                    "detail": "Return the node's display opacity.\nThe difference between opacity and displayedOpacity is:\nThe displayedOpacity is what's the final rendering opacity of node.\nreturn A GLubyte value.\n"
                },
                "updateDisplayedOpacity": {
                    "type": "method",
                    "define": "updateDisplayedOpacity(${1:#unsigned char parentOpacity})",
                    "detail": "Update the displayed opacity of node with it's parent opacity;\nparam parentOpacity The opacity of parent node.\n"
                },
                "setIgnoreAnchorPointForPosition": {
                    "type": "method",
                    "define": "setIgnoreAnchorPointForPosition(${1:#bool ignore})",
                    "detail": "Sets whether the anchor point will be (0,0) when you position this node.\nThis is an internal method, only used by Layer and Scene. Don't call it outside framework.\nThe default value is false, while in Layer and Scene are true.\nparam ignore    true if anchor point will be (0,0) when you position this node.\n"
                },
                "removeChildByTag": {
                    "type": "method",
                    "define": "removeChildByTag(${1:#int tag},${2:#bool cleanup})",
                    "detail": "Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.\nparam tag       An integer number that identifies a child node.\nparam cleanup   True if all running actions and callbacks on the child node will be cleanup, false otherwise.\nPlease use `removeChildByName` instead.\n"
                },
                "convertTouchToNodeSpaceAR": {
                    "type": "method",
                    "define": "convertTouchToNodeSpaceAR(${1:#cc.Touch touch})",
                    "detail": "converts a Touch (world coordinates) into a local coordinate. This method is AR (Anchor Relative).\nparam touch A given touch.\nreturn A point in world space coordinates, anchor relative.\n"
                },
                "getGLProgramState": {
                    "type": "method",
                    "define": "getGLProgramState()",
                    "detail": "Return the GLProgramState currently used for this node.\nreturn The GLProgramState currently used for this node.\n"
                },
                "setOpacity": {
                    "type": "method",
                    "define": "setOpacity(${1:#unsigned char opacity})",
                    "detail": "Change node opacity.\nparam opacity A GLubyte opacity value.\n"
                },
                "getChildByName": {
                    "type": "method",
                    "define": "getChildByName(${1:#string name})",
                    "detail": "Gets a child from the container with its name.\nparam name   An identifier to find the child node.\nreturn a Node object whose name equals to the input parameter.\nsince v3.2\n"
                },
                "isVisible": {
                    "type": "method",
                    "define": "isVisible()",
                    "detail": "Determines if the node is visible.\nsee `setVisible(bool)`\nreturn true if the node is visible, false if the node is hidden.\n"
                },
                "setCameraMask": {
                    "type": "method",
                    "define": "setCameraMask(${1:#unsigned short mask},${2:#bool applyChildren})",
                    "detail": "Modify the camera mask for current node.\nIf applyChildren is true, then it will modify the camera mask of its children recursively.\nparam mask A unsigned short bit for mask.\nparam applyChildren A boolean value to determine whether the mask bit should apply to its children or not.\n"
                },
                "setOpacityModifyRGB": {
                    "type": "method",
                    "define": "setOpacityModifyRGB(${1:#bool value})",
                    "detail": "If you want the opacity affect the color property, then set to true.\nparam value A boolean value.\n"
                },
                "updateOrderOfArrival": {
                    "type": "method",
                    "define": "updateOrderOfArrival()",
                    "detail": " !!! ONLY FOR INTERNAL USE\nSets the arrival order when this node has a same ZOrder with other children.\nA node which called addChild subsequently will take a larger arrival order,\nIf two children have the same Z order, the child with larger arrival order will be drawn later.\nwarning This method is used internally for localZOrder sorting, don't change this manually\nparam orderOfArrival   The arrival order.\n"
                },
                "getColor": {
                    "type": "method",
                    "define": "getColor()",
                    "detail": "Query node's color value.\nreturn A Color3B color value.\n"
                },
                "getActionManager": {
                    "type": "method",
                    "define": "getActionManager()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "getScaleZ": {
                    "type": "method",
                    "define": "getScaleZ()",
                    "detail": "Returns the scale factor on Z axis of this node\nsee `setScaleZ(float)`\nreturn The scale factor on Z axis.\n"
                },
                "getCameraMask": {
                    "type": "method",
                    "define": "getCameraMask()",
                    "detail": "get & set camera mask, the node is visible by the camera whose camera flag & node's camera mask is true\n"
                },
                "isRunning": {
                    "type": "method",
                    "define": "isRunning()",
                    "detail": "Returns whether or not the node is \"running\".\nIf the node is running it will accept event callbacks like onEnter(), onExit(), update().\nreturn Whether or not the node is running.\n"
                },
                "setActionManager": {
                    "type": "method",
                    "define": "setActionManager(${1:#cc.ActionManager actionManager})",
                    "detail": "Sets the ActionManager object that is used by all actions.\nwarning If you set a new ActionManager, then previously created actions will be removed.\nparam actionManager     A ActionManager object that is used by all actions.\n"
                },
                "getNodeToParentAffineTransform": {
                    "type": "method",
                    "define": "getNodeToParentAffineTransform(${1:#cc.Node ancestor})",
                    "detail": "@overload self, cc.Node         \n@overload self         \n"
                },
                "getRotationSkewX": {
                    "type": "method",
                    "define": "getRotationSkewX()",
                    "detail": "Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew.\nsee `setRotationSkewX(float)`\nreturn The X rotation in degrees.\njs getRotationX \n"
                },
                "getWorldToNodeTransform": {
                    "type": "method",
                    "define": "getWorldToNodeTransform()",
                    "detail": "Returns the inverse world affine transform matrix. The matrix is in Pixels.\nreturn The transformation matrix.\n"
                },
                "setGlobalZOrder": {
                    "type": "method",
                    "define": "setGlobalZOrder(${1:#float globalZOrder})",
                    "detail": "Defines the order in which the nodes are renderer.\nNodes that have a Global Z Order lower, are renderer first.\nIn case two or more nodes have the same Global Z Order, the order is not guaranteed.\nThe only exception if the Nodes have a Global Z Order == 0. In that case, the Scene Graph order is used.\nBy default, all nodes have a Global Z Order = 0. That means that by default, the Scene Graph order is used to render the nodes.\nGlobal Z Order is useful when you need to render nodes in an order different than the Scene Graph order.\nLimitations: Global Z Order can't be used by Nodes that have SpriteBatchNode as one of their ancestors.\nAnd if ClippingNode is one of the ancestors, then \"global Z order\" will be relative to the ClippingNode.\nsee `setLocalZOrder()`\nsee `setVertexZ()`\nsince v3.0\nparam globalZOrder The global Z order value.\n"
                },
                "_setLocalZOrder": {
                    "type": "method",
                    "define": "_setLocalZOrder(${1:#int z})"
                },
                "setScaleY": {
                    "type": "method",
                    "define": "setScaleY(${1:#float scaleY})",
                    "detail": "Sets the scale (y) of the node.\nIt is a scaling factor that multiplies the height of the node and its children.\nparam scaleY   The scale factor on Y axis.\nwarning The physics body doesn't support this.\n"
                }
            },
            "EaseSineOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "mat4": [
                "createIdentity",
                "createRotation",
                "createRotationZ",
                "createTranslation",
                "decompose",
                "getInversed",
                "multiply",
                "new",
                "setIdentity",
                "transformVector",
                "translate"
            ],
            "312": "p",
            "AsyncTaskPool": {
                "1": "new",
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": "Destroys the async task pool.\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "Returns the shared instance of the async task pool.\n"
                },
                "stopTasks": {
                    "type": "method",
                    "define": "stopTasks(${1:#int type})",
                    "detail": "Stop tasks.\nparam type Task type you want to stop.\n"
                }
            },
            "311": "convertColor",
            "310": "clampf",
            "ControlPotentiometer": {
                "1": "new",
                "potentiometerBegan": {
                    "type": "method",
                    "define": "potentiometerBegan(${1:#vec2_table location})",
                    "detail": " Factorize the event dispatch into these methods. \n"
                },
                "setPreviousLocation": {
                    "type": "method",
                    "define": "setPreviousLocation(${1:#vec2_table var})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#char backgroundFile},${2:#char progressFile},${3:#char thumbFile})",
                    "detail": "Creates potentiometer with a track filename and a progress filename.\n"
                },
                "angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint": {
                    "type": "method",
                    "define": "angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(${1:#vec2_table beginLineA},${2:#vec2_table endLineA},${3:#vec2_table beginLineB},${4:#vec2_table endLineB})",
                    "detail": " Returns the angle in degree between line1 and line2. \n"
                },
                "setMaximumValue": {
                    "type": "method",
                    "define": "setMaximumValue(${1:#float maximumValue})"
                },
                "setProgressTimer": {
                    "type": "method",
                    "define": "setProgressTimer(${1:#cc.ProgressTimer var})"
                },
                "distanceBetweenPointAndPoint": {
                    "type": "method",
                    "define": "distanceBetweenPointAndPoint(${1:#vec2_table point1},${2:#vec2_table point2})",
                    "detail": " Returns the distance between the point1 and point2. \n"
                },
                "setMinimumValue": {
                    "type": "method",
                    "define": "setMinimumValue(${1:#float minimumValue})"
                },
                "setThumbSprite": {
                    "type": "method",
                    "define": "setThumbSprite(${1:#cc.Sprite var})"
                },
                "getMaximumValue": {
                    "type": "method",
                    "define": "getMaximumValue()"
                },
                "getMinimumValue": {
                    "type": "method",
                    "define": "getMinimumValue()"
                },
                "setValue": {
                    "type": "method",
                    "define": "setValue(${1:#float value})"
                },
                "getPreviousLocation": {
                    "type": "method",
                    "define": "getPreviousLocation()"
                },
                "getThumbSprite": {
                    "type": "method",
                    "define": "getThumbSprite()"
                },
                "getProgressTimer": {
                    "type": "method",
                    "define": "getProgressTimer()"
                },
                "getValue": {
                    "type": "method",
                    "define": "getValue()"
                },
                "potentiometerEnded": {
                    "type": "method",
                    "define": "potentiometerEnded(${1:#vec2_table location})"
                },
                "initWithTrackSprite_ProgressTimer_ThumbSprite": {
                    "type": "method",
                    "define": "initWithTrackSprite_ProgressTimer_ThumbSprite(${1:#cc.Sprite trackSprite},${2:#cc.ProgressTimer progressTimer},${3:#cc.Sprite thumbSprite})",
                    "detail": "Initializes a potentiometer with a track sprite and a progress bar.\nparam trackSprite   Sprite, that is used as a background.\nparam progressTimer ProgressTimer, that is used as a progress bar.\n"
                },
                "potentiometerMoved": {
                    "type": "method",
                    "define": "potentiometerMoved(${1:#vec2_table location})"
                }
            },
            "309": "c4f",
            "Skeleton3D": {
                "1": "new",
                "getBoneByName": {
                    "type": "method",
                    "define": "getBoneByName(${1:#string id})"
                },
                "removeAllBones": {
                    "type": "method",
                    "define": "removeAllBones()",
                    "detail": "remove all bones\n"
                },
                "getRootBone": {
                    "type": "method",
                    "define": "getRootBone(${1:#int index})"
                },
                "getBoneCount": {
                    "type": "method",
                    "define": "getBoneCount()",
                    "detail": "get total bone count\n"
                },
                "getBoneByIndex": {
                    "type": "method",
                    "define": "getBoneByIndex(${1:#unsigned int index})",
                    "detail": "get bone\n"
                },
                "getBoneIndex": {
                    "type": "method",
                    "define": "getBoneIndex(${1:#cc.Bone3D bone})",
                    "detail": "get bone index\n"
                },
                "updateBoneMatrix": {
                    "type": "method",
                    "define": "updateBoneMatrix()",
                    "detail": "refresh bone world matrix\n"
                },
                "getRootCount": {
                    "type": "method",
                    "define": "getRootCount()",
                    "detail": "get & set root bone\n"
                },
                "addBone": {
                    "type": "method",
                    "define": "addBone(${1:#cc.Bone3D bone})",
                    "detail": "add bone\n"
                }
            },
            "EaseCubicActionInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "BLACK": [
                "b",
                "g",
                "r"
            ],
            "307": "c3b",
            "Grid3DAction": {
                "getGridRect": {
                    "type": "method",
                    "define": "getGridRect()",
                    "detail": "brief Get the effect grid rect.\nreturn Return the effect grid rect.\n"
                }
            },
            "MenuItemToggle": {
                "1": "create",
                "2": "new",
                "getSelectedIndex": {
                    "type": "method",
                    "define": "getSelectedIndex()",
                    "detail": " Gets the index of the selected item. \n"
                },
                "setSubItems": {
                    "type": "method",
                    "define": "setSubItems(${1:#array_table items})",
                    "detail": " Sets the array that contains the subitems. \n"
                },
                "addSubItem": {
                    "type": "method",
                    "define": "addSubItem(${1:#cc.MenuItem item})",
                    "detail": " Add more menu item. \n"
                },
                "setSelectedIndex": {
                    "type": "method",
                    "define": "setSelectedIndex(${1:#unsigned int index})",
                    "detail": " Sets the index of the selected item. \n"
                },
                "getSelectedItem": {
                    "type": "method",
                    "define": "getSelectedItem()",
                    "detail": " Return the selected item. \n"
                },
                "initWithItem": {
                    "type": "method",
                    "define": "initWithItem(${1:#cc.MenuItem item})",
                    "detail": " Initializes a menu item with a item. \n"
                }
            },
            "EaseBounceIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "303": "Z_COMPRESSION_GZIP",
            "BezierBy": {
                "1": "create",
                "2": "new",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#cc._ccBezierConfig c})",
                    "detail": "initializes the action with a duration and a bezier configuration\nparam t in seconds\n"
                }
            },
            "GLProgram_VERTEX_ATTRIB": [
                "BLEND_INDEX",
                "BLEND_WEIGHT",
                "COLOR",
                "MAX",
                "NORMAL",
                "POSITION",
                "TEX_COORD",
                "TEX_COORD1",
                "TEX_COORD2",
                "TEX_COORD3",
                "TEX_COORD4",
                "TEX_COORD5",
                "TEX_COORD6",
                "TEX_COORD7",
                "TEX_COORDS"
            ],
            "XMLHttpRequest": [
                "collector",
                "abort",
                "getAllResponseHeaders",
                "getResponseHeader",
                "new",
                "open",
                "registerScriptHandler",
                "send",
                "setRequestHeader",
                "unregisterScriptHandler"
            ],
            "301": "XMLHTTPREQUEST_RESPONSE_STRING",
            "ParticleRain": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a rain particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleRain object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a rain particle system.\nreturn An autoreleased ParticleRain object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "EaseInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "1": "new"
            },
            "300": "XMLHTTPREQUEST_RESPONSE_JSON",
            "299": "XMLHTTPREQUEST_RESPONSE_DOCUMENT",
            "CameraBackgroundBrush": {
                "1": "new",
                "createColorBrush": {
                    "type": "method",
                    "define": "createColorBrush(${1:#color4f_table color},${2:#float depth})",
                    "detail": "Creates a color brush\nparam color Color of brush\nparam depth Depth used to clear depth buffer\nreturn Created brush\n"
                },
                "drawBackground": {
                    "type": "method",
                    "define": "drawBackground(${1:#cc.Camera})",
                    "detail": "draw the background\n"
                },
                "getBrushType": {
                    "type": "method",
                    "define": "getBrushType()",
                    "detail": "get brush type\nreturn BrushType\n"
                },
                "createSkyboxBrush": {
                    "type": "method",
                    "define": "createSkyboxBrush(${1:#string positive_x},${2:#string negative_x},${3:#string positive_y},${4:#string negative_y},${5:#string positive_z},${6:#string negative_z})",
                    "detail": " Creates a Skybox brush with 6 textures.\nparam positive_x texture for the right side of the texture cube face.\nparam negative_x texture for the up side of the texture cube face.\nparam positive_y texture for the top side of the texture cube face\nparam negative_y texture for the bottom side of the texture cube face\nparam positive_z texture for the forward side of the texture cube face.\nparam negative_z texture for the rear side of the texture cube face.\nreturn  A new brush inited with given parameters.\n"
                },
                "createDepthBrush": {
                    "type": "method",
                    "define": "createDepthBrush()",
                    "detail": "Creates a depth brush, which clears depth buffer with a given depth.\nparam depth Depth used to clear depth buffer\nreturn Created brush\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "createNoneBrush": {
                    "type": "method",
                    "define": "createNoneBrush()",
                    "detail": "Creates a none brush, it does nothing when clear the background\nreturn Created brush.\n"
                },
                "isValid": {
                    "type": "method",
                    "define": "isValid()"
                }
            },
            "298": "XMLHTTPREQUEST_RESPONSE_BLOB",
            "TransitionPageTurn": {
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#cc.Scene scene},${3:#bool backwards})",
                    "detail": "Creates a base transition with duration and incoming scene.\nIf back is true then the effect is reversed to appear as if the incoming\nscene is being turned from left over the outgoing scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nparam backwards If back is true then the effect is reversed to appear as if the incoming scene is being turned from left over the outgoing scene.\nreturn True if initialize success.\n"
                },
                "1": "new",
                "actionWithSize": {
                    "type": "method",
                    "define": "actionWithSize(${1:#size_table vector})",
                    "detail": " Returns the action that will be performed with size.\nparam vector A given size.\nreturn The action that will be performed.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene},${3:#bool backwards})",
                    "detail": "Creates a base transition with duration and incoming scene.\nIf back is true then the effect is reversed to appear as if the incoming\nscene is being turned from left over the outgoing scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nparam backwards If back is true then the effect is reversed to appear as if the incoming scene is being turned from left over the outgoing scene.\nreturn An autoreleased TransitionPageTurn object.\n"
                }
            },
            "Waves": {
                "1": "new",
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float amplitude})",
                    "detail": "brief Set the amplitude to the effect.\nparam amplitude The value of amplitude will be set.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of the effect.\nreturn Return the amplitude rate of the effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amplitudeRate})",
                    "detail": "brief Set the amplitude rate of the effect.\nparam amplitudeRate The value of amplitude rate will be set.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of the effect.\nreturn Return the amplitude of the effect.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude},${5:#bool horizontal},${6:#bool vertical})",
                    "detail": "brief Initializes the action with amplitude, horizontal sin, vertical sin, grid size, waves count and duration.\nparam duration Specify the duration of the Waves action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the Waves action.\nparam amplitude Specify the amplitude of the Waves action.\nparam horizontal Specify whether waves on horizontal.\nparam vertical Specify whether waves on vertical.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude},${5:#bool horizontal},${6:#bool vertical})",
                    "detail": "brief Create the action with amplitude, horizontal sin, vertical sin, grid size, waves count and duration.\nparam duration Specify the duration of the Waves action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the Waves action.\nparam amplitude Specify the amplitude of the Waves action.\nparam horizontal Specify whether waves on horizontal.\nparam vertical Specify whether waves on vertical.\nreturn If the creation success, return a pointer of Waves action; otherwise, return nil.\n"
                }
            },
            "LabelBMFont": [
                "create",
                "getBlendFunc",
                "getFntFile",
                "getLetter",
                "getString",
                "initWithString",
                "isOpacityModifyRGB",
                "new",
                "setAlignment",
                "setBlendFunc",
                "setFntFile",
                "setLineBreakWithoutSpace",
                "setOpacityModifyRGB",
                "setString",
                "setWidth"
            ],
            "AnimationFrame": {
                "1": "new",
                "clone": {
                    "type": "method",
                    "define": "clone()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.SpriteFrame spriteFrame},${2:#float delayUnits},${3:#map_table userInfo})",
                    "detail": "Creates the animation frame with a spriteframe, number of delay units and a notification user info.\nparam spriteFrame The animation frame with a spriteframe.\nparam delayUnits Number of delay units.\nparam userInfo A notification user info.\nsince 3.0\n"
                },
                "getSpriteFrame": {
                    "type": "method",
                    "define": "getSpriteFrame()",
                    "detail": " Return a SpriteFrameName to be used.\nreturn a SpriteFrameName to be used.\n"
                },
                "initWithSpriteFrame": {
                    "type": "method",
                    "define": "initWithSpriteFrame(${1:#cc.SpriteFrame spriteFrame},${2:#float delayUnits},${3:#map_table userInfo})",
                    "detail": " initializes the animation frame with a spriteframe, number of delay units and a notification user info \n"
                },
                "getUserInfo": {
                    "type": "method",
                    "define": "getUserInfo()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "setSpriteFrame": {
                    "type": "method",
                    "define": "setSpriteFrame(${1:#cc.SpriteFrame frame})",
                    "detail": " Set the SpriteFrame.\nparam frame A SpriteFrame will be used.\n"
                },
                "setUserInfo": {
                    "type": "method",
                    "define": "setUserInfo(${1:#map_table userInfo})",
                    "detail": " Sets user information.\nparam userInfo A dictionary as UserInfo.\n"
                },
                "setDelayUnits": {
                    "type": "method",
                    "define": "setDelayUnits(${1:#float delayUnits})",
                    "detail": " Sets the units of time the frame takes.\nparam delayUnits The units of time the frame takes.\n"
                },
                "getDelayUnits": {
                    "type": "method",
                    "define": "getDelayUnits()",
                    "detail": " Gets the units of time the frame takes.\nreturn The units of time the frame takes.\n"
                }
            },
            "293": "WEBSOCKET_STATE_CLOSED",
            "291": "WEBSOCKET_MESSAGE",
            "289": "WEBSOCKET_CLOSE",
            "288": "Vertex3F",
            "EaseBounceOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "ControlButton": {
                "1": "new",
                "setTitleColorForState": {
                    "type": "method",
                    "define": "setTitleColorForState(${1:#color3b_table color},${2:#int state})",
                    "detail": "Sets the color of the title to use for the specified state.\nparam color The color of the title to use for the specified state.\nparam state The state that uses the specified color. The values are described\nin \"CCControlState\".\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node label},${2:#ccui.Scale9Sprite backgroundSprite},${3:#bool adjustBackGroundSize})",
                    "detail": "@overload self, ccui.Scale9Sprite         \n@overload self         \n@overload self, cc.Node, ccui.Scale9Sprite         \n@overload self, string, string, float         \n@overload self, cc.Node, ccui.Scale9Sprite, bool         \n"
                },
                "setMargins": {
                    "type": "method",
                    "define": "setMargins(${1:#int marginH},${2:#int marginV})"
                },
                "doesAdjustBackgroundImage": {
                    "type": "method",
                    "define": "doesAdjustBackgroundImage()",
                    "detail": " Adjust the background image. YES by default. If the property is set to NO, the\nbackground will use the preferred size of the background image. \n"
                },
                "getTitleTTFSizeForState": {
                    "type": "method",
                    "define": "getTitleTTFSizeForState(${1:#int state})"
                },
                "getTitleLabelForState": {
                    "type": "method",
                    "define": "getTitleLabelForState(${1:#int state})",
                    "detail": "Returns the title label used for a state.\nparam state The state that uses the title label. Possible values are described\nin \"CCControlState\".\n"
                },
                "getCurrentTitle": {
                    "type": "method",
                    "define": "getCurrentTitle()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "isPushed": {
                    "type": "method",
                    "define": "isPushed()"
                },
                "getTitleForState": {
                    "type": "method",
                    "define": "getTitleForState(${1:#int state})",
                    "detail": "Returns the title used for a state.\nparam state The state that uses the title. Possible values are described in\n\"CCControlState\".\nreturn The title for the specified state.\n"
                },
                "initWithTitleAndFontNameAndFontSize": {
                    "type": "method",
                    "define": "initWithTitleAndFontNameAndFontSize(${1:#string title},${2:#string fontName},${3:#float fontSize})"
                },
                "getBackgroundSpriteForState": {
                    "type": "method",
                    "define": "getBackgroundSpriteForState(${1:#int state})",
                    "detail": "Returns the background sprite used for a state.\nparam state The state that uses the background sprite. Possible values are\ndescribed in \"CCControlState\".\n"
                },
                "setLabelAnchorPoint": {
                    "type": "method",
                    "define": "setLabelAnchorPoint(${1:#vec2_table var})"
                },
                "setScaleRatio": {
                    "type": "method",
                    "define": "setScaleRatio(${1:#float var})"
                },
                "initWithBackgroundSprite": {
                    "type": "method",
                    "define": "initWithBackgroundSprite(${1:#ccui.Scale9Sprite sprite})"
                },
                "setTitleBMFontForState": {
                    "type": "method",
                    "define": "setTitleBMFontForState(${1:#string fntFile},${2:#int state})",
                    "detail": "Sets the font of the label, changes the label to a BMFont if necessary.\nparam fntFile The name of the font to change to\nparam state The state that uses the specified fntFile. The values are described\nin \"CCControlState\".\n"
                },
                "getPreferredSize": {
                    "type": "method",
                    "define": "getPreferredSize()"
                },
                "getTitleColorForState": {
                    "type": "method",
                    "define": "getTitleColorForState(${1:#int state})",
                    "detail": "Returns the title color used for a state.\nparam state The state that uses the specified color. The values are described\nin \"CCControlState\".\nreturn The color of the title for the specified state.\n"
                },
                "setPreferredSize": {
                    "type": "method",
                    "define": "setPreferredSize(${1:#size_table var})"
                },
                "getScaleRatio": {
                    "type": "method",
                    "define": "getScaleRatio()"
                },
                "getBackgroundSprite": {
                    "type": "method",
                    "define": "getBackgroundSprite()"
                },
                "getTitleTTFForState": {
                    "type": "method",
                    "define": "getTitleTTFForState(${1:#int state})"
                },
                "setAdjustBackgroundImage": {
                    "type": "method",
                    "define": "setAdjustBackgroundImage(${1:#bool adjustBackgroundImage})"
                },
                "setZoomOnTouchDown": {
                    "type": "method",
                    "define": "setZoomOnTouchDown(${1:#bool var})"
                },
                "setTitleTTFForState": {
                    "type": "method",
                    "define": "setTitleTTFForState(${1:#string fntFile},${2:#int state})"
                },
                "setTitleLabelForState": {
                    "type": "method",
                    "define": "setTitleLabelForState(${1:#cc.Node label},${2:#int state})",
                    "detail": "Sets the title label to use for the specified state.\nIf a property is not specified for a state, the default is to use\nthe ButtonStateNormal value.\nparam label The title label to use for the specified state.\nparam state The state that uses the specified title. The values are described\nin \"CCControlState\".\n"
                },
                "getVerticalMargin": {
                    "type": "method",
                    "define": "getVerticalMargin()"
                },
                "setTitleForState": {
                    "type": "method",
                    "define": "setTitleForState(${1:#string title},${2:#int state})",
                    "detail": "Sets the title string to use for the specified state.\nIf a property is not specified for a state, the default is to use\nthe ButtonStateNormal value.\nparam title The title string to use for the specified state.\nparam state The state that uses the specified title. The values are described\nin \"CCControlState\".\n"
                },
                "getZoomOnTouchDown": {
                    "type": "method",
                    "define": "getZoomOnTouchDown()"
                },
                "getHorizontalOrigin": {
                    "type": "method",
                    "define": "getHorizontalOrigin()"
                },
                "getTitleBMFontForState": {
                    "type": "method",
                    "define": "getTitleBMFontForState(${1:#int state})"
                },
                "setBackgroundSprite": {
                    "type": "method",
                    "define": "setBackgroundSprite(${1:#ccui.Scale9Sprite var})"
                },
                "getLabelAnchorPoint": {
                    "type": "method",
                    "define": "getLabelAnchorPoint()"
                },
                "getTitleLabel": {
                    "type": "method",
                    "define": "getTitleLabel()"
                },
                "initWithLabelAndBackgroundSprite": {
                    "type": "method",
                    "define": "initWithLabelAndBackgroundSprite(${1:#cc.Node label},${2:#ccui.Scale9Sprite backgroundSprite},${3:#bool adjustBackGroundSize})"
                },
                "getCurrentTitleColor": {
                    "type": "method",
                    "define": "getCurrentTitleColor()"
                },
                "setBackgroundSpriteFrameForState": {
                    "type": "method",
                    "define": "setBackgroundSpriteFrameForState(${1:#cc.SpriteFrame spriteFrame},${2:#int state})",
                    "detail": "Sets the background spriteFrame to use for the specified button state.\nparam spriteFrame The background spriteFrame to use for the specified state.\nparam state The state that uses the specified image. The values are described\nin \"CCControlState\".\n"
                },
                "setTitleLabel": {
                    "type": "method",
                    "define": "setTitleLabel(${1:#cc.Node var})"
                },
                "setTitleTTFSizeForState": {
                    "type": "method",
                    "define": "setTitleTTFSizeForState(${1:#float size},${2:#int state})"
                },
                "setBackgroundSpriteForState": {
                    "type": "method",
                    "define": "setBackgroundSpriteForState(${1:#ccui.Scale9Sprite sprite},${2:#int state})",
                    "detail": "Sets the background sprite to use for the specified button state.\nparam sprite The background sprite to use for the specified state.\nparam state The state that uses the specified image. The values are described\nin \"CCControlState\".\n"
                }
            },
            "CameraFlag": [
                "DEFAULT",
                "USER1",
                "USER2",
                "USER3",
                "USER4",
                "USER5",
                "USER6",
                "USER7",
                "USER8"
            ],
            "ControlColourPicker": {
                "1": "new",
                "getHuePicker": {
                    "type": "method",
                    "define": "getHuePicker()"
                },
                "setcolourPicker": {
                    "type": "method",
                    "define": "setcolourPicker(${1:#cc.ControlSaturationBrightnessPicker var})"
                },
                "hueSliderValueChanged": {
                    "type": "method",
                    "define": "hueSliderValueChanged(${1:#cc.Ref sender},${2:#int controlEvent})"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getcolourPicker": {
                    "type": "method",
                    "define": "getcolourPicker()"
                },
                "colourSliderValueChanged": {
                    "type": "method",
                    "define": "colourSliderValueChanged(${1:#cc.Ref sender},${2:#int controlEvent})"
                },
                "setBackground": {
                    "type": "method",
                    "define": "setBackground(${1:#cc.Sprite var})"
                },
                "getBackground": {
                    "type": "method",
                    "define": "getBackground()"
                },
                "setHuePicker": {
                    "type": "method",
                    "define": "setHuePicker(${1:#cc.ControlHuePicker var})"
                }
            },
            "286": "VERTICAL_TEXT_ALIGNMENT_CENTER",
            "285": "VERTICAL_TEXT_ALIGNMENT_BOTTOM",
            "TransitionSplitRows": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionSplitRows object.\n"
                },
                "1": "new"
            },
            "283": "VERTEX_ATTRIB_TEX_COORD",
            "282": "VERTEX_ATTRIB_POSITION",
            "281": "VERTEX_ATTRIB_MAX",
            "280": "VERTEX_ATTRIB_FLAG_TEX_COORDS",
            "ScaleBy": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float sx},${3:#float sy},${4:#float sz})",
                    "detail": "@overload self, float, float, float         \n@overload self, float, float         \n@overload self, float, float, float, float         \n"
                },
                "1": "new"
            },
            "LabelTTF": [
                "create",
                "createWithFontDefinition",
                "disableShadow",
                "disableStroke",
                "enableShadow",
                "enableStroke",
                "getBlendFunc",
                "getDimensions",
                "getFontName",
                "getFontSize",
                "getHorizontalAlignment",
                "getString",
                "getTextDefinition",
                "getVerticalAlignment",
                "initWithString",
                "initWithStringAndTextDefinition",
                "new",
                "setBlendFunc",
                "setDimensions",
                "setFlippedX",
                "setFlippedY",
                "setFontFillColor",
                "setFontName",
                "setFontSize",
                "setHorizontalAlignment",
                "setString",
                "setTextDefinition",
                "setVerticalAlignment"
            ],
            "Director": {
                "1": "endToLua",
                "getNotificationNode": {
                    "type": "method",
                    "define": "getNotificationNode()",
                    "detail": " This object will be visited after the main scene is visited.\nThis object MUST implement the \"visit\" function.\nUseful to hook a notification object, like Notifications (http:github.com/manucorporat/CCNotifications)\nsince v0.99.5\n"
                },
                "multiplyProjectionMatrix": {
                    "type": "method",
                    "define": "multiplyProjectionMatrix(${1:#mat4_table mat},${2:#unsigned long index})",
                    "detail": "Multiplies a matrix to the top of projection matrix stack.\nparam mat The matrix that to be multiplied.\nparam index The index of projection matrix stack.\njs NA\n"
                },
                "setAnimationInterval": {
                    "type": "method",
                    "define": "setAnimationInterval(${1:#float interval})",
                    "detail": " Sets the FPS value. FPS = 1/interval. \n"
                },
                "popScene": {
                    "type": "method",
                    "define": "popScene()",
                    "detail": "Pops out a scene from the stack.\nThis scene will replace the running one.\nThe running scene will be deleted. If there are no more scenes in the stack the execution is terminated.\nONLY call it if there is a running scene.\n"
                },
                "getFrameRate": {
                    "type": "method",
                    "define": "getFrameRate()",
                    "detail": "Gets Frame Rate.\njs NA\n"
                },
                "initProjectionMatrixStack": {
                    "type": "method",
                    "define": "initProjectionMatrixStack(${1:#unsigned long stackCount})",
                    "detail": "Init the projection matrix stack.\nparam stackCount The size of projection matrix stack.\njs NA\n"
                },
                "startAnimation": {
                    "type": "method",
                    "define": "startAnimation()",
                    "detail": " The main loop is triggered again.\nCall this function only if [stopAnimation] was called earlier.\nwarning Don't call this function to start the main loop. To run the main loop call runWithScene.\n"
                },
                "getZEye": {
                    "type": "method",
                    "define": "getZEye()",
                    "detail": "Gets the distance between camera and near clipping frame.\nIt is correct for default camera that near clipping frame is same as the screen.\n"
                },
                "isValid": {
                    "type": "method",
                    "define": "isValid()",
                    "detail": "returns whether or not the Director is in a valid state\n"
                },
                "convertToGL": {
                    "type": "method",
                    "define": "convertToGL(${1:#vec2_table point})",
                    "detail": "Converts a screen coordinate to an OpenGL coordinate.\nUseful to convert (multi) touch coordinates to the current layout (portrait or landscape).\n"
                },
                "drawScene": {
                    "type": "method",
                    "define": "drawScene()",
                    "detail": " Draw the scene.\nThis method is called every frame. Don't call it manually.\n"
                },
                "replaceScene": {
                    "type": "method",
                    "define": "replaceScene(${1:#cc.Scene scene})",
                    "detail": " Replaces the running scene with a new one. The running scene is terminated.\nONLY call it if there is a running scene.\njs NA\n"
                },
                "setActionManager": {
                    "type": "method",
                    "define": "setActionManager(${1:#cc.ActionManager actionManager})",
                    "detail": " Sets the ActionManager associated with this director.\nsince v2.0\n"
                },
                "resume": {
                    "type": "method",
                    "define": "resume()",
                    "detail": " Resumes the paused scene.\nThe scheduled timers will be activated again.\nThe \"delta time\" will be 0 (as if the game wasn't paused).\n"
                },
                "setScheduler": {
                    "type": "method",
                    "define": "setScheduler(${1:#cc.Scheduler scheduler})",
                    "detail": " Sets the Scheduler associated with this director.\nsince v2.0\n"
                },
                "getTotalFrames": {
                    "type": "method",
                    "define": "getTotalFrames()",
                    "detail": " How many frames were called since the director started \n"
                },
                "runWithScene": {
                    "type": "method",
                    "define": "runWithScene(${1:#cc.Scene scene})",
                    "detail": "Enters the Director's main loop with the given Scene.\nCall it to run only your FIRST scene.\nDon't call it if there is already a running scene.\nIt will call pushScene: and then it will call startAnimation\njs NA\n"
                },
                "setNextDeltaTimeZero": {
                    "type": "method",
                    "define": "setNextDeltaTimeZero(${1:#bool nextDeltaTimeZero})",
                    "detail": "Sets the delta time between current frame and next frame is 0.\nThis value will be used in Schedule, and will affect all functions that are using frame delta time, such as Actions.\nThis value will take effect only one time.\n"
                },
                "setAlphaBlending": {
                    "type": "method",
                    "define": "setAlphaBlending(${1:#bool on})",
                    "detail": " Enables/disables OpenGL alpha blending. \n"
                },
                "setNotificationNode": {
                    "type": "method",
                    "define": "setNotificationNode(${1:#cc.Node node})",
                    "detail": "Sets the notification node.\nsee Director::getNotificationNode()\n"
                },
                "getScheduler": {
                    "type": "method",
                    "define": "getScheduler()",
                    "detail": " Gets the Scheduler associated with this director.\nsince v2.0\n"
                },
                "loadIdentityMatrix": {
                    "type": "method",
                    "define": "loadIdentityMatrix(${1:#int type})",
                    "detail": " Adds an identity matrix to the top of specified type of matrix stack.\njs NA\n"
                },
                "isPaused": {
                    "type": "method",
                    "define": "isPaused()",
                    "detail": " Whether or not the Director is paused. \n"
                },
                "getMatrix": {
                    "type": "method",
                    "define": "getMatrix(${1:#int type})",
                    "detail": "Gets the top matrix of specified type of matrix stack.\njs NA\n"
                },
                "purgeCachedData": {
                    "type": "method",
                    "define": "purgeCachedData()",
                    "detail": " Removes all cocos2d cached data.\nIt will purge the TextureCache, SpriteFrameCache, LabelBMFont cache\nsince v0.99.3\n"
                },
                "convertToUI": {
                    "type": "method",
                    "define": "convertToUI(${1:#vec2_table point})",
                    "detail": "Converts an OpenGL coordinate to a screen coordinate.\nUseful to convert node points to window points for calls such as glScissor.\n"
                },
                "multiplyMatrix": {
                    "type": "method",
                    "define": "multiplyMatrix(${1:#int type},${2:#mat4_table mat})",
                    "detail": "Multiplies a matrix to the top of specified type of matrix stack.\nparam type Matrix type.\nparam mat The matrix that to be multiplied.\njs NA\n"
                },
                "getRunningScene": {
                    "type": "method",
                    "define": "getRunningScene()",
                    "detail": " Gets current running Scene. Director can only run one Scene at a time. \n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "resetMatrixStack": {
                    "type": "method",
                    "define": "resetMatrixStack()",
                    "detail": "Clear all types of matrix stack, and add identity matrix to these matrix stacks.\njs NA\n"
                },
                "getOpenGLView": {
                    "type": "method",
                    "define": "getOpenGLView()",
                    "detail": "Get the GLView.\nlua NA\n"
                },
                "pushProjectionMatrix": {
                    "type": "method",
                    "define": "pushProjectionMatrix(${1:#unsigned long index})",
                    "detail": "Clones a projection matrix and put it to the top of projection matrix stack.\nparam index The index of projection matrix stack.\njs NA\n"
                },
                "restart": {
                    "type": "method",
                    "define": "restart()"
                },
                "isSendCleanupToScene": {
                    "type": "method",
                    "define": "isSendCleanupToScene()",
                    "detail": " Whether or not the replaced scene will receive the cleanup message.\nIf the new scene is pushed, then the old scene won't receive the \"cleanup\" message.\nIf the new scene replaces the old one, the it will receive the \"cleanup\" message.\nsince v0.99.0\n"
                },
                "setGLDefaultValues": {
                    "type": "method",
                    "define": "setGLDefaultValues()",
                    "detail": " Sets the OpenGL default values.\nIt will enable alpha blending, disable depth test.\njs NA\n"
                },
                "setDisplayStats": {
                    "type": "method",
                    "define": "setDisplayStats(${1:#bool displayStats})",
                    "detail": " Display the FPS on the bottom-left corner of the screen. \n"
                },
                "getDeltaTime": {
                    "type": "method",
                    "define": "getDeltaTime()"
                },
                "setContentScaleFactor": {
                    "type": "method",
                    "define": "setContentScaleFactor(${1:#float scaleFactor})",
                    "detail": " The size in pixels of the surface. It could be different than the screen size.\nHigh-res devices might have a higher surface size than the screen size.\nOnly available when compiled using SDK >= 4.0.\nsince v0.99.4\n"
                },
                "loadProjectionIdentityMatrix": {
                    "type": "method",
                    "define": "loadProjectionIdentityMatrix(${1:#unsigned long index})",
                    "detail": " Adds an identity matrix to the top of projection matrix stack.\nparam index The index of projection matrix stack.\njs NA\n"
                },
                "popToRootScene": {
                    "type": "method",
                    "define": "popToRootScene()",
                    "detail": "Pops out all scenes from the stack until the root scene in the queue.\nThis scene will replace the running one.\nInternally it will call `popToSceneStackLevel(1)`.\n"
                },
                "getSecondsPerFrame": {
                    "type": "method",
                    "define": "getSecondsPerFrame()",
                    "detail": " Get seconds per frame. \n"
                },
                "isDisplayStats": {
                    "type": "method",
                    "define": "isDisplayStats()",
                    "detail": " Whether or not displaying the FPS on the bottom-left corner of the screen. \n"
                },
                "isNextDeltaTimeZero": {
                    "type": "method",
                    "define": "isNextDeltaTimeZero()",
                    "detail": " Whether or not `_nextDeltaTimeZero` is set to 0. \n"
                },
                "setEventDispatcher": {
                    "type": "method",
                    "define": "setEventDispatcher(${1:#cc.EventDispatcher dispatcher})",
                    "detail": " Sets the EventDispatcher associated with this director.\nsince v3.0\njs NA\n"
                },
                "getContentScaleFactor": {
                    "type": "method",
                    "define": "getContentScaleFactor()",
                    "detail": "Gets content scale factor.\nsee Director::setContentScaleFactor()\n"
                },
                "stopAnimation": {
                    "type": "method",
                    "define": "stopAnimation()",
                    "detail": " Stops the animation. Nothing will be drawn. The main loop won't be triggered anymore.\nIf you don't want to pause your animation call [pause] instead.\n"
                },
                "getVisibleSize": {
                    "type": "method",
                    "define": "getVisibleSize()",
                    "detail": "Returns visible size of the OpenGL view in points.\nThe value is equal to `Director::getWinSize()` if don't invoke `GLView::setDesignResolutionSize()`.\n"
                },
                "getEventDispatcher": {
                    "type": "method",
                    "define": "getEventDispatcher()",
                    "detail": " Gets the EventDispatcher associated with this director.\nsince v3.0\njs NA\n"
                },
                "pushScene": {
                    "type": "method",
                    "define": "pushScene(${1:#cc.Scene scene})",
                    "detail": "Suspends the execution of the running scene, pushing it on the stack of suspended scenes.\nThe new scene will be executed.\nTry to avoid big stacks of pushed scenes to reduce memory allocation. \nONLY call it if there is a running scene.\n"
                },
                "setProjection": {
                    "type": "method",
                    "define": "setProjection(${1:#int projection})",
                    "detail": " Sets OpenGL projection. \n"
                },
                "setOpenGLView": {
                    "type": "method",
                    "define": "setOpenGLView(${1:#cc.GLView openGLView})",
                    "detail": "Sets the GLView. \nlua NA\n"
                },
                "getWinSizeInPixels": {
                    "type": "method",
                    "define": "getWinSizeInPixels()",
                    "detail": " Returns the size of the OpenGL view in pixels. \n"
                },
                "setClearColor": {
                    "type": "method",
                    "define": "setClearColor(${1:#color4f_table clearColor})",
                    "detail": " Sets clear values for the color buffers,\nvalue range of each element is [0.0, 1.0].\njs NA\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "Returns a shared instance of the director. \njs _getInstance\n"
                },
                "popProjectionMatrix": {
                    "type": "method",
                    "define": "popProjectionMatrix(${1:#unsigned long index})",
                    "detail": " Pops the top matrix of the projection matrix stack.\nparam index The index of projection matrix stack.\njs NA\n"
                },
                "getWinSize": {
                    "type": "method",
                    "define": "getWinSize()",
                    "detail": " Returns the size of the OpenGL view in points. \n"
                },
                "getActionManager": {
                    "type": "method",
                    "define": "getActionManager()",
                    "detail": " Gets the ActionManager associated with this director.\nsince v2.0\n"
                },
                "popToSceneStackLevel": {
                    "type": "method",
                    "define": "popToSceneStackLevel(${1:#int level})",
                    "detail": " Pops out all scenes from the stack until it reaches `level`.\nIf level is 0, it will end the director.\nIf level is 1, it will pop all scenes until it reaches to root scene.\nIf level is <= than the current stack level, it won't do anything.\n"
                },
                "popMatrix": {
                    "type": "method",
                    "define": "popMatrix(${1:#int type})",
                    "detail": " Pops the top matrix of the specified type of matrix stack.\njs NA\n"
                },
                "setDefaultValues": {
                    "type": "method",
                    "define": "setDefaultValues()",
                    "detail": " Sets the default values based on the Configuration info. \n"
                },
                "pause": {
                    "type": "method",
                    "define": "pause()",
                    "detail": " Pauses the running scene.\nThe running scene will be _drawed_ but all scheduled timers will be paused.\nWhile paused, the draw rate will be 4 FPS to reduce CPU consumption.\n"
                },
                "getVisibleOrigin": {
                    "type": "method",
                    "define": "getVisibleOrigin()",
                    "detail": " Returns visible origin coordinate of the OpenGL view in points. \n"
                },
                "getAnimationInterval": {
                    "type": "method",
                    "define": "getAnimationInterval()",
                    "detail": " Gets the FPS value. \n"
                },
                "getTextureCache": {
                    "type": "method",
                    "define": "getTextureCache()"
                },
                "mainLoop": {
                    "type": "method",
                    "define": "mainLoop()"
                },
                "pushMatrix": {
                    "type": "method",
                    "define": "pushMatrix(${1:#int type})",
                    "detail": "Clones a specified type matrix and put it to the top of specified type of matrix stack.\njs NA\n"
                },
                "loadProjectionMatrix": {
                    "type": "method",
                    "define": "loadProjectionMatrix(${1:#mat4_table mat},${2:#unsigned long index})",
                    "detail": "Adds a matrix to the top of projection matrix stack.\nparam mat The matrix that to be added.\nparam index The index of projection matrix stack.\njs NA\n"
                },
                "getConsole": {
                    "type": "method",
                    "define": "getConsole()",
                    "detail": " Returns the Console associated with this director.\nsince v3.0\njs NA\n"
                },
                "setViewport": {
                    "type": "method",
                    "define": "setViewport()",
                    "detail": " Sets the glViewport.\n"
                },
                "loadMatrix": {
                    "type": "method",
                    "define": "loadMatrix(${1:#int type},${2:#mat4_table mat})",
                    "detail": "Adds a matrix to the top of specified type of matrix stack.\nparam type Matrix type.\nparam mat The matrix that to be added.\njs NA\n"
                },
                "setDepthTest": {
                    "type": "method",
                    "define": "setDepthTest(${1:#bool on})",
                    "detail": " Enables/disables OpenGL depth test. \n"
                }
            },
            "278": "VERTEX_ATTRIB_FLAG_POSITION",
            "AABB": [
                "collector",
                "containPoint",
                "getCenter",
                "getCorners",
                "isEmpty",
                "new",
                "reset",
                "set",
                "transform",
                "updateMinMax"
            ],
            "277": "VERTEX_ATTRIB_FLAG_NONE",
            "Sprite3D": {
                "1": "createAsync",
                "2": "getAABB",
                "setForceDepthWrite": {
                    "type": "method",
                    "define": "setForceDepthWrite(${1:#bool value})",
                    "detail": "Force to write to depth buffer, this is useful if you want to achieve effects like fading.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "setMaterial": {
                    "type": "method",
                    "define": "setMaterial(${1:#cc.Material material},${2:#int meshIndex})",
                    "detail": "@overload self, cc.Material, int         \n@overload self, cc.Material         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string modelPath},${2:#string texturePath})",
                    "detail": "@overload self, string         \n@overload self         \n@overload self, string, string         \n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                },
                "getMeshCount": {
                    "type": "method",
                    "define": "getMeshCount()",
                    "detail": " get mesh count \n"
                },
                "removeAllAttachNode": {
                    "type": "method",
                    "define": "removeAllAttachNode()",
                    "detail": "remove all attach nodes\n"
                },
                "getSkeleton": {
                    "type": "method",
                    "define": "getSkeleton()"
                },
                "getMeshByIndex": {
                    "type": "method",
                    "define": "getMeshByIndex(${1:#int index})",
                    "detail": "get Mesh by index\n"
                },
                "getLightMask": {
                    "type": "method",
                    "define": "getLightMask()"
                },
                "getAttachNode": {
                    "type": "method",
                    "define": "getAttachNode(${1:#string boneName})",
                    "detail": "get AttachNode by bone name, return nullptr if not exist\n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#string texFile})",
                    "detail": "@overload self, cc.Texture2D         \n@overload self, string         \n"
                },
                "setLightMask": {
                    "type": "method",
                    "define": "setLightMask(${1:#unsigned int mask})",
                    "detail": " light mask getter & setter, light works only when _lightmask & light's flag is true, default value of _lightmask is 0xffff \n"
                },
                "setForce2DQueue": {
                    "type": "method",
                    "define": "setForce2DQueue(${1:#bool force2D})",
                    "detail": "force set this Sprite3D to 2D render queue\n"
                },
                "setCullFaceEnabled": {
                    "type": "method",
                    "define": "setCullFaceEnabled(${1:#bool enable})"
                },
                "setCullFace": {
                    "type": "method",
                    "define": "setCullFace(${1:#unsigned int cullFace})"
                },
                "getMaterial": {
                    "type": "method",
                    "define": "getMaterial(${1:#int meshIndex})",
                    "detail": " Adds a new material to a particular mesh of the sprite.\nmeshIndex is the mesh that will be applied to.\nif meshIndex == -1, then it will be applied to all the meshes that belong to the sprite.\n"
                },
                "genMaterial": {
                    "type": "method",
                    "define": "genMaterial()",
                    "detail": "generate default material\n"
                },
                "getMeshes": {
                    "type": "method",
                    "define": "getMeshes()",
                    "detail": "Get meshes used in sprite 3d\n"
                },
                "getMeshByName": {
                    "type": "method",
                    "define": "getMeshByName(${1:#string name})",
                    "detail": "get Mesh by Name, it returns the first one if there are more than one mesh with the same name \n"
                },
                "removeAttachNode": {
                    "type": "method",
                    "define": "removeAttachNode(${1:#string boneName})",
                    "detail": "remove attach node\n"
                },
                "isForceDepthWrite": {
                    "type": "method",
                    "define": "isForceDepthWrite()"
                },
                "getMesh": {
                    "type": "method",
                    "define": "getMesh()",
                    "detail": "get mesh\n"
                }
            },
            "EventMouse": {
                "setScrollData": {
                    "type": "method",
                    "define": "setScrollData(${1:#float scrollX},${2:#float scrollY})",
                    "detail": " Set mouse scroll data.\nparam scrollX The scroll data of x axis.\nparam scrollY The scroll data of y axis.\n"
                },
                "getLocationInView": {
                    "type": "method",
                    "define": "getLocationInView()",
                    "detail": " Returns the current touch location in screen coordinates.\nreturn The current touch location in screen coordinates.\n"
                },
                "getCursorY": {
                    "type": "method",
                    "define": "getCursorY()",
                    "detail": " Get the cursor position of y axis.\nreturn The y coordinate of cursor position.\njs getLocationY\n"
                },
                "setMouseButton": {
                    "type": "method",
                    "define": "setMouseButton(${1:#int button})",
                    "detail": " Set mouse button.\nparam button a given mouse button.\njs setButton\n"
                },
                "setCursorPosition": {
                    "type": "method",
                    "define": "setCursorPosition(${1:#float x},${2:#float y})",
                    "detail": " Set the cursor position.\nparam x The x coordinate of cursor position.\nparam y The y coordinate of cursor position.\njs setLocation\n"
                },
                "getScrollY": {
                    "type": "method",
                    "define": "getScrollY()",
                    "detail": " Get mouse scroll data of y axis.\nreturn The scroll data of y axis.\n"
                },
                "getMouseButton": {
                    "type": "method",
                    "define": "getMouseButton()",
                    "detail": " Get mouse button.\nreturn The mouse button.\njs getButton\n"
                },
                "1": "new",
                "getCursorX": {
                    "type": "method",
                    "define": "getCursorX()",
                    "detail": " Get the cursor position of x axis.\nreturn The x coordinate of cursor position.\njs getLocationX\n"
                },
                "getDelta": {
                    "type": "method",
                    "define": "getDelta()",
                    "detail": " Returns the delta of 2 current touches locations in screen coordinates.\nreturn The delta of 2 current touches locations in screen coordinates.\n"
                },
                "getStartLocationInView": {
                    "type": "method",
                    "define": "getStartLocationInView()",
                    "detail": " Returns the start touch location in screen coordinates.\nreturn The start touch location in screen coordinates.\njs NA\n"
                },
                "getScrollX": {
                    "type": "method",
                    "define": "getScrollX()",
                    "detail": " Get mouse scroll data of x axis.\nreturn The scroll data of x axis.\n"
                },
                "getStartLocation": {
                    "type": "method",
                    "define": "getStartLocation()",
                    "detail": " Returns the start touch location in OpenGL coordinates.\nreturn The start touch location in OpenGL coordinates.\njs NA\n"
                },
                "getLocation": {
                    "type": "method",
                    "define": "getLocation()",
                    "detail": " Returns the current touch location in OpenGL coordinates.\nreturn The current touch location in OpenGL coordinates.\n"
                },
                "getPreviousLocation": {
                    "type": "method",
                    "define": "getPreviousLocation()",
                    "detail": " Returns the previous touch location in OpenGL coordinates.\nreturn The previous touch location in OpenGL coordinates.\njs NA\n"
                },
                "getPreviousLocationInView": {
                    "type": "method",
                    "define": "getPreviousLocationInView()",
                    "detail": " Returns the previous touch location in screen coordinates.\nreturn The previous touch location in screen coordinates.\njs NA\n"
                }
            },
            "ActionInterval": {
                "getElapsed": {
                    "type": "method",
                    "define": "getElapsed()",
                    "detail": " How many seconds had elapsed since the actions started to run.\nreturn The seconds had elapsed since the actions started to run.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amp})",
                    "detail": " Sets the amplitude rate, extension in GridAction\nparam amp   The amplitude rate.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": " Gets the amplitude rate, extension in GridAction\nreturn  The amplitude rate.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float d})",
                    "detail": " initializes the action \n"
                }
            },
            "272": "V2F_C4F_T2F_Quad",
            "PUParticleSystem3D": {
                "1": "new",
                "forceEmission": {
                    "type": "method",
                    "define": "forceEmission(${1:#cc.PUEmitter emitter},${2:#unsigned int requested})",
                    "detail": " Forces emission of particles.\nremarks The number of requested particles are the exact number that are emitted. No down-scaling is applied.\n"
                },
                "getDerivedScale": {
                    "type": "method",
                    "define": "getDerivedScale()"
                },
                "getDerivedPosition": {
                    "type": "method",
                    "define": "getDerivedPosition()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string filePath},${2:#string materialPath})",
                    "detail": "@overload self, string         \n@overload self         \n@overload self, string, string         \n"
                },
                "calulateRotationOffset": {
                    "type": "method",
                    "define": "calulateRotationOffset()"
                },
                "getParticleSystemScaleVelocity": {
                    "type": "method",
                    "define": "getParticleSystemScaleVelocity()",
                    "detail": "Returns the velocity scale, defined in the particle system, but passed to the technique for convenience.\n"
                },
                "getDefaultWidth": {
                    "type": "method",
                    "define": "getDefaultWidth()",
                    "detail": "default particle width\n"
                },
                "getTimeElapsedSinceStart": {
                    "type": "method",
                    "define": "getTimeElapsedSinceStart()"
                },
                "setMarkedForEmission": {
                    "type": "method",
                    "define": "setMarkedForEmission(${1:#bool isMarked})"
                },
                "setEmittedEmitterQuota": {
                    "type": "method",
                    "define": "setEmittedEmitterQuota(${1:#unsigned int quota})"
                },
                "removeListener": {
                    "type": "method",
                    "define": "removeListener(${1:#cc.PUListener listener})"
                },
                "getDefaultHeight": {
                    "type": "method",
                    "define": "getDefaultHeight()",
                    "detail": "default particle height\n"
                },
                "removerAllObserver": {
                    "type": "method",
                    "define": "removerAllObserver()"
                },
                "initSystem": {
                    "type": "method",
                    "define": "initSystem(${1:#string filePath})"
                },
                "removeAllEmitter": {
                    "type": "method",
                    "define": "removeAllEmitter()"
                },
                "getParentParticleSystem": {
                    "type": "method",
                    "define": "getParentParticleSystem()"
                },
                "copyAttributesTo": {
                    "type": "method",
                    "define": "copyAttributesTo(${1:#cc.PUParticleSystem3D system})"
                },
                "getEmittedEmitterQuota": {
                    "type": "method",
                    "define": "getEmittedEmitterQuota()"
                },
                "setParticleSystemScaleVelocity": {
                    "type": "method",
                    "define": "setParticleSystemScaleVelocity(${1:#float scaleVelocity})"
                },
                "forceUpdate": {
                    "type": "method",
                    "define": "forceUpdate(${1:#float delta})"
                },
                "setMaxVelocity": {
                    "type": "method",
                    "define": "setMaxVelocity(${1:#float maxVelocity})",
                    "detail": "Set the maximum velocity a particle can have.\n"
                },
                "isMarkedForEmission": {
                    "type": "method",
                    "define": "isMarkedForEmission()"
                },
                "setMaterialName": {
                    "type": "method",
                    "define": "setMaterialName(${1:#string name})"
                },
                "setDefaultHeight": {
                    "type": "method",
                    "define": "setDefaultHeight(${1:#float height})"
                },
                "removeAllBehaviourTemplate": {
                    "type": "method",
                    "define": "removeAllBehaviourTemplate()"
                },
                "addEmitter": {
                    "type": "method",
                    "define": "addEmitter(${1:#cc.PUEmitter emitter})",
                    "detail": "add particle affector\n"
                },
                "setEmittedSystemQuota": {
                    "type": "method",
                    "define": "setEmittedSystemQuota(${1:#unsigned int quota})"
                },
                "setDefaultDepth": {
                    "type": "method",
                    "define": "setDefaultDepth(${1:#float depth})"
                },
                "addListener": {
                    "type": "method",
                    "define": "addListener(${1:#cc.PUListener listener})"
                },
                "rotationOffset": {
                    "type": "method",
                    "define": "rotationOffset(${1:#vec3_table pos})",
                    "detail": "If the orientation of the particle system has been changed since the last update, the passed vector is rotated accordingly.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()"
                },
                "addObserver": {
                    "type": "method",
                    "define": "addObserver(${1:#cc.PUObserver observer})"
                },
                "getEmittedSystemQuota": {
                    "type": "method",
                    "define": "getEmittedSystemQuota()"
                },
                "initWithFilePath": {
                    "type": "method",
                    "define": "initWithFilePath(${1:#string filePath})"
                },
                "getMaxVelocity": {
                    "type": "method",
                    "define": "getMaxVelocity()",
                    "detail": "Return the maximum velocity a particle can have, even if the velocity of the particle has been set higher (either by initialisation of the particle or by means of an affector).\n"
                },
                "setDefaultWidth": {
                    "type": "method",
                    "define": "setDefaultWidth(${1:#float width})"
                },
                "removeAllListener": {
                    "type": "method",
                    "define": "removeAllListener()"
                },
                "getDefaultDepth": {
                    "type": "method",
                    "define": "getDefaultDepth()",
                    "detail": "default particle depth\n"
                },
                "makeParticleLocal": {
                    "type": "method",
                    "define": "makeParticleLocal(${1:#cc.PUParticle3D particle})"
                },
                "getMaterialName": {
                    "type": "method",
                    "define": "getMaterialName()"
                },
                "initWithFilePathAndMaterialPath": {
                    "type": "method",
                    "define": "initWithFilePathAndMaterialPath(${1:#string filePath},${2:#string materialPath})"
                },
                "clearAllParticles": {
                    "type": "method",
                    "define": "clearAllParticles()"
                },
                "addBehaviourTemplate": {
                    "type": "method",
                    "define": "addBehaviourTemplate(${1:#cc.PUBehaviour behaviour})"
                }
            },
            "271": "V2F_C4F_T2F",
            "UserDefault": {
                "1": "getInstance",
                "getIntegerForKey": {
                    "type": "method",
                    "define": "getIntegerForKey(${1:#char key},${2:#int defaultValue})",
                    "detail": "@overload self, char, int         \n@overload self, char         \n"
                },
                "setDoubleForKey": {
                    "type": "method",
                    "define": "setDoubleForKey(${1:#char key},${2:#double value})",
                    "detail": "Set double value by key.\nparam key The key to set.\nparam value A double value to set to the key.\njs NA\n"
                },
                "isXMLFileExist": {
                    "type": "method",
                    "define": "isXMLFileExist()",
                    "detail": " All supported platforms other iOS & Android and CC_PLATFORM_WINRT use xml file to save values. This function checks whether the xml file exists or not.\nreturn True if the xml file exists, false if not.\njs NA\n"
                },
                "getDoubleForKey": {
                    "type": "method",
                    "define": "getDoubleForKey(${1:#char key},${2:#double defaultValue})",
                    "detail": "@overload self, char, double         \n@overload self, char         \n"
                },
                "setIntegerForKey": {
                    "type": "method",
                    "define": "setIntegerForKey(${1:#char key},${2:#int value})",
                    "detail": "Set integer value by key.\nparam key The key to set.\nparam value A integer value to set to the key.\njs NA\n"
                },
                "setBoolForKey": {
                    "type": "method",
                    "define": "setBoolForKey(${1:#char key},${2:#bool value})",
                    "detail": "Set bool value by key.\nparam key The key to set.\nparam value A bool value to set to the key.\njs NA\n"
                },
                "setFloatForKey": {
                    "type": "method",
                    "define": "setFloatForKey(${1:#char key},${2:#float value})",
                    "detail": "Set float value by key.\nparam key The key to set.\nparam value A float value to set to the key.\njs NA\n"
                },
                "getStringForKey": {
                    "type": "method",
                    "define": "getStringForKey(${1:#char key},${2:#string defaultValue})",
                    "detail": "@overload self, char, string         \n@overload self, char         \n"
                },
                "deleteValueForKey": {
                    "type": "method",
                    "define": "deleteValueForKey(${1:#char key})",
                    "detail": "delete any value by key,\nparam key The key to delete value.\njs NA\n"
                },
                "getBoolForKey": {
                    "type": "method",
                    "define": "getBoolForKey(${1:#char key},${2:#bool defaultValue})",
                    "detail": "@overload self, char, bool         \n@overload self, char         \n"
                },
                "flush": {
                    "type": "method",
                    "define": "flush()",
                    "detail": "You should invoke this function to save values set by setXXXForKey().\njs NA\n"
                },
                "setStringForKey": {
                    "type": "method",
                    "define": "setStringForKey(${1:#char key},${2:#string value})",
                    "detail": "Set string value by key.\nparam key The key to set.\nparam value A string value to set to the key.\njs NA\n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": "js NA\n"
                },
                "getFloatForKey": {
                    "type": "method",
                    "define": "getFloatForKey(${1:#char key},${2:#float defaultValue})",
                    "detail": "@overload self, char, float         \n@overload self, char         \n"
                },
                "getXMLFilePath": {
                    "type": "method",
                    "define": "getXMLFilePath()",
                    "detail": " All supported platforms other iOS & Android use xml file to save values. This function is return the file path of the xml path.\njs NA\n"
                }
            },
            "269": "V2F_C4B_T2F",
            "AssetsManagerExStatic": [
                "MANIFEST_ID",
                "VERSION_ID"
            ],
            "267": "UNIFORM_TIME_S",
            "BillBoard": {
                "1": "new",
                "createWithTexture": {
                    "type": "method",
                    "define": "createWithTexture(${1:#cc.Texture2D texture},${2:#int mode})",
                    "detail": "Creates a BillBoard with a Texture2D object.\nAfter creation, the rect will be the size of the texture, and the offset will be (0,0).\nparam   texture    A pointer to a Texture2D object.\nreturn  An autoreleased BillBoard object\n"
                },
                "setMode": {
                    "type": "method",
                    "define": "setMode(${1:#int mode})",
                    "detail": " Set the billboard rotation mode. \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string filename},${2:#rect_table rect},${3:#int mode})",
                    "detail": "@overload self, string, int         \n@overload self, int         \n@overload self, string, rect_table, int         \n"
                },
                "getMode": {
                    "type": "method",
                    "define": "getMode()",
                    "detail": " Get the billboard rotation mode. \n"
                }
            },
            "GridAction": {
                "getGrid": {
                    "type": "method",
                    "define": "getGrid()",
                    "detail": "brief Get the pointer of GridBase.\nreturn The pointer of GridBase.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize})",
                    "detail": "brief Initializes the action with size and duration.\nparam duration The duration of the GridAction. It's a value in seconds.\nparam gridSize The size of the GridAction should be.\nreturn Return true when the initialization success, otherwise return false.\n"
                },
                "reverse": {
                    "type": "method",
                    "define": "reverse()"
                }
            },
            "OrbitCamera": {
                "1": "new",
                "2": "sphericalRadius",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#float radius},${3:#float deltaRadius},${4:#float angleZ},${5:#float deltaAngleZ},${6:#float angleX},${7:#float deltaAngleX})",
                    "detail": " Creates a OrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX. \nparam t Duration in seconds.\nparam radius The start radius.\nparam deltaRadius The delta radius.\nparam angleZ The start angle in Z.\nparam deltaAngleZ The delta angle in Z.\nparam angleX The start angle in X.\nparam deltaAngleX The delta angle in X.\nreturn An OrbitCamera.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#float radius},${3:#float deltaRadius},${4:#float angleZ},${5:#float deltaAngleZ},${6:#float angleX},${7:#float deltaAngleX})",
                    "detail": " Initializes a OrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX. \n"
                }
            },
            "DelayTime": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float d})",
                    "detail": "Creates the action.\nparam d Duration time, in seconds.\nreturn An autoreleased DelayTime object.\n"
                },
                "1": "new"
            },
            "263": "UNIFORM_SAMPLER_S",
            "TMXLayer": {
                "1": "getTileGIDAt",
                "2": "initWithTilesetInfo",
                "3": "new",
                "4": "releaseMap",
                "getMapTileSize": {
                    "type": "method",
                    "define": "getMapTileSize()",
                    "detail": " Size of the map's tile (could be different from the tile's size).\nreturn Size of the map's tile (could be different from the tile's size).\n"
                },
                "setLayerSize": {
                    "type": "method",
                    "define": "setLayerSize(${1:#size_table size})",
                    "detail": " Set the size of the layer in tiles. \nparam size The new size of the layer in tiles.\n"
                },
                "getProperty": {
                    "type": "method",
                    "define": "getProperty(${1:#string propertyName})",
                    "detail": " Return the value for the specific property name.\nparam propertyName The value for the specific property name.\nreturn The value for the specific property name.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.TMXTilesetInfo tilesetInfo},${2:#cc.TMXLayerInfo layerInfo},${3:#cc.TMXMapInfo mapInfo})",
                    "detail": " Creates a FastTMXLayer with an tileset info, a layer info and a map info.\nparam tilesetInfo An tileset info.\nparam layerInfo A layer info.\nparam mapInfo A map info.\nreturn Return an autorelease object.\n"
                },
                "getLayerOrientation": {
                    "type": "method",
                    "define": "getLayerOrientation()",
                    "detail": " Layer orientation, which is the same as the map orientation.\nreturn Layer orientation, which is the same as the map orientation.\n"
                },
                "removeTileAt": {
                    "type": "method",
                    "define": "removeTileAt(${1:#vec2_table tileCoordinate})",
                    "detail": " Removes a tile at given tile coordinate.\nparam tileCoordinate The tile Coordinate.\n"
                },
                "setTileGID": {
                    "type": "method",
                    "define": "setTileGID(${1:#int gid},${2:#vec2_table tileCoordinate},${3:#int flags})",
                    "detail": "@overload self, int, vec2_table, int         \n@overload self, int, vec2_table         \n"
                },
                "setLayerOrientation": {
                    "type": "method",
                    "define": "setLayerOrientation(${1:#int orientation})",
                    "detail": " Set Layer orientation, which is the same as the map orientation. \nparam orientation Layer orientation, which is the same as the map orientation.\n"
                },
                "getPositionAt": {
                    "type": "method",
                    "define": "getPositionAt(${1:#vec2_table tileCoordinate})",
                    "detail": " Returns the position in points of a given tile coordinate.\nparam tileCoordinate The tile Coordinate.\nreturn The position in points of a given tile coordinate.\n"
                },
                "5": "setTiles",
                "setMapTileSize": {
                    "type": "method",
                    "define": "setMapTileSize(${1:#size_table size})",
                    "detail": " Set the size of the map's tile. \nparam size The new size of the map's tile.\n"
                },
                "getLayerName": {
                    "type": "method",
                    "define": "getLayerName()",
                    "detail": " Get the tile layer name.\nreturn The tile layer name.\n"
                },
                "setTileSet": {
                    "type": "method",
                    "define": "setTileSet(${1:#cc.TMXTilesetInfo info})",
                    "detail": " Set the tileset information for the layer. \nparam info The new tileset information for the layer.\n"
                },
                "setupTiles": {
                    "type": "method",
                    "define": "setupTiles()",
                    "detail": " Creates the tiles. \n"
                },
                "setLayerName": {
                    "type": "method",
                    "define": "setLayerName(${1:#string layerName})",
                    "detail": " Set the tile layer name.\nparam layerName The new layer name.\n"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "getLayerSize": {
                    "type": "method",
                    "define": "getLayerSize()",
                    "detail": " Size of the layer in tiles.\nreturn Size of the layer in tiles.\n"
                },
                "getTileAt": {
                    "type": "method",
                    "define": "getTileAt(${1:#vec2_table tileCoordinate})",
                    "detail": " Returns the tile (Sprite) at a given a tile coordinate.\nThe returned Sprite will be already added to the TMXLayer. Don't add it again.\nThe Sprite can be treated like any other Sprite: rotated, scaled, translated, opacity, color, etc.\nYou can remove either by calling:\n- layer->removeChild(sprite, cleanup);\nreturn Returns the tile (Sprite) at a given a tile coordinate.\n"
                },
                "getTileSet": {
                    "type": "method",
                    "define": "getTileSet()",
                    "detail": " Tileset information for the layer.\nreturn Tileset information for the layer.\n"
                },
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})",
                    "detail": " Set the properties to the layer.\nparam properties The properties to the layer.\n"
                }
            },
            "261": "UNIFORM_RANDOM01_S",
            "259": "UNIFORM_P_MATRIX_S",
            "EaseSineInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "TransitionFade": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#cc.Scene scene},${3:#color3b_table color})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, color3b_table         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#cc.Scene scene},${3:#color3b_table color})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, color3b_table         \n"
                }
            },
            "AssetsManagerEx": {
                "1": "getFileNum",
                "2": "getTotalSize",
                "3": "new",
                "4": "setUrlExtra",
                "5": "startUpdate",
                "setMaxConcurrentTask": {
                    "type": "method",
                    "define": "setMaxConcurrentTask(${1:#int max})",
                    "detail": " @brief Function for setting the max concurrent task count\n"
                },
                "getState": {
                    "type": "method",
                    "define": "getState()",
                    "detail": " @brief Gets the current update state.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string manifestUrl},${2:#string storagePath})",
                    "detail": " @brief Create function for creating a new AssetsManagerEx\nparam manifestUrl   The url for the local manifest file\nparam storagePath   The storage path for downloaded assets\nwarning   The cached manifest in your storage path have higher priority and will be searched first,\nonly if it doesn't exist, AssetsManagerEx will use the given manifestUrl.\n"
                },
                "getRemoteManifest": {
                    "type": "method",
                    "define": "getRemoteManifest()",
                    "detail": " @brief Function for retrieving the remote manifest object\n"
                },
                "checkUpdate": {
                    "type": "method",
                    "define": "checkUpdate()",
                    "detail": " @brief  Check out if there is a new version of manifest.\nYou may use this method before updating, then let user determine whether\nhe wants to update resources.\n"
                },
                "setVerifyCallback": {
                    "type": "method",
                    "define": "setVerifyCallback(${1:#function callback})",
                    "detail": " @brief Set the verification function for checking whether downloaded asset is correct, e.g. using md5 verification\nparam callback  The verify callback function\n"
                },
                "getStoragePath": {
                    "type": "method",
                    "define": "getStoragePath()",
                    "detail": " @brief Gets storage path.\n"
                },
                "getLocalManifest": {
                    "type": "method",
                    "define": "getLocalManifest()",
                    "detail": " @brief Function for retrieving the local manifest object\n"
                },
                "downloadFailedAssets": {
                    "type": "method",
                    "define": "downloadFailedAssets()",
                    "detail": " @brief Reupdate all failed assets under the current AssetsManagerEx context\n"
                },
                "setVersionCompareHandle": {
                    "type": "method",
                    "define": "setVersionCompareHandle(${1:#function handle})",
                    "detail": " @brief Set the handle function for comparing manifests versions\nparam handle    The compare function\n"
                },
                "update": {
                    "type": "method",
                    "define": "update()",
                    "detail": " @brief Update with the current local manifest.\n"
                },
                "getMaxConcurrentTask": {
                    "type": "method",
                    "define": "getMaxConcurrentTask()",
                    "detail": " @brief Function for retrieving the max concurrent task count\n"
                }
            },
            "Twirl": {
                "1": "new",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#vec2_table position},${4:#unsigned int twirls},${5:#float amplitude})",
                    "detail": "brief Initializes the action with center position, number of twirls, amplitude, a grid size and duration.\nparam duration Specify the duration of the Twirl action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam position Specify the center position of the twirl action.\nparam twirls Specify the twirls count of the Twirl action.\nparam amplitude Specify the amplitude of the Twirl action.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float amplitude})",
                    "detail": "brief Set the amplitude to the effect.\nparam amplitude The value of amplitude will be set.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of the effect.\nreturn Return the amplitude rate of the effect.\n"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#vec2_table position})",
                    "detail": "brief Set the center position of twirl action.\nparam position The center position of twirl action will be set.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#vec2_table position},${4:#unsigned int twirls},${5:#float amplitude})",
                    "detail": "brief Create the action with center position, number of twirls, amplitude, a grid size and duration.\nparam duration Specify the duration of the Twirl action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam position Specify the center position of the twirl action.\nparam twirls Specify the twirls count of the Twirl action.\nparam amplitude Specify the amplitude of the Twirl action.\nreturn If the creation success, return a pointer of Twirl action; otherwise, return nil.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of the effect.\nreturn Return the amplitude of the effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amplitudeRate})",
                    "detail": "brief Set the amplitude rate of the effect.\nparam amplitudeRate The value of amplitude rate will be set.\n"
                },
                "getPosition": {
                    "type": "method",
                    "define": "getPosition()",
                    "detail": "brief Get the center position of twirl action.\nreturn The center position of twirl action.\n"
                }
            },
            "TurnOffTiles": {
                "1": "new",
                "turnOnTile": {
                    "type": "method",
                    "define": "turnOnTile(${1:#vec2_table pos})",
                    "detail": "brief Show the tile at specified position.\nparam pos The position index of the tile should be shown.\n"
                },
                "turnOffTile": {
                    "type": "method",
                    "define": "turnOffTile(${1:#vec2_table pos})",
                    "detail": "brief Hide the tile at specified position.\nparam pos The position index of the tile should be hide.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int seed})",
                    "detail": "@overload self, float, size_table, unsigned int         \n@overload self, float, size_table         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int seed})",
                    "detail": "brief Initializes the action with grid size, random seed and duration.\nparam duration Specify the duration of the TurnOffTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam seed Specify the random seed.\nreturn If the Initialization success, return true; otherwise, return false.\n"
                }
            },
            "ControlSaturationBrightnessPicker": {
                "initWithTargetAndPos": {
                    "type": "method",
                    "define": "initWithTargetAndPos(${1:#cc.Node target},${2:#vec2_table pos})"
                },
                "getBrightness": {
                    "type": "method",
                    "define": "getBrightness()"
                },
                "getSlider": {
                    "type": "method",
                    "define": "getSlider()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node target},${2:#vec2_table pos})"
                },
                "getOverlay": {
                    "type": "method",
                    "define": "getOverlay()"
                },
                "getBackground": {
                    "type": "method",
                    "define": "getBackground()"
                },
                "getShadow": {
                    "type": "method",
                    "define": "getShadow()"
                },
                "1": "new",
                "getStartPos": {
                    "type": "method",
                    "define": "getStartPos()"
                },
                "getSaturation": {
                    "type": "method",
                    "define": "getSaturation()"
                }
            },
            "Ray": [
                "collector",
                "intersects",
                "new",
                "set",
                "transform"
            ],
            "TransitionScene": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a base transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionScene object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " initializes a transition with duration and incoming scene \n"
                },
                "finish": {
                    "type": "method",
                    "define": "finish()",
                    "detail": " Called after the transition finishes.\n"
                },
                "hideOutShowIn": {
                    "type": "method",
                    "define": "hideOutShowIn()",
                    "detail": " Used by some transitions to hide the outer scene.\n"
                },
                "1": "new",
                "getInScene": {
                    "type": "method",
                    "define": "getInScene()"
                },
                "getDuration": {
                    "type": "method",
                    "define": "getDuration()"
                }
            },
            "EaseCircleActionInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "TransitionSplitCols": {
                "1": "new",
                "action": {
                    "type": "method",
                    "define": "action()",
                    "detail": " Returns the action that will be performed.\nreturn The action that will be performed.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionSplitCols object.\n"
                },
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})"
                }
            },
            "ProgressTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float percent})",
                    "detail": "brief Create and initializes with a duration and a destination percentage.\nparam duration Specify the duration of the ProgressTo action. It's a value in seconds.\nparam percent Specify the destination percentage.\nreturn If the creation success, return a pointer of ProgressTo action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#float percent})",
                    "detail": "brief Initializes with a duration and destination percentage. \nparam duration Specify the duration of the ProgressTo action. It's a value in seconds.\nparam percent Specify the destination percentage.\nreturn If the creation success, return true; otherwise, return false.\n"
                }
            },
            "TransitionSlideInT": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionSlideInT object.\n"
                },
                "1": "new"
            },
            "Image": {
                "setPNGPremultipliedAlphaEnabled": {
                    "type": "method",
                    "define": "setPNGPremultipliedAlphaEnabled(${1:#bool enabled})",
                    "detail": "Enables or disables premultiplied alpha for PNG files.\nparam enabled (default: true)\n"
                },
                "setPVRImagesHavePremultipliedAlpha": {
                    "type": "method",
                    "define": "setPVRImagesHavePremultipliedAlpha(${1:#bool haveAlphaPremultiplied})",
                    "detail": " treats (or not) PVR files as if they have alpha premultiplied.\nSince it is impossible to know at runtime if the PVR images have the alpha channel premultiplied, it is\npossible load them as if they have (or not) the alpha channel premultiplied.\nBy default it is disabled.\n"
                },
                "getBitPerPixel": {
                    "type": "method",
                    "define": "getBitPerPixel()"
                },
                "saveToFile": {
                    "type": "method",
                    "define": "saveToFile(${1:#string filename},${2:#bool isToRGB})",
                    "detail": "brief    Save Image data to the specified file, with specified format.\nparam    filePath        the file's absolute path, including file suffix.\nparam    isToRGB        whether the image is saved as RGB format.\n"
                },
                "hasPremultipliedAlpha": {
                    "type": "method",
                    "define": "hasPremultipliedAlpha()"
                },
                "initWithImageFile": {
                    "type": "method",
                    "define": "initWithImageFile(${1:#string path})",
                    "detail": "brief Load the image from the specified path.\nparam path   the absolute file path.\nreturn true if loaded correctly.\n"
                },
                "isCompressed": {
                    "type": "method",
                    "define": "isCompressed()"
                },
                "getFilePath": {
                    "type": "method",
                    "define": "getFilePath()"
                },
                "hasAlpha": {
                    "type": "method",
                    "define": "hasAlpha()"
                },
                "getWidth": {
                    "type": "method",
                    "define": "getWidth()"
                },
                "getRenderFormat": {
                    "type": "method",
                    "define": "getRenderFormat()"
                },
                "getHeight": {
                    "type": "method",
                    "define": "getHeight()"
                },
                "1": "new",
                "getNumberOfMipmaps": {
                    "type": "method",
                    "define": "getNumberOfMipmaps()"
                },
                "getFileType": {
                    "type": "method",
                    "define": "getFileType()"
                }
            },
            "TransitionSlideInB": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionSlideInB object.\n"
                },
                "1": "new"
            },
            "TransitionShrinkGrow": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionShrinkGrow object.\n"
                },
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})"
                }
            },
            "TransitionProgressVertical": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgressVertical object.\n"
                },
                "1": "new"
            },
            "Sprite": {
                "1": "create",
                "2": "initWithPolygon",
                "3": "new",
                "4": "setPolygonInfo",
                "getTextureRect": {
                    "type": "method",
                    "define": "getTextureRect()",
                    "detail": "Returns the rect of the Sprite in points.\n"
                },
                "getBatchNode": {
                    "type": "method",
                    "define": "getBatchNode()",
                    "detail": "Returns the batch node object if this sprite is rendered by SpriteBatchNode.\nreturn The SpriteBatchNode object if this sprite is rendered by SpriteBatchNode,\nnullptr if the sprite isn't used batch node.\n"
                },
                "setTextureAtlas": {
                    "type": "method",
                    "define": "setTextureAtlas(${1:#cc.TextureAtlas textureAtlas})",
                    "detail": "Sets the weak reference of the TextureAtlas when the sprite is rendered using via SpriteBatchNode.\n"
                },
                "setVertexRect": {
                    "type": "method",
                    "define": "setVertexRect(${1:#rect_table rect})",
                    "detail": "Sets the vertex rect.\nIt will be called internally by setTextureRect.\nUseful if you want to create 2x images from SD images in Retina Display.\nDo not call it manually. Use setTextureRect instead.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "/ @{/ @name Functions inherited from TextureProtocol.\ncode\nWhen this function bound into js or lua,the parameter will be changed.\nIn js: var setBlendFunc(var src, var dst).\nIn lua: local setBlendFunc(local src, local dst).\nendcode\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "js  NA\nlua NA\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()",
                    "detail": " Returns the Texture2D object used by the sprite. \n"
                },
                "createWithSpriteFrame": {
                    "type": "method",
                    "define": "createWithSpriteFrame(${1:#cc.SpriteFrame spriteFrame})",
                    "detail": "Creates a sprite with an sprite frame.\nparam   spriteFrame    A sprite frame which involves a texture and a rect.\nreturn  An autoreleased sprite object.\n"
                },
                "initWithFile": {
                    "type": "method",
                    "define": "initWithFile(${1:#string filename},${2:#rect_table rect})",
                    "detail": "@overload self, string, rect_table         \n@overload self, string         \n"
                },
                "isTextureRectRotated": {
                    "type": "method",
                    "define": "isTextureRectRotated()",
                    "detail": "Returns whether or not the texture rectangle is rotated.\n"
                },
                "setStretchEnabled": {
                    "type": "method",
                    "define": "setStretchEnabled(${1:#bool enabled})",
                    "detail": " whether or not contentSize stretches the sprite's texture \n"
                },
                "removeAllChildrenWithCleanup": {
                    "type": "method",
                    "define": "removeAllChildrenWithCleanup(${1:#bool cleanup})"
                },
                "createWithTexture": {
                    "type": "method",
                    "define": "createWithTexture(${1:#cc.Texture2D texture},${2:#rect_table rect},${3:#bool rotated})",
                    "detail": "@overload self, cc.Texture2D, rect_table, bool         \n@overload self, cc.Texture2D         \n"
                },
                "setDirty": {
                    "type": "method",
                    "define": "setDirty(${1:#bool dirty})",
                    "detail": "Makes the Sprite to be updated in the Atlas.\n"
                },
                "getSpriteFrame": {
                    "type": "method",
                    "define": "getSpriteFrame()",
                    "detail": "Returns the current displayed frame.\n"
                },
                "isStretchEnabled": {
                    "type": "method",
                    "define": "isStretchEnabled()",
                    "detail": " returns whether or not contentSize stretches the sprite's texture \n"
                },
                "getCenterRectNormalized": {
                    "type": "method",
                    "define": "getCenterRectNormalized()",
                    "detail": "getCenterRectNormalized\nReturns the CenterRect in normalized coordinates\n"
                },
                "setCenterRectNormalized": {
                    "type": "method",
                    "define": "setCenterRectNormalized(${1:#rect_table rect})",
                    "detail": "setCenterRectNormalized\nUseful to implement \"9 sliced\" sprites.\nThe default value is (0,0) - (1,1), which means that only one \"slice\" will be used: From top-left (0,0) to bottom-right (1,1).\nIf the value is different than (0,0), (1,1), then the sprite will be sliced into a 3 x 3 grid. The four corners of this grid are applied without\nperforming any scaling. The upper- and lower-middle parts are scaled horizontally, and the left- and right-middle parts are scaled vertically.\nThe center is scaled in both directions.\nImportant: The scaling is based the Sprite's trimmed size.\nLimitations: Does not work when the sprite is part of `SpriteBatchNode`.\n"
                },
                "isFrameDisplayed": {
                    "type": "method",
                    "define": "isFrameDisplayed(${1:#cc.SpriteFrame frame})",
                    "detail": "Returns whether or not a SpriteFrame is being displayed.\n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#string filename})",
                    "detail": "@overload self, cc.Texture2D         \n@overload self, string         \n"
                },
                "isFlippedY": {
                    "type": "method",
                    "define": "isFlippedY()",
                    "detail": "Return the flag which indicates whether the sprite is flipped vertically or not.\nIt only flips the texture of the sprite, and not the texture of the sprite's children.\nAlso, flipping the texture doesn't alter the anchorPoint.\nIf you want to flip the anchorPoint too, and/or to flip the children too use:\nsprite->setScaleY(sprite->getScaleY() * -1);\nreturn true if the sprite is flipped vertically, false otherwise.\n"
                },
                "setFlippedY": {
                    "type": "method",
                    "define": "setFlippedY(${1:#bool flippedY})",
                    "detail": "Sets whether the sprite should be flipped vertically or not.\nparam flippedY true if the sprite should be flipped vertically, false otherwise.\n"
                },
                "getResourceName": {
                    "type": "method",
                    "define": "getResourceName()"
                },
                "isFlippedX": {
                    "type": "method",
                    "define": "isFlippedX()",
                    "detail": "Returns the flag which indicates whether the sprite is flipped horizontally or not.\nIt only flips the texture of the sprite, and not the texture of the sprite's children.\nAlso, flipping the texture doesn't alter the anchorPoint.\nIf you want to flip the anchorPoint too, and/or to flip the children too use:\nsprite->setScaleX(sprite->getScaleX() * -1);\nreturn true if the sprite is flipped horizontally, false otherwise.\n"
                },
                "setTextureRect": {
                    "type": "method",
                    "define": "setTextureRect(${1:#rect_table rect},${2:#bool rotated},${3:#size_table untrimmedSize})",
                    "detail": "@overload self, rect_table, bool, size_table         \n@overload self, rect_table         \n"
                },
                "setSpriteFrame": {
                    "type": "method",
                    "define": "setSpriteFrame(${1:#string spriteFrameName})",
                    "detail": "@overload self, cc.SpriteFrame         \n@overload self, string         \n"
                },
                "getAtlasIndex": {
                    "type": "method",
                    "define": "getAtlasIndex()",
                    "detail": "Returns the index used on the TextureAtlas.\n"
                },
                "setFlippedX": {
                    "type": "method",
                    "define": "setFlippedX(${1:#bool flippedX})",
                    "detail": "Sets whether the sprite should be flipped horizontally or not.\nparam flippedX true if the sprite should be flipped horizontally, false otherwise.\n"
                },
                "setDisplayFrameWithAnimationName": {
                    "type": "method",
                    "define": "setDisplayFrameWithAnimationName(${1:#string animationName},${2:#int frameIndex})",
                    "detail": "/ @{/ @name Animation methods\nChanges the display frame with animation name and index.\nThe animation name will be get from the AnimationCache.\n"
                },
                "getOffsetPosition": {
                    "type": "method",
                    "define": "getOffsetPosition()",
                    "detail": "Gets the offset position of the sprite. Calculated automatically by editors like Zwoptex.\n"
                },
                "setBatchNode": {
                    "type": "method",
                    "define": "setBatchNode(${1:#cc.SpriteBatchNode spriteBatchNode})",
                    "detail": "Sets the batch node to sprite.\nwarning This method is not recommended for game developers. Sample code for using batch node\ncode\nSpriteBatchNode *batch = SpriteBatchNode::create(\"Images/grossini_dance_atlas.png\", 15);\nSprite *sprite = Sprite::createWithTexture(batch->getTexture(), Rect(0, 0, 57, 57));\nbatch->addChild(sprite);\nlayer->addChild(batch);\nendcode\n"
                },
                "isDirty": {
                    "type": "method",
                    "define": "isDirty()",
                    "detail": "Whether or not the Sprite needs to be updated in the Atlas.\nreturn True if the sprite needs to be updated in the Atlas, false otherwise.\n"
                },
                "getResourceType": {
                    "type": "method",
                    "define": "getResourceType()",
                    "detail": "/ @}\n"
                },
                "setAtlasIndex": {
                    "type": "method",
                    "define": "setAtlasIndex(${1:#int atlasIndex})",
                    "detail": "Sets the index used on the TextureAtlas.\nwarning Don't modify this value unless you know what you are doing.\n"
                },
                "initWithSpriteFrame": {
                    "type": "method",
                    "define": "initWithSpriteFrame(${1:#cc.SpriteFrame spriteFrame})",
                    "detail": "Initializes a sprite with an SpriteFrame. The texture and rect in SpriteFrame will be applied on this sprite.\nparam   spriteFrame  A SpriteFrame object. It should includes a valid texture and a rect.\nreturn  True if the sprite is initialized properly, false otherwise.\n"
                },
                "getTextureAtlas": {
                    "type": "method",
                    "define": "getTextureAtlas()",
                    "detail": "Gets the weak reference of the TextureAtlas when the sprite is rendered using via SpriteBatchNode.\n"
                },
                "initWithTexture": {
                    "type": "method",
                    "define": "initWithTexture(${1:#cc.Texture2D texture},${2:#rect_table rect},${3:#bool rotated})",
                    "detail": "@overload self, cc.Texture2D, rect_table         \n@overload self, cc.Texture2D         \n@overload self, cc.Texture2D, rect_table, bool         \n"
                },
                "setCenterRect": {
                    "type": "method",
                    "define": "setCenterRect(${1:#rect_table rect})"
                },
                "initWithSpriteFrameName": {
                    "type": "method",
                    "define": "initWithSpriteFrameName(${1:#string spriteFrameName})",
                    "detail": "Initializes a sprite with an sprite frame name.\nA SpriteFrame will be fetched from the SpriteFrameCache by name.\nIf the SpriteFrame doesn't exist it will raise an exception.\nparam   spriteFrameName  A key string that can fetched a valid SpriteFrame from SpriteFrameCache.\nreturn  True if the sprite is initialized properly, false otherwise.\n"
                },
                "createWithSpriteFrameName": {
                    "type": "method",
                    "define": "createWithSpriteFrameName(${1:#string spriteFrameName})",
                    "detail": "Creates a sprite with an sprite frame name.\nA SpriteFrame will be fetched from the SpriteFrameCache by spriteFrameName param.\nIf the SpriteFrame doesn't exist it will raise an exception.\nparam   spriteFrameName A null terminated string which indicates the sprite frame name.\nreturn  An autoreleased sprite object.\n"
                },
                "getCenterRect": {
                    "type": "method",
                    "define": "getCenterRect()",
                    "detail": "brief Returns the Cap Insets rect\nreturn Scale9Sprite's cap inset.\n"
                }
            },
            "TransitionProgressRadialCW": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgressRadialCW object.\n"
                },
                "1": "new"
            },
            "MotionStreak3D": {
                "1": "new",
                "reset": {
                    "type": "method",
                    "define": "reset()",
                    "detail": " Remove all living segments of the ribbon.\n"
                },
                "isStartingPositionInitialized": {
                    "type": "method",
                    "define": "isStartingPositionInitialized()",
                    "detail": " Is the starting position initialized or not.\nreturn True if the starting position is initialized.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "js NA\nlua NA\n"
                },
                "initWithFade": {
                    "type": "method",
                    "define": "initWithFade(${1:#float fade},${2:#float minSeg},${3:#float stroke},${4:#color3b_table color},${5:#string path})",
                    "detail": "@overload self, float, float, float, color3b_table, cc.Texture2D         \n@overload self, float, float, float, color3b_table, string         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float fade},${2:#float minSeg},${3:#float stroke},${4:#color3b_table color},${5:#string path})",
                    "detail": "@overload self, float, float, float, color3b_table, cc.Texture2D         \n@overload self, float, float, float, color3b_table, string         \n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "js NA\nlua NA\n"
                },
                "getStroke": {
                    "type": "method",
                    "define": "getStroke()",
                    "detail": " Get stroke.\nreturn float stroke.\n"
                },
                "tintWithColor": {
                    "type": "method",
                    "define": "tintWithColor(${1:#color3b_table colors})",
                    "detail": " Color used for the tint.\nparam colors The color used for the tint.\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})"
                },
                "setSweepAxis": {
                    "type": "method",
                    "define": "setSweepAxis(${1:#vec3_table sweepAxis})",
                    "detail": "Set the direction of sweeping line segment.\nparam sweepAxis Direction of sweeping line segment\n"
                },
                "setStroke": {
                    "type": "method",
                    "define": "setStroke(${1:#float stroke})",
                    "detail": " Set stroke.\nparam stroke The width of stroke.\n"
                },
                "setStartingPositionInitialized": {
                    "type": "method",
                    "define": "setStartingPositionInitialized(${1:#bool bStartingPositionInitialized})",
                    "detail": " Sets the starting position initialized or not.\nparam bStartingPositionInitialized True if initialized the starting position.\n"
                },
                "getSweepAxis": {
                    "type": "method",
                    "define": "getSweepAxis()",
                    "detail": "Get the direction of sweeping line segment\n"
                }
            },
            "ScaleTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float sx},${3:#float sy},${4:#float sz})",
                    "detail": "@overload self, float, float, float         \n@overload self, float, float         \n@overload self, float, float, float, float         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#float sx},${3:#float sy},${4:#float sz})",
                    "detail": "@overload self, float, float, float         \n@overload self, float, float         \n@overload self, float, float, float, float         \n"
                }
            },
            "SpriteFrame": {
                "isRotated": {
                    "type": "method",
                    "define": "isRotated()",
                    "detail": "Is the sprite frame rotated or not.\nreturn Is rotated if true.\n"
                },
                "setAnchorPoint": {
                    "type": "method",
                    "define": "setAnchorPoint(${1:#vec2_table anchorPoint})",
                    "detail": " Set anchor point of the frame.\nparam anchorPoint The anchor point of the sprite frame.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string filename},${2:#rect_table rect},${3:#bool rotated},${4:#vec2_table offset},${5:#size_table originalSize})",
                    "detail": "@overload self, string, rect_table, bool, vec2_table, size_table         \n@overload self, string, rect_table         \n"
                },
                "getOriginalSize": {
                    "type": "method",
                    "define": "getOriginalSize()",
                    "detail": " Get original size of the trimmed image.\nreturn The original size of the trimmed image.\n"
                },
                "setOffset": {
                    "type": "method",
                    "define": "setOffset(${1:#vec2_table offsets})",
                    "detail": " Set offset of the frame.\nparam offsets The offset of the sprite frame.\n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D pobTexture})",
                    "detail": " Set texture of the frame, the texture is retained.\nparam pobTexture The texture of the sprite frame.\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()",
                    "detail": " Get texture of the frame.\nreturn The texture of the sprite frame.\n"
                },
                "setRotated": {
                    "type": "method",
                    "define": "setRotated(${1:#bool rotated})",
                    "detail": " Set rotated of the sprite frame.\nparam rotated Rotated the sprite frame if true.\n"
                },
                "setOriginalSize": {
                    "type": "method",
                    "define": "setOriginalSize(${1:#size_table sizeInPixels})",
                    "detail": " Set original size of the trimmed image.\nparam sizeInPixels The original size of the trimmed image.\n"
                },
                "1": "new",
                "getOriginalSizeInPixels": {
                    "type": "method",
                    "define": "getOriginalSizeInPixels()",
                    "detail": " Get original size of the trimmed image.\nreturn The original size of the trimmed image, in pixels.\n"
                },
                "getAnchorPoint": {
                    "type": "method",
                    "define": "getAnchorPoint()",
                    "detail": " Get anchor point of the frame.\nreturn The anchor point of the sprite frame.\n"
                },
                "initWithTextureFilename": {
                    "type": "method",
                    "define": "initWithTextureFilename(${1:#string filename},${2:#rect_table rect},${3:#bool rotated},${4:#vec2_table offset},${5:#size_table originalSize})",
                    "detail": "@overload self, string, rect_table, bool, vec2_table, size_table         \n@overload self, string, rect_table         \n"
                },
                "setRect": {
                    "type": "method",
                    "define": "setRect(${1:#rect_table rect})",
                    "detail": " Set rect of the frame.\nparam rect The rect of the sprite.\n"
                },
                "setRectInPixels": {
                    "type": "method",
                    "define": "setRectInPixels(${1:#rect_table rectInPixels})",
                    "detail": " Set rect of the sprite frame.\nparam rectInPixels The rect of the sprite frame, in pixels.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()"
                },
                "createWithTexture": {
                    "type": "method",
                    "define": "createWithTexture(${1:#cc.Texture2D pobTexture},${2:#rect_table rect},${3:#bool rotated},${4:#vec2_table offset},${5:#size_table originalSize})",
                    "detail": "@overload self, cc.Texture2D, rect_table, bool, vec2_table, size_table         \n@overload self, cc.Texture2D, rect_table         \n"
                },
                "getRect": {
                    "type": "method",
                    "define": "getRect()",
                    "detail": " Get rect of the frame.\nreturn The rect of the sprite frame.\n"
                },
                "hasAnchorPoint": {
                    "type": "method",
                    "define": "hasAnchorPoint()",
                    "detail": " Check if anchor point is defined for the frame.\nreturn true if anchor point is available.\n"
                },
                "getOffsetInPixels": {
                    "type": "method",
                    "define": "getOffsetInPixels()",
                    "detail": " Get offset of the frame.\nreturn The offset of the sprite frame, in pixels.\n"
                },
                "hasCenterRect": {
                    "type": "method",
                    "define": "hasCenterRect()",
                    "detail": " hasCenterRect\nreturn Whether or not it has a centerRect\n"
                },
                "getOffset": {
                    "type": "method",
                    "define": "getOffset()",
                    "detail": " Get offset of the frame.\nreturn The offset of the sprite frame.\n"
                },
                "setOriginalSizeInPixels": {
                    "type": "method",
                    "define": "setOriginalSizeInPixels(${1:#size_table sizeInPixels})",
                    "detail": " Set original size of the trimmed image.\nparam sizeInPixels The original size of the trimmed image, in pixels.\n"
                },
                "initWithTexture": {
                    "type": "method",
                    "define": "initWithTexture(${1:#cc.Texture2D pobTexture},${2:#rect_table rect},${3:#bool rotated},${4:#vec2_table offset},${5:#size_table originalSize})",
                    "detail": "@overload self, cc.Texture2D, rect_table, bool, vec2_table, size_table         \n@overload self, cc.Texture2D, rect_table         \n"
                },
                "setOffsetInPixels": {
                    "type": "method",
                    "define": "setOffsetInPixels(${1:#vec2_table offsetInPixels})",
                    "detail": " Set offset of the frame.\nparam offsetInPixels The offset of the sprite frame, in pixels.\n"
                },
                "setCenterRectInPixels": {
                    "type": "method",
                    "define": "setCenterRectInPixels(${1:#rect_table centerRect})",
                    "detail": "setCenterRect\nUseful to implement \"9 sliced\" sprites.\nThe sprite will be sliced into a 3 x 3 grid. The four corners of this grid are applied without\nperforming any scaling. The upper- and lower-middle parts are scaled horizontally, and the left- and right-middle parts are scaled vertically.\nThe center is scaled in both directions.\nImportant: The scaling is based the Sprite's trimmed size.\nLimitations: Does not work when the sprite is part of `SpriteBatchNode`.\nparam centerRect the Rect in points\n"
                },
                "getRectInPixels": {
                    "type": "method",
                    "define": "getRectInPixels()",
                    "detail": " Get rect of the sprite frame.\nreturn The rect of the sprite frame, in pixels.\n"
                },
                "getCenterRect": {
                    "type": "method",
                    "define": "getCenterRect()",
                    "detail": " Get center rect of the frame.\nUseful to create 9-slice sprites\nreturn The center rect of the sprite frame in points\n"
                }
            },
            "YELLOW": [
                "b",
                "g",
                "r"
            ],
            "325": "pIsLineIntersect",
            "EaseIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "1": "new"
            },
            "EaseBezierAction": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})",
                    "detail": "brief Create the action with the inner action.\nparam action The pointer of the inner action.\nreturn A pointer of EaseBezierAction action. If creation failed, return nil.\n"
                },
                "setBezierParamer": {
                    "type": "method",
                    "define": "setBezierParamer(${1:#float p0},${2:#float p1},${3:#float p2},${4:#float p3})",
                    "detail": "brief Set the bezier parameters.\n"
                }
            },
            "EaseExponentialInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "TransitionProgress": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgress object.\n"
                },
                "1": "new"
            },
            "WavesTiles3D": {
                "1": "new",
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float amplitude})",
                    "detail": "brief Set the amplitude to the effect.\nparam amplitude The value of amplitude will be set.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of the effect.\nreturn Return the amplitude rate of the effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amplitudeRate})",
                    "detail": "brief Set the amplitude rate of the effect.\nparam amplitudeRate The value of amplitude rate will be set.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of the effect.\nreturn Return the amplitude of the effect.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude})",
                    "detail": "brief Initializes an action with duration, grid size, waves count and amplitude.\nparam duration Specify the duration of the WavesTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the WavesTiles3D action.\nparam amplitude Specify the amplitude of the WavesTiles3D action.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int waves},${4:#float amplitude})",
                    "detail": "brief Create the action with a number of waves, the waves amplitude, the grid size and the duration.\nparam duration Specify the duration of the WavesTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam waves Specify the waves count of the WavesTiles3D action.\nparam amplitude Specify the amplitude of the WavesTiles3D action.\nreturn If the creation success, return a pointer of WavesTiles3D action; otherwise, return nil.\n"
                }
            },
            "TransitionFlipAngular": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene s},${3:#int o})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, int         \n"
                },
                "1": "new"
            },
            "Ripple3D": {
                "1": "new",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#vec2_table position},${4:#float radius},${5:#unsigned int waves},${6:#float amplitude})",
                    "detail": "brief Initializes the action with center position, radius, number of waves, amplitude, a grid size and duration.\nparam duration Specify the duration of the Ripple3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam position Specify the center position of the ripple effect.\nparam radius Specify the radius of the ripple effect.\nparam waves Specify the waves count of the ripple effect.\nparam amplitude Specify the amplitude of the ripple effect.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float fAmplitude})",
                    "detail": "brief Set the amplitude of ripple effect.\nparam fAmplitude The amplitude of ripple effect.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of ripple effect.\nreturn The amplitude rate of ripple effect.\n"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#vec2_table position})",
                    "detail": "brief Set the center position of ripple effect.\nparam position The center position of ripple effect will be set.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#vec2_table position},${4:#float radius},${5:#unsigned int waves},${6:#float amplitude})",
                    "detail": "brief Create the action with center position, radius, number of waves, amplitude, a grid size and duration.\nparam duration Specify the duration of the Ripple3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam position Specify the center position of the ripple effect.\nparam radius Specify the radius of the ripple effect.\nparam waves Specify the waves count of the ripple effect.\nparam amplitude Specify the amplitude of the ripple effect.\nreturn If the creation success, return a pointer of Ripple3D action; otherwise, return nil.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of ripple effect.\nreturn The amplitude of ripple effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float fAmplitudeRate})",
                    "detail": "brief Set the amplitude rate of ripple effect.\nparam fAmplitudeRate The amplitude rate of ripple effect.\n"
                },
                "getPosition": {
                    "type": "method",
                    "define": "getPosition()",
                    "detail": "brief Get the center position of ripple effect.\nreturn The center position of ripple effect.\n"
                }
            },
            "Scene": {
                "1": "new",
                "render": {
                    "type": "method",
                    "define": "render(${1:#cc.Renderer renderer},${2:#mat4_table eyeTransforms},${3:#mat4_table eyeProjections},${4:#unsigned int multiViewCount})",
                    "detail": "@overload self, cc.Renderer, mat4_table, mat4_table, unsigned int         \n@overload self, cc.Renderer, mat4_table, mat4_table         \n"
                },
                "getDefaultCamera": {
                    "type": "method",
                    "define": "getDefaultCamera()",
                    "detail": " Get the default camera.\njs NA\nreturn The default camera of scene.\n"
                },
                "createWithPhysics": {
                    "type": "method",
                    "define": "createWithPhysics()",
                    "detail": " Create a scene with physics.\nreturn An autoreleased Scene object with physics.\njs NA\n"
                },
                "createWithSize": {
                    "type": "method",
                    "define": "createWithSize(${1:#size_table size})",
                    "detail": " Creates a new Scene object with a predefined Size. \nparam size The predefined size of scene.\nreturn An autoreleased Scene object.\njs NA\n"
                },
                "initWithPhysics": {
                    "type": "method",
                    "define": "initWithPhysics()"
                },
                "onProjectionChanged": {
                    "type": "method",
                    "define": "onProjectionChanged(${1:#cc.EventCustom event})"
                },
                "setCameraOrderDirty": {
                    "type": "method",
                    "define": "setCameraOrderDirty()"
                },
                "stepPhysicsAndNavigation": {
                    "type": "method",
                    "define": "stepPhysicsAndNavigation(${1:#float deltaTime})"
                },
                "initWithSize": {
                    "type": "method",
                    "define": "initWithSize(${1:#size_table size})"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Creates a new Scene object. \nreturn An autoreleased Scene object.\n"
                },
                "getPhysicsWorld": {
                    "type": "method",
                    "define": "getPhysicsWorld()",
                    "detail": " Get the physics world of the scene.\nreturn The physics world of the scene.\njs NA\n"
                }
            },
            "FadeOutDownTiles": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize})",
                    "detail": "brief Create the action with the grid size and the duration.\nparam duration Specify the duration of the FadeOutDownTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nreturn If the creation success, return a pointer of FadeOutDownTiles action; otherwise, return nil.\n"
                },
                "1": "new"
            },
            "GLProgram": {
                "1": "create",
                "2": "getProgram",
                "3": "getUniform",
                "4": "getVertexAttrib",
                "5": "new",
                "6": "setUniformLocationF32",
                "7": "setUniformLocationI32",
                "8": "setUniformLocationWith2iv",
                "9": "setUniformLocationWith3iv",
                "10": "setUniformLocationWith4iv",
                "11": "setUniformLocationWithMatrix2fv",
                "12": "setUniformLocationWithMatrix3fv",
                "13": "setUniformLocationWithMatrix4fv",
                "getVertexShaderLog": {
                    "type": "method",
                    "define": "getVertexShaderLog()",
                    "detail": " returns the vertexShader error log \n"
                },
                "reset": {
                    "type": "method",
                    "define": "reset()",
                    "detail": " Reload all shaders, this function is designed for android\nwhen opengl context lost, so don't call it.\n"
                },
                "initWithFilenames": {
                    "type": "method",
                    "define": "initWithFilenames(${1:#string vShaderFilename},${2:#string fShaderFilename},${3:#string compileTimeHeaders},${4:#string compileTimeDefines})",
                    "detail": "@overload self, string, string, string         \n@overload self, string, string         \n@overload self, string, string, string, string         \n"
                },
                "getFragmentShaderLog": {
                    "type": "method",
                    "define": "getFragmentShaderLog()",
                    "detail": " returns the fragmentShader error log \n"
                },
                "createWithByteArrays": {
                    "type": "method",
                    "define": "createWithByteArrays(${1:#char vShaderByteArray},${2:#char fShaderByteArray},${3:#string compileTimeHeaders},${4:#string compileTimeDefines})",
                    "detail": "@overload self, char, char, string         \n@overload self, char, char         \n@overload self, char, char, string, string         \n"
                },
                "use": {
                    "type": "method",
                    "define": "use()",
                    "detail": " it will call glUseProgram() \n"
                },
                "createWithFilenames": {
                    "type": "method",
                    "define": "createWithFilenames(${1:#string vShaderFilename},${2:#string fShaderFilename},${3:#string compileTimeHeaders},${4:#string compileTimeDefines})",
                    "detail": "@overload self, string, string, string         \n@overload self, string, string         \n@overload self, string, string, string, string         \n"
                },
                "bindAttribLocation": {
                    "type": "method",
                    "define": "bindAttribLocation(${1:#string attributeName},${2:#unsigned int index})",
                    "detail": "  It will add a new attribute to the shader by calling glBindAttribLocation. \n"
                },
                "updateUniforms": {
                    "type": "method",
                    "define": "updateUniforms()",
                    "detail": " It will create 4 uniforms:\n- kUniformPMatrix\n- kUniformMVMatrix\n- kUniformMVPMatrix\n- GLProgram::UNIFORM_SAMPLER\nAnd it will bind \"GLProgram::UNIFORM_SAMPLER\" to 0\n"
                },
                "setUniformsForBuiltins": {
                    "type": "method",
                    "define": "setUniformsForBuiltins(${1:#mat4_table modelView})",
                    "detail": "@overload self         \n@overload self, mat4_table         \n"
                },
                "initWithByteArrays": {
                    "type": "method",
                    "define": "initWithByteArrays(${1:#char vShaderByteArray},${2:#char fShaderByteArray},${3:#string compileTimeHeaders},${4:#string compileTimeDefines})",
                    "detail": "@overload self, char, char, string         \n@overload self, char, char         \n@overload self, char, char, string, string         \n"
                },
                "link": {
                    "type": "method",
                    "define": "link()",
                    "detail": " links the glProgram \n"
                },
                "getAttribLocation": {
                    "type": "method",
                    "define": "getAttribLocation(${1:#string attributeName})",
                    "detail": " Calls glGetAttribLocation. \n"
                }
            },
            "GLProgramCache": {
                "reloadDefaultGLProgramsRelativeToLights": {
                    "type": "method",
                    "define": "reloadDefaultGLProgramsRelativeToLights()",
                    "detail": " reload default programs these are relative to light \n"
                },
                "1": "new",
                "reloadDefaultGLPrograms": {
                    "type": "method",
                    "define": "reloadDefaultGLPrograms()",
                    "detail": " reload the default shaders \n"
                },
                "loadDefaultGLPrograms": {
                    "type": "method",
                    "define": "loadDefaultGLPrograms()",
                    "detail": " loads the default shaders \n"
                },
                "addGLProgram": {
                    "type": "method",
                    "define": "addGLProgram(${1:#cc.GLProgram program},${2:#string key})",
                    "detail": " adds a GLProgram to the cache for a given name \n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": " purges the cache. It releases the retained instance. \n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": " returns the shared instance \n"
                },
                "getGLProgram": {
                    "type": "method",
                    "define": "getGLProgram(${1:#string key})",
                    "detail": " returns a GL program for a given key \n"
                }
            },
            "CardinalSplineTo": {
                "1": "new",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#point_table points},${3:#float tension})",
                    "detail": "Initializes the action with a duration and an array of points.\nparam duration In seconds.\nparam points An PointArray.\nparam tension Goodness of fit.\n"
                },
                "getPoints": {
                    "type": "method",
                    "define": "getPoints()",
                    "detail": " Return a PointArray.\nreturn A PointArray.\n"
                },
                "updatePosition": {
                    "type": "method",
                    "define": "updatePosition(${1:#vec2_table newPos})",
                    "detail": " It will update the target position and change the _previousPosition to newPos\nparam newPos The new position.\n"
                }
            },
            "EaseQuinticActionIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "343": "rectEqualToRect",
            "Layer": {
                "1": "getTouchMode",
                "2": "isAccelerometerEnabled",
                "3": "isKeyboardEnabled",
                "4": "isSwallowsTouches",
                "5": "isTouchEnabled",
                "6": "new",
                "7": "registerScriptAccelerateHandler",
                "8": "registerScriptKeypadHandler",
                "9": "registerScriptTouchHandler",
                "10": "setAccelerometerEnabled",
                "11": "setAccelerometerInterval",
                "12": "setKeyboardEnabled",
                "13": "setSwallowsTouches",
                "14": "setTouchEnabled",
                "15": "setTouchMode",
                "16": "unregisterScriptAccelerateHandler",
                "17": "unregisterScriptKeypadHandler",
                "18": "unregisterScriptTouchHandler",
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Creates a fullscreen black layer.\nreturn An autoreleased Layer object.\n"
                }
            },
            "341": "rect",
            "TransitionMoveInB": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionMoveInB object.\n"
                },
                "1": "new"
            },
            "ControlStepper": {
                "1": "new",
                "setValueWithSendingEvent": {
                    "type": "method",
                    "define": "setValueWithSendingEvent(${1:#double value},${2:#bool send})",
                    "detail": " Set the numeric value of the stepper. If send is true, the Control::EventType::VALUE_CHANGED is sent. \n"
                },
                "stopAutorepeat": {
                    "type": "method",
                    "define": "stopAutorepeat()",
                    "detail": " Stop the autorepeat. \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Sprite minusSprite},${2:#cc.Sprite plusSprite})"
                },
                "setValue": {
                    "type": "method",
                    "define": "setValue(${1:#double value})"
                },
                "setMaximumValue": {
                    "type": "method",
                    "define": "setMaximumValue(${1:#double maximumValue})"
                },
                "setMinusSprite": {
                    "type": "method",
                    "define": "setMinusSprite(${1:#cc.Sprite var})"
                },
                "startAutorepeat": {
                    "type": "method",
                    "define": "startAutorepeat()",
                    "detail": " Start the autorepeat increment/decrement. \n"
                },
                "getMinusSprite": {
                    "type": "method",
                    "define": "getMinusSprite()"
                },
                "setMinimumValue": {
                    "type": "method",
                    "define": "setMinimumValue(${1:#double minimumValue})"
                },
                "getMinusLabel": {
                    "type": "method",
                    "define": "getMinusLabel()"
                },
                "updateLayoutUsingTouchLocation": {
                    "type": "method",
                    "define": "updateLayoutUsingTouchLocation(${1:#vec2_table location})",
                    "detail": " Update the layout of the stepper with the given touch location. \n"
                },
                "setStepValue": {
                    "type": "method",
                    "define": "setStepValue(${1:#double stepValue})"
                },
                "setMinusLabel": {
                    "type": "method",
                    "define": "setMinusLabel(${1:#cc.Label var})"
                },
                "getPlusLabel": {
                    "type": "method",
                    "define": "getPlusLabel()"
                },
                "setPlusLabel": {
                    "type": "method",
                    "define": "setPlusLabel(${1:#cc.Label var})"
                },
                "isContinuous": {
                    "type": "method",
                    "define": "isContinuous()"
                },
                "getPlusSprite": {
                    "type": "method",
                    "define": "getPlusSprite()"
                },
                "getValue": {
                    "type": "method",
                    "define": "getValue()"
                },
                "setWraps": {
                    "type": "method",
                    "define": "setWraps(${1:#bool wraps})"
                },
                "initWithMinusSpriteAndPlusSprite": {
                    "type": "method",
                    "define": "initWithMinusSpriteAndPlusSprite(${1:#cc.Sprite minusSprite},${2:#cc.Sprite plusSprite})"
                },
                "setPlusSprite": {
                    "type": "method",
                    "define": "setPlusSprite(${1:#cc.Sprite var})"
                }
            },
            "ComponentLua": {
                "1": "new",
                "getScriptObject": {
                    "type": "method",
                    "define": "getScriptObject()",
                    "detail": "This function is used to be invoked from lua side to get the corresponding script object of this component.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string scriptFileName})"
                },
                "update": {
                    "type": "method",
                    "define": "update(${1:#float dt})"
                }
            },
            "337": "pToAngleSelf",
            "MoveBy": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#vec2_table deltaPosition})",
                    "detail": "@overload self, float, vec3_table         \n@overload self, float, vec2_table         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#vec2_table deltaPosition})",
                    "detail": "@overload self, float, vec3_table         \n@overload self, float, vec2_table         \n"
                }
            },
            "351": "rectIntersectsRect",
            "EventListenerCustom": [
                "create",
                "new"
            ],
            "349": "rectGetMinY",
            "EventListenerKeyboard": {
                "1": "create",
                "2": "new",
                "3": "registerScriptHandler",
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": "/ Overrides\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                }
            },
            "347": "rectGetMidY",
            "SkewTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#float sx},${3:#float sy})",
                    "detail": "Creates the action.\nparam t Duration time, in seconds.\nparam sx Skew x angle.\nparam sy Skew y angle.\nreturn An autoreleased SkewTo object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#float sx},${3:#float sy})",
                    "detail": "param t In seconds.\n"
                }
            },
            "ClippingRectangleNode": {
                "isClippingEnabled": {
                    "type": "method",
                    "define": "isClippingEnabled()",
                    "detail": "brief Get whether the clipping is enabled or not.\nreturn Whether the clipping is enabled or not. Default is true.\n"
                },
                "setClippingRegion": {
                    "type": "method",
                    "define": "setClippingRegion(${1:#rect_table clippingRegion})",
                    "detail": "brief Set the clipping rectangle.\nparam clippingRegion Specify the clipping rectangle.\n"
                },
                "setClippingEnabled": {
                    "type": "method",
                    "define": "setClippingEnabled(${1:#bool enabled})",
                    "detail": "brief Enable/Disable the clipping.\nparam enabled Pass true to enable clipping. Pass false to disable clipping.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#rect_table clippingRegion})",
                    "detail": "@overload self         \n@overload self, rect_table         \n"
                },
                "getClippingRegion": {
                    "type": "method",
                    "define": "getClippingRegion()",
                    "detail": "brief Get the clipping rectangle.\nreturn The clipping rectangle.\n"
                }
            },
            "357": "vec3add",
            "TransitionFadeBL": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionFadeBL object.\n"
                },
                "1": "new"
            },
            "359": "vec3mul",
            "Touch": {
                "1": "getId",
                "2": "new",
                "getCurrentForce": {
                    "type": "method",
                    "define": "getCurrentForce()",
                    "detail": " Returns the current touch force for 3d touch.\nreturn The current touch force for 3d touch.\n"
                },
                "getMaxForce": {
                    "type": "method",
                    "define": "getMaxForce()",
                    "detail": " Returns the maximum touch force for 3d touch.\nreturn The maximum touch force for 3d touch.\n"
                },
                "setTouchInfo": {
                    "type": "method",
                    "define": "setTouchInfo(${1:#int id},${2:#float x},${3:#float y},${4:#float force},${5:#float maxForce})",
                    "detail": "@overload self, int, float, float, float, float         \n@overload self, int, float, float         \n"
                },
                "getStartLocation": {
                    "type": "method",
                    "define": "getStartLocation()",
                    "detail": " Returns the start touch location in OpenGL coordinates.\nreturn The start touch location in OpenGL coordinates.\n"
                },
                "getDelta": {
                    "type": "method",
                    "define": "getDelta()",
                    "detail": " Returns the delta of 2 current touches locations in screen coordinates.\nreturn The delta of 2 current touches locations in screen coordinates.\n"
                },
                "getStartLocationInView": {
                    "type": "method",
                    "define": "getStartLocationInView()",
                    "detail": " Returns the start touch location in screen coordinates.\nreturn The start touch location in screen coordinates.\n"
                },
                "getLocationInView": {
                    "type": "method",
                    "define": "getLocationInView()",
                    "detail": " Returns the current touch location in screen coordinates.\nreturn The current touch location in screen coordinates.\n"
                },
                "getLocation": {
                    "type": "method",
                    "define": "getLocation()",
                    "detail": " Returns the current touch location in OpenGL coordinates.\nreturn The current touch location in OpenGL coordinates.\n"
                },
                "getPreviousLocation": {
                    "type": "method",
                    "define": "getPreviousLocation()",
                    "detail": " Returns the previous touch location in OpenGL coordinates.\nreturn The previous touch location in OpenGL coordinates.\n"
                },
                "getPreviousLocationInView": {
                    "type": "method",
                    "define": "getPreviousLocationInView()",
                    "detail": " Returns the previous touch location in screen coordinates. \nreturn The previous touch location in screen coordinates.\n"
                }
            },
            "353": "size",
            "Timer": {
                "update": {
                    "type": "method",
                    "define": "update(${1:#float dt})",
                    "detail": " triggers the timer \n"
                },
                "trigger": {
                    "type": "method",
                    "define": "trigger(${1:#float dt})"
                },
                "cancel": {
                    "type": "method",
                    "define": "cancel()"
                },
                "isAborted": {
                    "type": "method",
                    "define": "isAborted()"
                },
                "setupTimerWithInterval": {
                    "type": "method",
                    "define": "setupTimerWithInterval(${1:#float seconds},${2:#unsigned int repeat},${3:#float delay})"
                },
                "setAborted": {
                    "type": "method",
                    "define": "setAborted()"
                },
                "getInterval": {
                    "type": "method",
                    "define": "getInterval()",
                    "detail": " get interval in seconds \n"
                },
                "setInterval": {
                    "type": "method",
                    "define": "setInterval(${1:#float interval})",
                    "detail": " set interval in seconds \n"
                }
            },
            "355": "vec2",
            "TileMapAtlas": {
                "1": "new",
                "releaseMap": {
                    "type": "method",
                    "define": "releaseMap()",
                    "detail": " dealloc the map from memory \n"
                },
                "setTile": {
                    "type": "method",
                    "define": "setTile(${1:#color3b_table tile},${2:#vec2_table position})",
                    "detail": " sets a tile at position x,y.\nFor the moment only channel R is used\n"
                },
                "initWithTileFile": {
                    "type": "method",
                    "define": "initWithTileFile(${1:#string tile},${2:#string mapFile},${3:#int tileWidth},${4:#int tileHeight})",
                    "detail": " initializes a TileMap with a tile file (atlas) with a map file and the width and height of each tile in points.\nThe file will be loaded using the TextureMgr.\n"
                },
                "getTileAt": {
                    "type": "method",
                    "define": "getTileAt(${1:#vec2_table position})",
                    "detail": "Returns a tile from position x,y.\nFor the moment only channel R is used\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string tile},${2:#string mapFile},${3:#int tileWidth},${4:#int tileHeight})",
                    "detail": " creates a TileMap with a tile file (atlas) with a map file and the width and height of each tile in points.\nThe tile file will be loaded using the TextureMgr.\n"
                }
            },
            "TextureCube": {
                "1": "new",
                "reloadTexture": {
                    "type": "method",
                    "define": "reloadTexture()",
                    "detail": " reload texture cube after GLESContext reconstructed.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string positive_x},${2:#string negative_x},${3:#string positive_y},${4:#string negative_y},${5:#string positive_z},${6:#string negative_z})",
                    "detail": " create cube texture from 6 textures.\nparam positive_x texture for the right side of the texture cube face.\nparam negative_x texture for the up side of the texture cube face.\nparam positive_y texture for the top side of the texture cube face\nparam negative_y texture for the bottom side of the texture cube face\nparam positive_z texture for the forward side of the texture cube face.\nparam negative_z texture for the rear side of the texture cube face.\nreturn  A new texture cube inited with given parameters.\n"
                },
                "setTexParameters": {
                    "type": "method",
                    "define": "setTexParameters(${1:#cc.Texture2D::_TexParams})",
                    "detail": " Sets the min filter, mag filter, wrap s and wrap t texture parameters.\nIf the texture size is NPOT (non power of 2), then in can only use GL_CLAMP_TO_EDGE in GL_TEXTURE_WRAP_{S,T}.\n"
                }
            },
            "EventListenerAcceleration": {
                "1": "create",
                "2": "new",
                "init": {
                    "type": "method",
                    "define": "init(${1:#function callback})"
                }
            },
            "Action": {
                "getTarget": {
                    "type": "method",
                    "define": "getTarget()",
                    "detail": " Return certain target.\nreturn A certain target.\n"
                },
                "getTag": {
                    "type": "method",
                    "define": "getTag()",
                    "detail": " Returns a tag that is used to identify the action easily. \nreturn A tag.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": " Returns a clone of action.\nreturn A clone action.\n"
                },
                "stop": {
                    "type": "method",
                    "define": "stop()",
                    "detail": "Called after the action has finished. It will set the 'target' to nil.\nIMPORTANT: You should never call \"Action::stop()\" manually. Instead, use: \"target->stopAction(action);\".\n"
                },
                "step": {
                    "type": "method",
                    "define": "step(${1:#float dt})",
                    "detail": " Called every frame with it's delta time, dt in seconds. DON'T override unless you know what you are doing. \nparam dt In seconds.\n"
                },
                "startWithTarget": {
                    "type": "method",
                    "define": "startWithTarget(${1:#cc.Node target})",
                    "detail": " Called before the action start. It will also set the target. \nparam target A certain target.\n"
                },
                "setTarget": {
                    "type": "method",
                    "define": "setTarget(${1:#cc.Node target})",
                    "detail": " The action will modify the target properties. \nparam target A certain target.\n"
                },
                "getOriginalTarget": {
                    "type": "method",
                    "define": "getOriginalTarget()",
                    "detail": " Return a original Target. \nreturn A original Target.\n"
                },
                "isDone": {
                    "type": "method",
                    "define": "isDone()",
                    "detail": " Return true if the action has finished. \nreturn Is true if the action has finished.\n"
                },
                "reverse": {
                    "type": "method",
                    "define": "reverse()",
                    "detail": " Returns a new action that performs the exact reverse of the action. \nreturn A new action that performs the exact reverse of the action.\njs NA\n"
                },
                "setFlags": {
                    "type": "method",
                    "define": "setFlags(${1:#unsigned int flags})",
                    "detail": " Changes the flag field that is used to group the actions easily.\nparam flags Used to group the actions easily.\n"
                },
                "setTag": {
                    "type": "method",
                    "define": "setTag(${1:#int tag})",
                    "detail": " Changes the tag that is used to identify the action easily. \nparam tag Used to identify the action easily.\n"
                },
                "setOriginalTarget": {
                    "type": "method",
                    "define": "setOriginalTarget(${1:#cc.Node originalTarget})",
                    "detail": "Set the original target, since target can be nil.\nIs the target that were used to run the action. Unless you are doing something complex, like ActionManager, you should NOT call this method.\nThe target is 'assigned', it is not 'retained'.\nsince v0.8.2\nparam originalTarget Is 'assigned', it is not 'retained'.\n"
                },
                "update": {
                    "type": "method",
                    "define": "update(${1:#float time})",
                    "detail": "Called once per frame. time a value between 0 and 1.\nFor example:\n- 0 Means that the action just started.\n- 0.5 Means that the action is in the middle.\n- 1 Means that the action is over.\nparam time A value between 0 and 1.\n"
                },
                "getFlags": {
                    "type": "method",
                    "define": "getFlags()",
                    "detail": " Returns a flag field that is used to group the actions easily.\nreturn A tag.\n"
                }
            },
            "Console": {
                "1": "addCommand",
                "2": "send",
                "stop": {
                    "type": "method",
                    "define": "stop()",
                    "detail": " stops the Console. 'stop' will be called at destruction time as well \n"
                },
                "delCommand": {
                    "type": "method",
                    "define": "delCommand(${1:#string cmdName})",
                    "detail": " delete custom command \n"
                },
                "getSubCommand": {
                    "type": "method",
                    "define": "getSubCommand(${1:#string cmdName},${2:#string subCmdName})",
                    "detail": "@overload self, cc.Console::Command, string         \n@overload self, string, string         \n"
                },
                "isIpv6Server": {
                    "type": "method",
                    "define": "isIpv6Server()",
                    "detail": " Checks whether the server for console is bound with ipv6 address \n"
                },
                "3": "wait",
                "getCommand": {
                    "type": "method",
                    "define": "getCommand(${1:#string cmdName})",
                    "detail": " get custom command \n"
                },
                "delSubCommand": {
                    "type": "method",
                    "define": "delSubCommand(${1:#string cmdName},${2:#string subCmdName})",
                    "detail": "@overload self, cc.Console::Command, string         \n@overload self, string, string         \n"
                },
                "listenOnFileDescriptor": {
                    "type": "method",
                    "define": "listenOnFileDescriptor(${1:#int fd})",
                    "detail": " starts listening to specified file descriptor \n"
                },
                "log": {
                    "type": "method",
                    "define": "log(${1:#char buf})",
                    "detail": " log something in the console \n"
                },
                "setBindAddress": {
                    "type": "method",
                    "define": "setBindAddress(${1:#string address})",
                    "detail": "set bind address\naddress : 127.0.0.1\n"
                },
                "listenOnTCP": {
                    "type": "method",
                    "define": "listenOnTCP(${1:#int port})",
                    "detail": " starts listening to specified TCP port \n"
                },
                "addSubCommand": {
                    "type": "method",
                    "define": "addSubCommand(${1:#string cmdName},${2:#cc.Console::Command subCmd})",
                    "detail": "@overload self, cc.Console::Command, cc.Console::Command         \n@overload self, string, cc.Console::Command         \n"
                }
            },
            "FadeOut": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float d})",
                    "detail": "Creates the action.\nparam d Duration time, in seconds.\n"
                },
                "setReverseAction": {
                    "type": "method",
                    "define": "setReverseAction(${1:#cc.FadeTo ac})",
                    "detail": "js NA\n"
                }
            },
            "TableViewCell": {
                "1": "new",
                "setIdx": {
                    "type": "method",
                    "define": "setIdx(${1:#int uIdx})"
                },
                "reset": {
                    "type": "method",
                    "define": "reset()",
                    "detail": "Cleans up any resources linked to this cell and resets <code>idx</code> property.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()"
                },
                "getIdx": {
                    "type": "method",
                    "define": "getIdx()",
                    "detail": "The index used internally by SWTableView and its subclasses\n"
                }
            },
            "363": "vertex2F",
            "PHYSICSBODY_MATERIAL_DEFAULT": [
                "density",
                "friction",
                "restitution"
            ],
            "TMXLayerInfo": {
                "1": "new",
                "setProperties": {
                    "type": "method",
                    "define": "setProperties(${1:#map_table properties})"
                },
                "getProperties": {
                    "type": "method",
                    "define": "getProperties()"
                }
            },
            "FadeOutUpTiles": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize})",
                    "detail": "brief Create the action with the grid size and the duration.\nparam duration Specify the duration of the FadeOutUpTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nreturn If the creation success, return a pointer of FadeOutUpTiles action; otherwise, return nil.\n"
                },
                "1": "new"
            },
            "Control": {
                "isSelected": {
                    "type": "method",
                    "define": "isSelected()"
                },
                "2": "registerControlEventHandler",
                "needsLayout": {
                    "type": "method",
                    "define": "needsLayout()",
                    "detail": "Updates the control layout using its current internal state.\n"
                },
                "setSelected": {
                    "type": "method",
                    "define": "setSelected(${1:#bool bSelected})",
                    "detail": " A Boolean value that determines the control selected state. \n"
                },
                "setHighlighted": {
                    "type": "method",
                    "define": "setHighlighted(${1:#bool bHighlighted})",
                    "detail": " A Boolean value that determines whether the control is highlighted. \n"
                },
                "getState": {
                    "type": "method",
                    "define": "getState()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Creates a Control object \n"
                },
                "sendActionsForControlEvents": {
                    "type": "method",
                    "define": "sendActionsForControlEvents(${1:#int controlEvents})",
                    "detail": "Sends action messages for the given control events.\nparam controlEvents A bitmask whose set flags specify the control events for\nwhich action messages are sent. See \"CCControlEvent\" for bitmask constants.\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool bEnabled})",
                    "detail": " Tells whether the control is enabled. \n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()"
                },
                "hasVisibleParents": {
                    "type": "method",
                    "define": "hasVisibleParents()"
                },
                "3": "unregisterControlEventHandler",
                "isTouchInside": {
                    "type": "method",
                    "define": "isTouchInside(${1:#cc.Touch touch})",
                    "detail": "Returns a boolean value that indicates whether a touch is inside the bounds\nof the receiver. The given touch must be relative to the world.\nparam touch A Touch object that represents a touch.\nreturn Whether a touch is inside the receiver's rect.\n"
                },
                "1": "new",
                "getTouchLocation": {
                    "type": "method",
                    "define": "getTouchLocation(${1:#cc.Touch touch})",
                    "detail": "Returns a point corresponding to the touch location converted into the\ncontrol space coordinates.\nparam touch A Touch object that represents a touch.\n"
                },
                "isHighlighted": {
                    "type": "method",
                    "define": "isHighlighted()"
                }
            },
            "SpriteBatchNode": {
                "1": "getDescendants",
                "2": "new",
                "addSpriteWithoutQuad": {
                    "type": "method",
                    "define": "addSpriteWithoutQuad(${1:#cc.Sprite child},${2:#int z},${3:#int aTag})"
                },
                "setTextureAtlas": {
                    "type": "method",
                    "define": "setTextureAtlas(${1:#cc.TextureAtlas textureAtlas})",
                    "detail": " Sets the TextureAtlas object. \nparam textureAtlas The TextureAtlas object.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "code\nWhen this function bound into js or lua,the parameter will be changed.\nIn js: var setBlendFunc(var src, var dst).\nendcode\nlua NA \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string fileImage},${2:#int capacity})",
                    "detail": " Creates a SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and capacity of children.\nThe capacity will be increased in 33% in runtime if it runs out of space.\nThe file will be loaded using the TextureMgr.\nparam fileImage A file image (.png, .jpeg, .pvr, etc).\nparam capacity The capacity of children.\nreturn Return an autorelease object.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "lua NA\n"
                },
                "insertQuadFromSprite": {
                    "type": "method",
                    "define": "insertQuadFromSprite(${1:#cc.Sprite sprite},${2:#int index})",
                    "detail": " Inserts a quad at a certain index into the texture atlas. The Sprite won't be added into the children array.\nThis method should be called only when you are dealing with very big AtlasSprite and when most of the Sprite won't be updated.\nFor example: a tile map (TMXMap) or a label with lots of characters (LabelBMFont).\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()"
                },
                "reserveCapacity": {
                    "type": "method",
                    "define": "reserveCapacity(${1:#int newCapacity})",
                    "detail": " reserves capacity for the batch node.\nIf the current capacity is bigger, nothing happens.\notherwise, a new capacity is allocated \n"
                },
                "initWithFile": {
                    "type": "method",
                    "define": "initWithFile(${1:#string fileImage},${2:#int capacity})",
                    "detail": " initializes a SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.\nThe capacity will be increased in 33% in runtime if it runs out of space.\nThe file will be loaded using the TextureMgr.\njs init\nlua init\n"
                },
                "getTextureAtlas": {
                    "type": "method",
                    "define": "getTextureAtlas()",
                    "detail": " Returns the TextureAtlas object. \nreturn The TextureAtlas object.\n"
                },
                "appendChild": {
                    "type": "method",
                    "define": "appendChild(${1:#cc.Sprite sprite})",
                    "detail": " Append the child. \nparam sprite A Sprite.\n"
                },
                "removeAllChildrenWithCleanup": {
                    "type": "method",
                    "define": "removeAllChildrenWithCleanup(${1:#bool cleanup})",
                    "detail": "js NA\n"
                },
                "createWithTexture": {
                    "type": "method",
                    "define": "createWithTexture(${1:#cc.Texture2D tex},${2:#int capacity})",
                    "detail": " Creates a SpriteBatchNode with a texture2d and capacity of children.\nThe capacity will be increased in 33% in runtime if it runs out of space.\nparam tex A texture2d.\nparam capacity The capacity of children.\nreturn Return an autorelease object.\n"
                },
                "reorderBatch": {
                    "type": "method",
                    "define": "reorderBatch(${1:#bool reorder})"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})"
                },
                "removeSpriteFromAtlas": {
                    "type": "method",
                    "define": "removeSpriteFromAtlas(${1:#cc.Sprite sprite})",
                    "detail": " Remove a sprite from Atlas. \nparam sprite A Sprite.\n"
                },
                "rebuildIndexInOrder": {
                    "type": "method",
                    "define": "rebuildIndexInOrder(${1:#cc.Sprite parent},${2:#int index})",
                    "detail": " Rebuild index with a sprite all child. \nparam parent The parent sprite.\nparam index The child index.\nreturn Index.\n"
                },
                "removeChildAtIndex": {
                    "type": "method",
                    "define": "removeChildAtIndex(${1:#int index},${2:#bool doCleanup})",
                    "detail": " Removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter.\nparam index A certain index.\nparam doCleanup Whether or not to cleanup the running actions.\nwarning Removing a child from a SpriteBatchNode is very slow.\n"
                },
                "initWithTexture": {
                    "type": "method",
                    "define": "initWithTexture(${1:#cc.Texture2D tex},${2:#int capacity})",
                    "detail": " initializes a SpriteBatchNode with a texture2d and capacity of children.\nThe capacity will be increased in 33% in runtime if it runs out of space.\n"
                },
                "highestAtlasIndexInChild": {
                    "type": "method",
                    "define": "highestAtlasIndexInChild(${1:#cc.Sprite sprite})",
                    "detail": " Get the Max image block index,in all child.\nparam sprite The parent sprite.\nreturn Index.\n"
                },
                "atlasIndexForChild": {
                    "type": "method",
                    "define": "atlasIndexForChild(${1:#cc.Sprite sprite},${2:#int z})",
                    "detail": " Get the nearest index from the sprite in z.\nparam sprite The parent sprite.\nparam z Z order for drawing priority.\nreturn Index.\n"
                },
                "lowestAtlasIndexInChild": {
                    "type": "method",
                    "define": "lowestAtlasIndexInChild(${1:#cc.Sprite sprite})",
                    "detail": " Get the Min image block index,in all child. \nparam sprite The parent sprite.\nreturn Index.\n"
                },
                "increaseAtlasCapacity": {
                    "type": "method",
                    "define": "increaseAtlasCapacity()",
                    "detail": " Increase the Atlas Capacity. \n"
                }
            },
            "DrawNode": {
                "1": "drawCardinalSpline",
                "2": "drawCatmullRom",
                "3": "drawPoints",
                "4": "drawPoly",
                "5": "drawPolygon",
                "6": "drawSolidPoly",
                "7": "new",
                "drawSolidRect": {
                    "type": "method",
                    "define": "drawSolidRect(${1:#vec2_table origin},${2:#vec2_table destination},${3:#color4f_table color})",
                    "detail": " Draws a solid rectangle given the origin and destination point measured in points.\nThe origin and the destination can not have the same x and y coordinate.\nparam origin The rectangle origin.\nparam destination The rectangle destination.\nparam color The rectangle color.\njs NA\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " creates and initialize a DrawNode node.\nreturn Return an autorelease object.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": " Get the color mixed mode.\nlua NA\n"
                },
                "setLineWidth": {
                    "type": "method",
                    "define": "setLineWidth(${1:#float lineWidth})"
                },
                "drawQuadBezier": {
                    "type": "method",
                    "define": "drawQuadBezier(${1:#vec2_table origin},${2:#vec2_table control},${3:#vec2_table destination},${4:#unsigned int segments},${5:#color4f_table color})",
                    "detail": " Draws a quad bezier path.\nparam origin The origin of the bezier path.\nparam control The control of the bezier path.\nparam destination The destination of the bezier path.\nparam segments The number of segments.\nparam color Set the quad bezier color.\n"
                },
                "drawSolidCircle": {
                    "type": "method",
                    "define": "drawSolidCircle(${1:#vec2_table center},${2:#float radius},${3:#float angle},${4:#unsigned int segments},${5:#float scaleX},${6:#float scaleY},${7:#color4f_table color})",
                    "detail": "@overload self, vec2_table, float, float, unsigned int, color4f_table         \n@overload self, vec2_table, float, float, unsigned int, float, float, color4f_table         \n"
                },
                "drawPoint": {
                    "type": "method",
                    "define": "drawPoint(${1:#vec2_table point},${2:#float pointSize},${3:#color4f_table color})",
                    "detail": " Draw a point.\nparam point A Vec2 used to point.\nparam pointSize The point size.\nparam color The point color.\njs NA\n"
                },
                "drawTriangle": {
                    "type": "method",
                    "define": "drawTriangle(${1:#vec2_table p1},${2:#vec2_table p2},${3:#vec2_table p3},${4:#color4f_table color})",
                    "detail": " draw a triangle with color. \nparam p1 The triangle vertex point.\nparam p2 The triangle vertex point.\nparam p3 The triangle vertex point.\nparam color The triangle color.\njs NA\n"
                },
                "drawCubicBezier": {
                    "type": "method",
                    "define": "drawCubicBezier(${1:#vec2_table origin},${2:#vec2_table control1},${3:#vec2_table control2},${4:#vec2_table destination},${5:#unsigned int segments},${6:#color4f_table color})",
                    "detail": " Draw a cubic bezier curve with color and number of segments\nparam origin The origin of the bezier path.\nparam control1 The first control of the bezier path.\nparam control2 The second control of the bezier path.\nparam destination The destination of the bezier path.\nparam segments The number of segments.\nparam color Set the cubic bezier color.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": " Set the color mixed mode.\ncode\nWhen this function bound into js or lua,the parameter will be changed\nIn js: var setBlendFunc(var src, var dst)\nendcode\nlua NA\n"
                },
                "onDraw": {
                    "type": "method",
                    "define": "onDraw(${1:#mat4_table transform},${2:#unsigned int flags})",
                    "detail": "js NA\n"
                },
                "getLineWidth": {
                    "type": "method",
                    "define": "getLineWidth()"
                },
                "onDrawGLPoint": {
                    "type": "method",
                    "define": "onDrawGLPoint(${1:#mat4_table transform},${2:#unsigned int flags})",
                    "detail": "js NA\n"
                },
                "drawCircle": {
                    "type": "method",
                    "define": "drawCircle(${1:#vec2_table center},${2:#float radius},${3:#float angle},${4:#unsigned int segments},${5:#bool drawLineToCenter},${6:#float scaleX},${7:#float scaleY},${8:#color4f_table color})",
                    "detail": "@overload self, vec2_table, float, float, unsigned int, bool, color4f_table         \n@overload self, vec2_table, float, float, unsigned int, bool, float, float, color4f_table         \n"
                },
                "drawLine": {
                    "type": "method",
                    "define": "drawLine(${1:#vec2_table origin},${2:#vec2_table destination},${3:#color4f_table color})",
                    "detail": " Draw an line from origin to destination with color. \nparam origin The line origin.\nparam destination The line destination.\nparam color The line color.\njs NA\n"
                },
                "onDrawGLLine": {
                    "type": "method",
                    "define": "onDrawGLLine(${1:#mat4_table transform},${2:#unsigned int flags})",
                    "detail": "js NA\n"
                },
                "drawRect": {
                    "type": "method",
                    "define": "drawRect(${1:#vec2_table p1},${2:#vec2_table p2},${3:#vec2_table p3},${4:#vec2_table p4},${5:#color4f_table color})",
                    "detail": "@overload self, vec2_table, vec2_table, vec2_table, vec2_table, color4f_table         \n@overload self, vec2_table, vec2_table, color4f_table         \n"
                },
                "drawSegment": {
                    "type": "method",
                    "define": "drawSegment(${1:#vec2_table from},${2:#vec2_table to},${3:#float radius},${4:#color4f_table color})",
                    "detail": " draw a segment with a radius and color. \nparam from The segment origin.\nparam to The segment destination.\nparam radius The segment radius.\nparam color The segment color.\n"
                },
                "clear": {
                    "type": "method",
                    "define": "clear()",
                    "detail": " Clear the geometry in the node's buffer. \n"
                },
                "drawDot": {
                    "type": "method",
                    "define": "drawDot(${1:#vec2_table pos},${2:#float radius},${3:#color4f_table color})",
                    "detail": " draw a dot at a position, with a given radius and color. \nparam pos The dot center.\nparam radius The dot radius.\nparam color The dot color.\n"
                }
            },
            "ShatteredTiles3D": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#int range},${4:#bool shatterZ})",
                    "detail": "brief Create the action with a range, whether of not to shatter Z vertices, grid size and duration.\nparam duration Specify the duration of the ShatteredTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam range Specify the range of the shatter effect.\nparam shatterZ Specify whether shatter on the z axis.\nreturn If the creation success, return a pointer of ShatteredTiles3D action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#int range},${4:#bool shatterZ})",
                    "detail": "brief Initializes the action with a range, shatter Z vertices, grid size and duration.\nparam duration Specify the duration of the ShatteredTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam range Specify the range of the shatter effect.\nparam shatterZ Specify whether shake on the z axis.\nreturn If the Initialization success, return true; otherwise, return false.\n"
                }
            },
            "EaseCircleActionOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "ControlSwitch": {
                "locationFromTouch": {
                    "type": "method",
                    "define": "locationFromTouch(${1:#cc.Touch touch})"
                },
                "hasMoved": {
                    "type": "method",
                    "define": "hasMoved()"
                },
                "isOn": {
                    "type": "method",
                    "define": "isOn()"
                },
                "setOn": {
                    "type": "method",
                    "define": "setOn(${1:#bool isOn},${2:#bool animated})",
                    "detail": "@overload self, bool         \n@overload self, bool, bool         \n"
                },
                "initWithMaskSprite": {
                    "type": "method",
                    "define": "initWithMaskSprite(${1:#cc.Sprite maskSprite},${2:#cc.Sprite onSprite},${3:#cc.Sprite offSprite},${4:#cc.Sprite thumbSprite},${5:#cc.Label onLabel},${6:#cc.Label offLabel})",
                    "detail": "@overload self, cc.Sprite, cc.Sprite, cc.Sprite, cc.Sprite, cc.Label, cc.Label         \n@overload self, cc.Sprite, cc.Sprite, cc.Sprite, cc.Sprite         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Sprite maskSprite},${2:#cc.Sprite onSprite},${3:#cc.Sprite offSprite},${4:#cc.Sprite thumbSprite},${5:#cc.Label onLabel},${6:#cc.Label offLabel})",
                    "detail": "@overload self, cc.Sprite, cc.Sprite, cc.Sprite, cc.Sprite         \n@overload self, cc.Sprite, cc.Sprite, cc.Sprite, cc.Sprite, cc.Label, cc.Label         \n"
                },
                "1": "new"
            },
            "ParticleFireworks": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a fireworks particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleFireworks object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a fireworks particle system.\nreturn An autoreleased ParticleFireworks object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "Repeat": {
                "1": "new",
                "setInnerAction": {
                    "type": "method",
                    "define": "setInnerAction(${1:#cc.FiniteTimeAction action})",
                    "detail": " Sets the inner action.\nparam action The inner action.\n"
                },
                "getInnerAction": {
                    "type": "method",
                    "define": "getInnerAction()",
                    "detail": " Gets the inner action.\nreturn The inner action.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.FiniteTimeAction action},${2:#unsigned int times})",
                    "detail": " Creates a Repeat action. Times is an unsigned integer between 1 and pow(2,30).\nparam action The action needs to repeat.\nparam times The repeat times.\nreturn An autoreleased Repeat object.\n"
                },
                "initWithAction": {
                    "type": "method",
                    "define": "initWithAction(${1:#cc.FiniteTimeAction pAction},${2:#unsigned int times})",
                    "detail": " initializes a Repeat action. Times is an unsigned integer between 1 and pow(2,30) \n"
                }
            },
            "EventListener": {
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()",
                    "detail": " Checks whether the listener is enabled.\nreturn True if the listener is enabled.\n"
                },
                "checkAvailable": {
                    "type": "method",
                    "define": "checkAvailable()",
                    "detail": " Checks whether the listener is available.\nreturn True if the listener is available.\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool enabled})",
                    "detail": " Enables or disables the listener.\nnote Only listeners with `enabled` state will be able to receive events.\nWhen an listener was initialized, it's enabled by default.\nAn event listener can receive events when it is enabled and is not paused.\npaused state is always false when it is a fixed priority listener.\nparam enabled True if enables the listener.\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": " Clones the listener, its subclasses have to override this method.\n"
                }
            },
            "RenderState": {
                "setParent": {
                    "type": "method",
                    "define": "setParent(${1:#cc.RenderState parent})"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})",
                    "detail": " Texture that will use in the CC_Texture0 uniform.\nAdded to be backwards compatible. Use Samplers from .material instead.\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()",
                    "detail": " Returns the texture that is going to be used for CC_Texture0.\nAdded to be backwards compatible.\n"
                },
                "getTopmost": {
                    "type": "method",
                    "define": "getTopmost(${1:#cc.RenderState below})",
                    "detail": "Returns the topmost RenderState in the hierarchy below the given RenderState.\n"
                },
                "bind": {
                    "type": "method",
                    "define": "bind(${1:#cc.Pass pass})",
                    "detail": "Binds the render state for this RenderState and any of its parents, top-down,\nfor the given pass.\n"
                },
                "getStateBlock": {
                    "type": "method",
                    "define": "getStateBlock()"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()"
                },
                "initialize": {
                    "type": "method",
                    "define": "initialize()",
                    "detail": "Static initializer that is called during game startup.\n"
                }
            },
            "LightFlag": [
                "LIGHT0",
                "LIGHT1",
                "LIGHT10",
                "LIGHT11",
                "LIGHT12",
                "LIGHT13",
                "LIGHT14",
                "LIGHT15",
                "LIGHT2",
                "LIGHT3",
                "LIGHT4",
                "LIGHT5",
                "LIGHT6",
                "LIGHT7",
                "LIGHT8",
                "LIGHT9"
            ],
            "MenuItemFont": {
                "1": "create",
                "2": "new",
                "getFontNameObj": {
                    "type": "method",
                    "define": "getFontNameObj()",
                    "detail": " Returns the name of the Font.\njs getFontNameObj\njs NA\n"
                },
                "getFontSizeObj": {
                    "type": "method",
                    "define": "getFontSizeObj()",
                    "detail": " get font size .\njs getFontSize\njs NA\n"
                },
                "setFontName": {
                    "type": "method",
                    "define": "setFontName(${1:#string name})",
                    "detail": " Set the default font name. \n"
                },
                "setFontSize": {
                    "type": "method",
                    "define": "setFontSize(${1:#int size})",
                    "detail": " Set default font size. \n"
                },
                "getFontName": {
                    "type": "method",
                    "define": "getFontName()",
                    "detail": " Get the default font name. \n"
                },
                "getFontSize": {
                    "type": "method",
                    "define": "getFontSize()",
                    "detail": " Get default font size. \n"
                },
                "setFontSizeObj": {
                    "type": "method",
                    "define": "setFontSizeObj(${1:#int size})",
                    "detail": " Set font size.\nc++ can not overload static and non-static member functions with the same parameter types.\nso change the name to setFontSizeObj.\njs setFontSize\njs NA\n"
                },
                "setFontNameObj": {
                    "type": "method",
                    "define": "setFontNameObj(${1:#string name})",
                    "detail": "Set the font name .\nc++ can not overload static and non-static member functions with the same parameter types.\nso change the name to setFontNameObj.\njs setFontName\njs NA\n"
                },
                "initWithString": {
                    "type": "method",
                    "define": "initWithString(${1:#string value},${2:#function callback})",
                    "detail": " Initializes a menu item from a string with a target/selector. \n"
                }
            },
            "ProgressFromTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float fromPercentage},${3:#float toPercentage})",
                    "detail": "brief Create and initializes the action with a duration, a \"from\" percentage and a \"to\" percentage.\nparam duration Specify the duration of the ProgressFromTo action. It's a value in seconds.\nparam fromPercentage Specify the source percentage.\nparam toPercentage Specify the destination percentage.\nreturn If the creation success, return a pointer of ProgressFromTo action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#float fromPercentage},${3:#float toPercentage})",
                    "detail": "brief Initializes the action with a duration, a \"from\" percentage and a \"to\" percentage.\nparam duration Specify the duration of the ProgressFromTo action. It's a value in seconds.\nparam fromPercentage Specify the source percentage.\nparam toPercentage Specify the destination percentage.\nreturn If the creation success, return true; otherwise, return false.\n"
                }
            },
            "AssetsManager": {
                "1": "new",
                "2": "setDelegate",
                "update": {
                    "type": "method",
                    "define": "update()"
                },
                "setConnectionTimeout": {
                    "type": "method",
                    "define": "setConnectionTimeout(${1:#unsigned int timeout})",
                    "detail": " @brief Sets connection time out in seconds\n"
                },
                "setStoragePath": {
                    "type": "method",
                    "define": "setStoragePath(${1:#char storagePath})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#char packageUrl},${2:#char versionFileUrl},${3:#char storagePath},${4:#function errorCallback},${5:#function progressCallback},${6:#function successCallback})"
                },
                "setPackageUrl": {
                    "type": "method",
                    "define": "setPackageUrl(${1:#char packageUrl})"
                },
                "checkUpdate": {
                    "type": "method",
                    "define": "checkUpdate()"
                },
                "setVersionFileUrl": {
                    "type": "method",
                    "define": "setVersionFileUrl(${1:#char versionFileUrl})"
                },
                "getPackageUrl": {
                    "type": "method",
                    "define": "getPackageUrl()"
                },
                "getConnectionTimeout": {
                    "type": "method",
                    "define": "getConnectionTimeout()",
                    "detail": " @brief Gets connection time out in seconds\n"
                },
                "getVersion": {
                    "type": "method",
                    "define": "getVersion()"
                },
                "getVersionFileUrl": {
                    "type": "method",
                    "define": "getVersionFileUrl()"
                },
                "deleteVersion": {
                    "type": "method",
                    "define": "deleteVersion()"
                },
                "getStoragePath": {
                    "type": "method",
                    "define": "getStoragePath()"
                }
            },
            "EaseBackOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "ParallaxNode": {
                "1": "new",
                "addChild": {
                    "type": "method",
                    "define": "addChild(${1:#cc.Node child},${2:#int zOrder},${3:#int tag})",
                    "detail": "@overload self, cc.Node, int, string         \n@overload self, cc.Node, int, int         \n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a Parallax node. \nreturn An autoreleased ParallaxNode object.\n"
                },
                "removeAllChildrenWithCleanup": {
                    "type": "method",
                    "define": "removeAllChildrenWithCleanup(${1:#bool cleanup})"
                }
            },
            "265": "UNIFORM_SIN_TIME_S",
            "ShakyTiles3D": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#int range},${4:#bool shakeZ})",
                    "detail": "brief Create the action with a range, shake Z vertices, a grid and duration.\nparam duration Specify the duration of the ShakyTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam range Specify the range of the shaky effect.\nparam shakeZ Specify whether shake on the z axis.\nreturn If the creation success, return a pointer of ShakyTiles3D action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#int range},${4:#bool shakeZ})",
                    "detail": "brief Initializes the action with a range, shake Z vertices, grid size and duration.\nparam duration Specify the duration of the ShakyTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam range Specify the range of the shaky effect.\nparam shakeZ Specify whether shake on the z axis.\nreturn If the Initialization success, return true; otherwise, return false.\n"
                }
            },
            "GridBase": {
                "blit": {
                    "type": "method",
                    "define": "blit()",
                    "detail": "Interface used to blit the texture with grid to screen.\n"
                },
                "calculateVertexPoints": {
                    "type": "method",
                    "define": "calculateVertexPoints()",
                    "detail": "Interface, Calculate the vertices used for the blit.\n"
                },
                "reuse": {
                    "type": "method",
                    "define": "reuse()",
                    "detail": "Interface, Reuse the grid vertices.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#size_table gridSize},${2:#cc.Texture2D texture},${3:#bool flipped})",
                    "detail": "@overload self, size_table         \n@overload self, size_table, cc.Texture2D, bool         \n"
                },
                "getReuseGrid": {
                    "type": "method",
                    "define": "getReuseGrid()",
                    "detail": " Get number of times that the grid will be reused. \n"
                },
                "afterBlit": {
                    "type": "method",
                    "define": "afterBlit()"
                },
                "beforeBlit": {
                    "type": "method",
                    "define": "beforeBlit()",
                    "detail": "@{\nInterface for custom action when before or after draw.\njs NA\n"
                },
                "setGridSize": {
                    "type": "method",
                    "define": "setGridSize(${1:#size_table gridSize})",
                    "detail": "Set the size of the grid.\n"
                },
                "setTextureFlipped": {
                    "type": "method",
                    "define": "setTextureFlipped(${1:#bool flipped})",
                    "detail": "Set the texture flipped or not.\n"
                },
                "setReuseGrid": {
                    "type": "method",
                    "define": "setReuseGrid(${1:#int reuseGrid})",
                    "detail": " Set number of times that the grid will be reused. \n"
                },
                "setStep": {
                    "type": "method",
                    "define": "setStep(${1:#vec2_table step})",
                    "detail": "Get the pixels between the grids.\n"
                },
                "getGridRect": {
                    "type": "method",
                    "define": "getGridRect()",
                    "detail": "brief Get the effect grid rect.\nreturn Return the effect grid rect.\n"
                },
                "isTextureFlipped": {
                    "type": "method",
                    "define": "isTextureFlipped()",
                    "detail": " is texture flipped. \n"
                },
                "getStep": {
                    "type": "method",
                    "define": "getStep()",
                    "detail": " Pixels between the grids. \n"
                },
                "getGridSize": {
                    "type": "method",
                    "define": "getGridSize()",
                    "detail": " Size of the grid. \n"
                },
                "setGridRect": {
                    "type": "method",
                    "define": "setGridRect(${1:#rect_table rect})",
                    "detail": "brief Set the effect grid rect.\nparam rect The effect grid rect.\n"
                },
                "beforeDraw": {
                    "type": "method",
                    "define": "beforeDraw()",
                    "detail": "@{\nInit and reset the status when render effects by using the grid.\n"
                },
                "isActive": {
                    "type": "method",
                    "define": "isActive()",
                    "detail": "@} @{\nGetter and setter of the active state of the grid.\n"
                },
                "afterDraw": {
                    "type": "method",
                    "define": "afterDraw(${1:#cc.Node target})"
                },
                "set2DProjection": {
                    "type": "method",
                    "define": "set2DProjection()",
                    "detail": "Change projection to 2D for grabbing.\n"
                },
                "setActive": {
                    "type": "method",
                    "define": "setActive(${1:#bool active})"
                },
                "initWithSize": {
                    "type": "method",
                    "define": "initWithSize(${1:#size_table gridSize},${2:#cc.Texture2D texture},${3:#bool flipped},${4:#rect_table rect})",
                    "detail": "@overload self, size_table, rect_table         \n@overload self, size_table         \n@overload self, size_table, cc.Texture2D, bool         \n@overload self, size_table, cc.Texture2D, bool, rect_table         \n"
                }
            },
            "Animation": {
                "1": "new",
                "getDelayPerUnit": {
                    "type": "method",
                    "define": "getDelayPerUnit()",
                    "detail": " Gets the delay in seconds of the \"delay unit\".\nreturn The delay in seconds of the \"delay unit\".\n"
                },
                "setRestoreOriginalFrame": {
                    "type": "method",
                    "define": "setRestoreOriginalFrame(${1:#bool restoreOriginalFrame})",
                    "detail": " Sets whether to restore the original frame when animation finishes. \nparam restoreOriginalFrame Whether to restore the original frame when animation finishes.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#array_table arrayOfAnimationFrameNames},${2:#float delayPerUnit},${3:#unsigned int loops})",
                    "detail": "@overload self, array_table, float, unsigned int         \n@overload self         \n"
                },
                "addSpriteFrameWithFile": {
                    "type": "method",
                    "define": "addSpriteFrameWithFile(${1:#string filename})",
                    "detail": " Adds a frame with an image filename. Internally it will create a SpriteFrame and it will add it.\nThe frame will be added with one \"delay unit\".\nAdded to facilitate the migration from v0.8 to v0.9.\nparam filename The path of SpriteFrame.\n"
                },
                "addSpriteFrameWithTexture": {
                    "type": "method",
                    "define": "addSpriteFrameWithTexture(${1:#cc.Texture2D pobTexture},${2:#rect_table rect})",
                    "detail": " Adds a frame with a texture and a rect. Internally it will create a SpriteFrame and it will add it.\nThe frame will be added with one \"delay unit\".\nAdded to facilitate the migration from v0.8 to v0.9.\nparam pobTexture A frame with a texture.\nparam rect The Texture of rect.\n"
                },
                "createWithSpriteFrames": {
                    "type": "method",
                    "define": "createWithSpriteFrames(${1:#array_table arrayOfSpriteFrameNames},${2:#float delay},${3:#unsigned int loops})"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": " Initializes a Animation. \n"
                },
                "getDuration": {
                    "type": "method",
                    "define": "getDuration()",
                    "detail": " Gets the duration in seconds of the whole animation. It is the result of totalDelayUnits * delayPerUnit.\nreturn Result of totalDelayUnits * delayPerUnit.\n"
                },
                "addSpriteFrame": {
                    "type": "method",
                    "define": "addSpriteFrame(${1:#cc.SpriteFrame frame})",
                    "detail": " Adds a SpriteFrame to a Animation.\nparam frame The frame will be added with one \"delay unit\".\n"
                },
                "clone": {
                    "type": "method",
                    "define": "clone()"
                },
                "setLoops": {
                    "type": "method",
                    "define": "setLoops(${1:#unsigned int loops})",
                    "detail": " Sets the times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ... \nparam loops The times the animation is going to loop.\n"
                },
                "setFrames": {
                    "type": "method",
                    "define": "setFrames(${1:#array_table frames})",
                    "detail": " Sets the array of AnimationFrames. \nparam frames The array of AnimationFrames.\n"
                },
                "getRestoreOriginalFrame": {
                    "type": "method",
                    "define": "getRestoreOriginalFrame()",
                    "detail": " Checks whether to restore the original frame when animation finishes. \nreturn Restore the original frame when animation finishes.\n"
                },
                "getLoops": {
                    "type": "method",
                    "define": "getLoops()",
                    "detail": " Gets the times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ... \nreturn The times the animation is going to loop.\n"
                },
                "initWithAnimationFrames": {
                    "type": "method",
                    "define": "initWithAnimationFrames(${1:#array_table arrayOfAnimationFrameNames},${2:#float delayPerUnit},${3:#unsigned int loops})",
                    "detail": " Initializes a Animation with AnimationFrame.\nsince v2.0\n"
                },
                "getTotalDelayUnits": {
                    "type": "method",
                    "define": "getTotalDelayUnits()",
                    "detail": " Gets the total Delay units of the Animation. \nreturn The total Delay units of the Animation.\n"
                },
                "setDelayPerUnit": {
                    "type": "method",
                    "define": "setDelayPerUnit(${1:#float delayPerUnit})",
                    "detail": " Sets the delay in seconds of the \"delay unit\".\nparam delayPerUnit The delay in seconds of the \"delay unit\".\n"
                },
                "getFrames": {
                    "type": "method",
                    "define": "getFrames()",
                    "detail": " Gets the array of AnimationFrames.\nreturn The array of AnimationFrames.\n"
                },
                "initWithSpriteFrames": {
                    "type": "method",
                    "define": "initWithSpriteFrames(${1:#array_table arrayOfSpriteFrameNames},${2:#float delay},${3:#unsigned int loops})",
                    "detail": " Initializes a Animation with frames and a delay between frames.\nsince v0.99.5\n"
                }
            },
            "Material": {
                "clone": {
                    "type": "method",
                    "define": "clone()",
                    "detail": " returns a clone (deep-copy) of the material \n"
                },
                "addTechnique": {
                    "type": "method",
                    "define": "addTechnique(${1:#cc.Technique technique})",
                    "detail": " Adds a Technique into the Material \n"
                },
                "getTechniqueByIndex": {
                    "type": "method",
                    "define": "getTechniqueByIndex(${1:#int index})",
                    "detail": " Returns a Technique by index. \nreturns `nullptr` if the index is invalid.\n"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()",
                    "detail": "/ returns the material name\n"
                },
                "getTechniques": {
                    "type": "method",
                    "define": "getTechniques()",
                    "detail": " Returns the list of Techniques \n"
                },
                "createWithFilename": {
                    "type": "method",
                    "define": "createWithFilename(${1:#string path})",
                    "detail": "Creates a Material using the data from the Properties object defined at the specified URL,\nwhere the URL is of the format \"<file-path>.<extension>#<namespace-id>/<namespace-id>/.../<namespace-id>\"\n(and \"#<namespace-id>/<namespace-id>/.../<namespace-id>\" is optional).\nparam url The URL pointing to the Properties object defining the material.\nreturn A new Material or NULL if there was an error.\n"
                },
                "setName": {
                    "type": "method",
                    "define": "setName(${1:#string name})",
                    "detail": "/ sets the material name\n"
                },
                "createWithProperties": {
                    "type": "method",
                    "define": "createWithProperties(${1:#cc.Properties materialProperties})",
                    "detail": "Creates a material from the specified properties object.\nparam materialProperties The properties object defining the\nmaterial (must have namespace equal to 'material').\nreturn A new Material.\n"
                },
                "getTechniqueCount": {
                    "type": "method",
                    "define": "getTechniqueCount()",
                    "detail": " Returns the number of Techniques in the Material. \n"
                },
                "createWithGLStateProgram": {
                    "type": "method",
                    "define": "createWithGLStateProgram(${1:#cc.GLProgramState programState})",
                    "detail": " Creates a Material with a GLProgramState.\nIt will only contain one Technique and one Pass.\nAdded in order to support legacy code.\n"
                },
                "setTechnique": {
                    "type": "method",
                    "define": "setTechnique(${1:#string techniqueName})",
                    "detail": " Sets the current technique \n"
                },
                "getTechnique": {
                    "type": "method",
                    "define": "getTechnique()",
                    "detail": " Returns the Technique used by the Material \n"
                },
                "getTechniqueByName": {
                    "type": "method",
                    "define": "getTechniqueByName(${1:#string name})",
                    "detail": " Returns a Technique by its name.\nreturns `nullptr` if the Technique can't be found.\n"
                }
            },
            "EaseBounceInOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "CatmullRomTo": {
                "1": "create",
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float dt},${2:#point_table points})",
                    "detail": "Initializes the action with a duration and an array of points.\nparam dt In seconds.\nparam points An PointArray.\n"
                }
            },
            "ActionFloat": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float from},${3:#float to},${4:#function callback})",
                    "detail": "Creates FloatAction with specified duration, from value, to value and callback to report back\nresults\nparam duration of the action\nparam from value to start from\nparam to value to be at the end of the action\nparam callback to report back result\nreturn An autoreleased ActionFloat object\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#float from},${3:#float to},${4:#function callback})"
                }
            },
            "ConfigType": [
                "COCOSTUDIO",
                "NONE"
            ],
            "257": "UNIFORM_MV_MATRIX_S",
            "Lens3D": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#vec2_table position},${4:#float radius})",
                    "detail": "brief Create the action with center position, radius, a grid size and duration.\nparam duration Specify the duration of the Lens3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam position Specify the center position of the lens.\nparam radius Specify the radius of the lens.\nreturn If the creation success, return a pointer of Lens3D action; otherwise, return nil.\n"
                },
                "setLensEffect": {
                    "type": "method",
                    "define": "setLensEffect(${1:#float lensEffect})",
                    "detail": "brief Set the value of lens effect.\nparam lensEffect The value of lens effect will be set.\n"
                },
                "setPosition": {
                    "type": "method",
                    "define": "setPosition(${1:#vec2_table position})",
                    "detail": "brief Set the center position of lens effect.\nparam position The center position will be set.\n"
                },
                "setConcave": {
                    "type": "method",
                    "define": "setConcave(${1:#bool concave})",
                    "detail": "brief Set whether lens is concave.\nparam concave Whether lens is concave.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#vec2_table position},${4:#float radius})",
                    "detail": "brief Initializes the action with center position, radius, grid size and duration.\nparam duration Specify the duration of the Lens3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam position Specify the center position of the lens effect.\nparam radius Specify the radius of the lens effect.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "getLensEffect": {
                    "type": "method",
                    "define": "getLensEffect()",
                    "detail": "brief Get the value of lens effect. Default value is 0.7.\nreturn The value of lens effect.\n"
                },
                "getPosition": {
                    "type": "method",
                    "define": "getPosition()",
                    "detail": "brief Get the center position of lens effect.\nreturn The center position of lens effect.\n"
                }
            },
            "EaseOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "1": "new"
            },
            "JumpBy": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#vec2_table position},${3:#float height},${4:#int jumps})",
                    "detail": "Creates the action.\nparam duration Duration time, in seconds.\nparam position The jumping distance.\nparam height The jumping height.\nparam jumps The jumping times.\nreturn An autoreleased JumpBy object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#vec2_table position},${3:#float height},${4:#int jumps})",
                    "detail": "initializes the action\nparam duration in seconds\n"
                }
            },
            "EventKeyboard": [
                "new"
            ],
            "GREEN": [
                "b",
                "g",
                "r"
            ],
            "NodeGrid": {
                "1": "new",
                "getGrid": {
                    "type": "method",
                    "define": "getGrid()",
                    "detail": "@overload self         \n@overload self         \n"
                },
                "setGridRect": {
                    "type": "method",
                    "define": "setGridRect(${1:#rect_table gridRect})",
                    "detail": "brief Set the effect grid rect.\nparam gridRect The effect grid rect.\n"
                },
                "setTarget": {
                    "type": "method",
                    "define": "setTarget(${1:#cc.Node target})",
                    "detail": " Set the Grid Target. \nparam target A Node is used to set the Grid Target.\n"
                },
                "getGridRect": {
                    "type": "method",
                    "define": "getGridRect()",
                    "detail": "brief Get the effect grid rect.\nreturn Return the effect grid rect.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#rect_table rect})",
                    "detail": "@overload self, rect_table         \n@overload self         \n"
                },
                "setGrid": {
                    "type": "method",
                    "define": "setGrid(${1:#cc.GridBase grid})",
                    "detail": "Changes a grid object that is used when applying effects.\nparam grid  A Grid object that is used when applying effects.\n"
                }
            },
            "EaseElasticOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "1": "new"
            },
            "TransitionSlideInR": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionSlideInR object.\n"
                },
                "1": "new"
            },
            "RepeatForever": {
                "1": "new",
                "setInnerAction": {
                    "type": "method",
                    "define": "setInnerAction(${1:#cc.ActionInterval action})",
                    "detail": " Sets the inner action.\nparam action The inner action.\n"
                },
                "getInnerAction": {
                    "type": "method",
                    "define": "getInnerAction()",
                    "detail": " Gets the inner action.\nreturn The inner action.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})",
                    "detail": " Creates the action.\nparam action The action need to repeat forever.\nreturn An autoreleased RepeatForever object.\n"
                },
                "initWithAction": {
                    "type": "method",
                    "define": "initWithAction(${1:#cc.ActionInterval action})",
                    "detail": " initializes the action \n"
                }
            },
            "SkewBy": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#float deltaSkewX},${3:#float deltaSkewY})",
                    "detail": "Creates the action.\nparam t Duration time, in seconds.\nparam deltaSkewX Skew x delta angle.\nparam deltaSkewY Skew y delta angle.\nreturn An autoreleased SkewBy object.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float t},${2:#float sx},${3:#float sy})",
                    "detail": "param t In seconds.\n"
                }
            },
            "Event": {
                "1": "new",
                "getCurrentTarget": {
                    "type": "method",
                    "define": "getCurrentTarget()",
                    "detail": " Gets current target of the event.\nreturn The target with which the event associates.\nnote It's only available when the event listener is associated with node.\nIt returns 0 when the listener is associated with fixed priority.\n"
                },
                "stopPropagation": {
                    "type": "method",
                    "define": "stopPropagation()",
                    "detail": " Stops propagation for current event.\n"
                },
                "isStopped": {
                    "type": "method",
                    "define": "isStopped()",
                    "detail": " Checks whether the event has been stopped.\nreturn True if the event has been stopped.\n"
                },
                "getType": {
                    "type": "method",
                    "define": "getType()",
                    "detail": " Gets the event type.\nreturn The event type.\n"
                }
            },
            "TransitionMoveInR": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionMoveInR object.\n"
                },
                "1": "new"
            },
            "287": "VERTICAL_TEXT_ALIGNMENT_TOP",
            "ProtectedNode": {
                "1": "getProtectedChildren",
                "2": "new",
                "getProtectedChildByTag": {
                    "type": "method",
                    "define": "getProtectedChildByTag(${1:#int tag})",
                    "detail": "Gets a child from the container with its tag.\nparam tag   An identifier to find the child node.\nreturn a Node object whose tag equals to the input parameter.\n"
                },
                "disableCascadeColor": {
                    "type": "method",
                    "define": "disableCascadeColor()"
                },
                "removeAllProtectedChildren": {
                    "type": "method",
                    "define": "removeAllProtectedChildren()",
                    "detail": "Removes all children from the container with a cleanup.\nsee `removeAllChildrenWithCleanup(bool)`.\n"
                },
                "removeAllProtectedChildrenWithCleanup": {
                    "type": "method",
                    "define": "removeAllProtectedChildrenWithCleanup(${1:#bool cleanup})",
                    "detail": "Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.\nparam cleanup   true if all running actions on all children nodes should be cleanup, false otherwise.\njs removeAllChildren\nlua removeAllChildren\n"
                },
                "sortAllProtectedChildren": {
                    "type": "method",
                    "define": "sortAllProtectedChildren()",
                    "detail": "Sorts the children array once before drawing, instead of every time when a child is added or reordered.\nThis approach can improves the performance massively.\nnote Don't call this manually unless a child added needs to be removed in the same frame\n"
                },
                "reorderProtectedChild": {
                    "type": "method",
                    "define": "reorderProtectedChild(${1:#cc.Node child},${2:#int localZOrder})",
                    "detail": "Reorders a child according to a new z value.\nparam child     An already added child node. It MUST be already added.\nparam localZOrder Z order for drawing priority. Please refer to setLocalZOrder(int)\n"
                },
                "removeProtectedChildByTag": {
                    "type": "method",
                    "define": "removeProtectedChildByTag(${1:#int tag},${2:#bool cleanup})",
                    "detail": "Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter.\nparam tag       An integer number that identifies a child node.\nparam cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": "Creates a ProtectedNode with no argument.\nreturn A instance of ProtectedNode.\n"
                },
                "removeProtectedChild": {
                    "type": "method",
                    "define": "removeProtectedChild(${1:#cc.Node child},${2:#bool cleanup})",
                    "detail": "Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter.\nparam child     The child node which will be removed.\nparam cleanup   true if all running actions and callbacks on the child node will be cleanup, false otherwise.\n"
                },
                "disableCascadeOpacity": {
                    "type": "method",
                    "define": "disableCascadeOpacity()"
                },
                "addProtectedChild": {
                    "type": "method",
                    "define": "addProtectedChild(${1:#cc.Node child},${2:#int localZOrder},${3:#int tag})",
                    "detail": "@overload self, cc.Node, int         \n@overload self, cc.Node         \n@overload self, cc.Node, int, int         \n"
                }
            },
            "273": "V3F_C4B_T2F",
            "Manifest": {
                "isLoaded": {
                    "type": "method",
                    "define": "isLoaded()",
                    "detail": " @brief Check whether the manifest have been fully loaded\n"
                },
                "getPackageUrl": {
                    "type": "method",
                    "define": "getPackageUrl()",
                    "detail": " @brief Gets remote package url.\n"
                },
                "isVersionLoaded": {
                    "type": "method",
                    "define": "isVersionLoaded()",
                    "detail": " @brief Check whether the version informations have been fully loaded\n"
                },
                "getSearchPaths": {
                    "type": "method",
                    "define": "getSearchPaths()",
                    "detail": " @brief Get the search paths list related to the Manifest.\n"
                },
                "getVersionFileUrl": {
                    "type": "method",
                    "define": "getVersionFileUrl()",
                    "detail": " @brief Gets remote version file url.\n"
                },
                "getVersion": {
                    "type": "method",
                    "define": "getVersion()",
                    "detail": " @brief Gets manifest version.\n"
                },
                "getManifestFileUrl": {
                    "type": "method",
                    "define": "getManifestFileUrl()",
                    "detail": " @brief Gets remote manifest file url.\n"
                }
            },
            "275": "VERTEX_ATTRIB_COLOR",
            "EaseQuadraticActionOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "TransitionZoomFlipX": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene s},${3:#int o})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, int         \n"
                },
                "1": "new"
            },
            "FadeOutTRTiles": {
                "1": "new",
                "turnOffTile": {
                    "type": "method",
                    "define": "turnOffTile(${1:#vec2_table pos})",
                    "detail": "brief Hide the tile at specified position.\nparam pos The position index of the tile should be hide.\n"
                },
                "transformTile": {
                    "type": "method",
                    "define": "transformTile(${1:#vec2_table pos},${2:#float distance})",
                    "detail": "brief Show part of the tile.\nparam pos The position index of the tile should be shown.\nparam distance The percentage that the tile should be shown.\n"
                },
                "turnOnTile": {
                    "type": "method",
                    "define": "turnOnTile(${1:#vec2_table pos})",
                    "detail": "brief Show the tile at specified position.\nparam pos The position index of the tile should be shown.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize})",
                    "detail": "brief Create the action with the grid size and the duration.\nparam duration Specify the duration of the FadeOutTRTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nreturn If the creation success, return a pointer of FadeOutTRTiles action; otherwise, return nil.\n"
                },
                "testFunc": {
                    "type": "method",
                    "define": "testFunc(${1:#size_table pos},${2:#float time})",
                    "detail": "brief Calculate the percentage a tile should be shown.\nparam pos The position index of the tile.\nparam time The current percentage of the action.\nreturn Return the percentage the tile should be shown.\n"
                }
            },
            "279": "VERTEX_ATTRIB_FLAG_POS_COLOR_TEX",
            "295": "WEBSOCKET_STATE_CONNECTING",
            "ParticleExplosion": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a explosion particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleExplosion object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a explosion particle system.\nreturn An autoreleased ParticleExplosion object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "TransitionProgressRadialCCW": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgressRadialCCW object.\n"
                },
                "1": "new"
            },
            "ShuffleTiles": {
                "1": "new",
                "getDelta": {
                    "type": "method",
                    "define": "getDelta(${1:#size_table pos})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int seed})",
                    "detail": "brief Create the action with grid size, random seed and duration.\nparam duration Specify the duration of the ShuffleTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam seed Specify the random seed.\nreturn If the creation success, return a pointer of ShuffleTiles action; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int seed})",
                    "detail": "brief Initializes the action with grid size, random seed and duration.\nparam duration Specify the duration of the ShuffleTiles action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam seed Specify the random seed.\nreturn If the Initialization success, return true; otherwise, return false.\n"
                }
            },
            "Sequence": {
                "1": "create",
                "2": "new",
                "initWithTwoActions": {
                    "type": "method",
                    "define": "initWithTwoActions(${1:#cc.FiniteTimeAction pActionOne},${2:#cc.FiniteTimeAction pActionTwo})",
                    "detail": " initializes the action \n"
                },
                "init": {
                    "type": "method",
                    "define": "init(${1:#array_table arrayOfActions})"
                }
            },
            "Sprite3DCache": {
                "1": "new",
                "removeAllSprite3DData": {
                    "type": "method",
                    "define": "removeAllSprite3DData()",
                    "detail": "remove all the SpriteData from Sprite3D\n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "get & destroy\n"
                },
                "removeSprite3DData": {
                    "type": "method",
                    "define": "removeSprite3DData(${1:#string key})",
                    "detail": "remove the SpriteData from Sprite3D by given the specified key\n"
                }
            },
            "ParticleMeteor": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a meteor particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleMeteor object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a meteor particle system.\nreturn An autoreleased ParticleMeteor object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "LabelEffect": [
                "GLOW",
                "NORMAL",
                "OUTLINE",
                "SHADOW"
            ],
            "PageTurn3D": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize})",
                    "detail": "brief Create an action with duration, grid size.\nparam duration Specify the duration of the PageTurn3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nreturn If the creation success, return a pointer of PageTurn3D action; otherwise, return nil.\n"
                }
            },
            "SpriteFrameCache": {
                "1": "addSpriteFrames",
                "2": "getSpriteFrame",
                "isSpriteFramesWithFileLoaded": {
                    "type": "method",
                    "define": "isSpriteFramesWithFileLoaded(${1:#string plist})",
                    "detail": " Check if multiple Sprite Frames from a plist file have been loaded.\njs NA\nlua NA\nparam plist Plist file name.\nreturn True if the file is loaded.\n"
                },
                "removeUnusedSpriteFrames": {
                    "type": "method",
                    "define": "removeUnusedSpriteFrames()",
                    "detail": " Removes unused sprite frames.\nSprite Frames that have a retain count of 1 will be deleted.\nIt is convenient to call this method after when starting a new Scene.\njs NA\n"
                },
                "removeSpriteFramesFromTexture": {
                    "type": "method",
                    "define": "removeSpriteFramesFromTexture(${1:#cc.Texture2D texture})",
                    "detail": " Removes all Sprite Frames associated with the specified textures.\nIt is convenient to call this method when a specific texture needs to be removed.\nsince v0.995.\nparam texture The texture that needs to removed.\n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": " Returns the shared instance of the Sprite Frame cache.\nreturn The instance of the Sprite Frame Cache.\njs NA\n"
                },
                "removeSpriteFramesFromFileContent": {
                    "type": "method",
                    "define": "removeSpriteFramesFromFileContent(${1:#string plist_content})",
                    "detail": " Removes multiple Sprite Frames from a plist file content.\nSprite Frames stored in this file will be removed.\nIt is convenient to call this method when a specific texture needs to be removed.\nparam plist_content The string of the plist content that needs to removed.\njs NA\n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": " Destroys the cache. It releases all the Sprite Frames and the retained instance.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()",
                    "detail": " Initialize method.\nreturn if success return true.\n"
                },
                "removeSpriteFrames": {
                    "type": "method",
                    "define": "removeSpriteFrames()",
                    "detail": " Purges the dictionary of loaded sprite frames.\nCall this method if you receive the \"Memory Warning\".\nIn the short term: it will free some resources preventing your app from being killed.\nIn the medium term: it will allocate more resources.\nIn the long term: it will be the same.\n"
                },
                "removeSpriteFramesFromFile": {
                    "type": "method",
                    "define": "removeSpriteFramesFromFile(${1:#string plist})",
                    "detail": " Removes multiple Sprite Frames from a plist file.\nSprite Frames stored in this file will be removed.\nIt is convenient to call this method when a specific texture needs to be removed.\nsince v0.99.5\nparam plist The name of the plist that needs to removed.\n"
                },
                "reloadTexture": {
                    "type": "method",
                    "define": "reloadTexture(${1:#string plist})"
                },
                "removeSpriteFrameByName": {
                    "type": "method",
                    "define": "removeSpriteFrameByName(${1:#string name})",
                    "detail": " Deletes an sprite frame from the sprite frame cache. \nparam name The name of the sprite frame that needs to removed.\n"
                },
                "addSpriteFramesWithFileContent": {
                    "type": "method",
                    "define": "addSpriteFramesWithFileContent(${1:#string plist_content},${2:#cc.Texture2D texture})",
                    "detail": " Adds multiple Sprite Frames from a plist file content. The texture will be associated with the created sprite frames. \njs NA\nlua addSpriteFrames\nparam plist_content Plist file content string.\nparam texture Texture pointer.\n"
                },
                "addSpriteFrame": {
                    "type": "method",
                    "define": "addSpriteFrame(${1:#cc.SpriteFrame frame},${2:#string frameName})",
                    "detail": " Adds an sprite frame with a given name.\nIf the name already exists, then the contents of the old name will be replaced with the new one.\nparam frame A certain sprite frame.\nparam frameName The name of the sprite frame.\n"
                }
            },
            "TransitionFadeUp": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionFadeUp object.\n"
                },
                "1": "new"
            },
            "GLViewImpl": {
                "createWithFullScreen": {
                    "type": "method",
                    "define": "createWithFullScreen(${1:#string viewName})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string viewname})"
                },
                "createWithRect": {
                    "type": "method",
                    "define": "createWithRect(${1:#string viewName},${2:#rect_table rect},${3:#float frameZoomFactor})"
                }
            },
            "EventCode": [
                "BEGAN",
                "CANCELLED",
                "ENDED",
                "MOVED"
            ],
            "EventListenerAssetsManagerEx": {
                "1": "create",
                "2": "new",
                "init": {
                    "type": "method",
                    "define": "init(${1:#cc.AssetsManagerEx AssetsManagerEx},${2:#function callback})",
                    "detail": " Initializes event with type and callback function \n"
                }
            },
            "297": "XMLHTTPREQUEST_RESPONSE_ARRAY_BUFFER",
            "KeyCode": [
                "KEY_0",
                "KEY_1",
                "KEY_2",
                "KEY_3",
                "KEY_4",
                "KEY_5",
                "KEY_6",
                "KEY_7",
                "KEY_8",
                "KEY_9",
                "KEY_A",
                "KEY_ALT",
                "KEY_AMPERSAND",
                "KEY_APOSTROPHE",
                "KEY_ASTERISK",
                "KEY_AT",
                "KEY_B",
                "KEY_BACK",
                "KEY_BACKSPACE",
                "KEY_BACK_SLASH",
                "KEY_BACK_TAB",
                "KEY_BAR",
                "KEY_BREAK",
                "KEY_C",
                "KEY_CAPITAL_A",
                "KEY_CAPITAL_B",
                "KEY_CAPITAL_C",
                "KEY_CAPITAL_D",
                "KEY_CAPITAL_E",
                "KEY_CAPITAL_F",
                "KEY_CAPITAL_G",
                "KEY_CAPITAL_H",
                "KEY_CAPITAL_I",
                "KEY_CAPITAL_J",
                "KEY_CAPITAL_K",
                "KEY_CAPITAL_L",
                "KEY_CAPITAL_M",
                "KEY_CAPITAL_N",
                "KEY_CAPITAL_O",
                "KEY_CAPITAL_P",
                "KEY_CAPITAL_Q",
                "KEY_CAPITAL_R",
                "KEY_CAPITAL_S",
                "KEY_CAPITAL_T",
                "KEY_CAPITAL_U",
                "KEY_CAPITAL_V",
                "KEY_CAPITAL_W",
                "KEY_CAPITAL_X",
                "KEY_CAPITAL_Y",
                "KEY_CAPITAL_Z",
                "KEY_CAPS_LOCK",
                "KEY_CIRCUMFLEX",
                "KEY_COLON",
                "KEY_COMMA",
                "KEY_CTRL",
                "KEY_D",
                "KEY_DELETE",
                "KEY_DOLLAR",
                "KEY_DOWN_ARROW",
                "KEY_DPAD_CENTER",
                "KEY_DPAD_DOWN",
                "KEY_DPAD_LEFT",
                "KEY_DPAD_RIGHT",
                "KEY_DPAD_UP",
                "KEY_E",
                "KEY_END",
                "KEY_ENTER",
                "KEY_EQUAL",
                "KEY_ESCAPE",
                "KEY_EURO",
                "KEY_EXCLAM",
                "KEY_F",
                "KEY_F1",
                "KEY_F10",
                "KEY_F11",
                "KEY_F12",
                "KEY_F2",
                "KEY_F3",
                "KEY_F4",
                "KEY_F5",
                "KEY_F6",
                "KEY_F7",
                "KEY_F8",
                "KEY_F9",
                "KEY_G",
                "KEY_GRAVE",
                "KEY_GREATER_THAN",
                "KEY_H",
                "KEY_HOME",
                "KEY_HYPER",
                "KEY_I",
                "KEY_INSERT",
                "KEY_J",
                "KEY_K",
                "KEY_KP_DELETE",
                "KEY_KP_DIVIDE",
                "KEY_KP_DOWN",
                "KEY_KP_END",
                "KEY_KP_ENTER",
                "KEY_KP_FIVE",
                "KEY_KP_HOME",
                "KEY_KP_INSERT",
                "KEY_KP_LEFT",
                "KEY_KP_MINUS",
                "KEY_KP_MULTIPLY",
                "KEY_KP_PG_DOWN",
                "KEY_KP_PG_UP",
                "KEY_KP_PLUS",
                "KEY_KP_RIGHT",
                "KEY_KP_UP",
                "KEY_L",
                "KEY_LEFT_ALT",
                "KEY_LEFT_ARROW",
                "KEY_LEFT_BRACE",
                "KEY_LEFT_BRACKET",
                "KEY_LEFT_CTRL",
                "KEY_LEFT_PARENTHESIS",
                "KEY_LEFT_SHIFT",
                "KEY_LESS_THAN",
                "KEY_M",
                "KEY_MENU",
                "KEY_MIDDLE_DOT",
                "KEY_MINUS",
                "KEY_N",
                "KEY_NONE",
                "KEY_NUMBER",
                "KEY_NUM_LOCK",
                "KEY_O",
                "KEY_P",
                "KEY_PAUSE",
                "KEY_PERCENT",
                "KEY_PERIOD",
                "KEY_PG_DOWN",
                "KEY_PG_UP",
                "KEY_PLAY",
                "KEY_PLUS",
                "KEY_POUND",
                "KEY_PRINT",
                "KEY_Q",
                "KEY_QUESTION",
                "KEY_QUOTE",
                "KEY_R",
                "KEY_RETURN",
                "KEY_RIGHT_ALT",
                "KEY_RIGHT_ARROW",
                "KEY_RIGHT_BRACE",
                "KEY_RIGHT_BRACKET",
                "KEY_RIGHT_CTRL",
                "KEY_RIGHT_PARENTHESIS",
                "KEY_RIGHT_SHIFT",
                "KEY_S",
                "KEY_SCROLL_LOCK",
                "KEY_SEARCH",
                "KEY_SEMICOLON",
                "KEY_SHIFT",
                "KEY_SLASH",
                "KEY_SPACE",
                "KEY_SYSREQ",
                "KEY_T",
                "KEY_TAB",
                "KEY_TILDE",
                "KEY_U",
                "KEY_UNDERSCORE",
                "KEY_UP_ARROW",
                "KEY_V",
                "KEY_W",
                "KEY_X",
                "KEY_Y",
                "KEY_YEN",
                "KEY_Z"
            ],
            "AutoPolygon": [
                "collector",
                "generatePolygon",
                "new"
            ],
            "RotateTo": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#float dstAngleX},${3:#float dstAngleY})",
                    "detail": "@overload self, float, float         \n@overload self, float, float, float         \n@overload self, float, vec3_table         \n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#float dstAngleX},${3:#float dstAngleY})",
                    "detail": "@overload self, float, vec3_table         \n@overload self, float, float, float         \n"
                }
            },
            "ParticleSpiral": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a spiral particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleSpiral object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a spiral particle system.\nreturn An autoreleased ParticleSpiral object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "RenderTexture": {
                "1": "endToLua",
                "2": "new",
                "setClearDepth": {
                    "type": "method",
                    "define": "setClearDepth(${1:#float clearDepth})",
                    "detail": " Set Value for clearDepth.\nparam clearDepth Value for clearDepth.\n"
                },
                "newImage": {
                    "type": "method",
                    "define": "newImage()"
                },
                "getClearFlags": {
                    "type": "method",
                    "define": "getClearFlags()",
                    "detail": " Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT. They can be OR'ed. Valid when \"autoDraw\" is true. \nreturn Clear flags.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#int w},${2:#int h},${3:#int format},${4:#unsigned int depthStencilFormat})",
                    "detail": "@overload self, int, int, int         \n@overload self, int, int, int, unsigned int         \n@overload self, int, int         \n"
                },
                "setAutoDraw": {
                    "type": "method",
                    "define": "setAutoDraw(${1:#bool isAutoDraw})",
                    "detail": " Set a valve to control whether or not render its children into the texture automatically. \nparam isAutoDraw Whether or not render its children into the texture automatically.\n"
                },
                "setClearColor": {
                    "type": "method",
                    "define": "setClearColor(${1:#color4f_table clearColor})",
                    "detail": " Set color value. \nparam clearColor Color value.\n"
                },
                "setVirtualViewport": {
                    "type": "method",
                    "define": "setVirtualViewport(${1:#vec2_table rtBegin},${2:#rect_table fullRect},${3:#rect_table fullViewport})",
                    "detail": "Used for grab part of screen to a texture. \nparam rtBegin The position of renderTexture on the fullRect.\nparam fullRect The total size of screen.\nparam fullViewport The total viewportSize.\n"
                },
                "setSprite": {
                    "type": "method",
                    "define": "setSprite(${1:#cc.Sprite sprite})",
                    "detail": " Sets the Sprite being used. \nparam sprite A Sprite.\n"
                },
                "getClearColor": {
                    "type": "method",
                    "define": "getClearColor()",
                    "detail": " Clear color value. Valid only when \"autoDraw\" is true. \nreturn Color value.\n"
                },
                "initWithWidthAndHeight": {
                    "type": "method",
                    "define": "initWithWidthAndHeight(${1:#int w},${2:#int h},${3:#int format},${4:#unsigned int depthStencilFormat})",
                    "detail": "@overload self, int, int, int, unsigned int         \n@overload self, int, int, int         \n"
                },
                "beginWithClear": {
                    "type": "method",
                    "define": "beginWithClear(${1:#float r},${2:#float g},${3:#float b},${4:#float a},${5:#float depthValue},${6:#int stencilValue})",
                    "detail": "@overload self, float, float, float, float, float         \n@overload self, float, float, float, float         \n@overload self, float, float, float, float, float, int         \n"
                },
                "saveToFile": {
                    "type": "method",
                    "define": "saveToFile(${1:#string filename},${2:#int format},${3:#bool isRGBA},${4:#function callback})",
                    "detail": "@overload self, string, int, bool, function         \n@overload self, string, bool, function         \n"
                },
                "getClearDepth": {
                    "type": "method",
                    "define": "getClearDepth()",
                    "detail": " Value for clearDepth. Valid only when \"autoDraw\" is true. \nreturn Value for clearDepth.\n"
                },
                "getSprite": {
                    "type": "method",
                    "define": "getSprite()",
                    "detail": " Gets the Sprite being used. \nreturn A Sprite.\n"
                },
                "setKeepMatrix": {
                    "type": "method",
                    "define": "setKeepMatrix(${1:#bool keepMatrix})",
                    "detail": " Flag: Use stack matrix computed from scene hierarchy or generate new modelView and projection matrix.\nparam keepMatrix Whether or not use stack matrix computed from scene hierarchy or generate new modelView and projection matrix.\njs NA\n"
                },
                "clearDepth": {
                    "type": "method",
                    "define": "clearDepth(${1:#float depthValue})",
                    "detail": " Clears the texture with a specified depth value. \nparam depthValue A specified depth value.\n"
                },
                "setClearFlags": {
                    "type": "method",
                    "define": "setClearFlags(${1:#unsigned int clearFlags})",
                    "detail": " Set flags.\nparam clearFlags Valid flags: GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT.\n"
                },
                "begin": {
                    "type": "method",
                    "define": "begin()",
                    "detail": " Starts grabbing. \n"
                },
                "clearStencil": {
                    "type": "method",
                    "define": "clearStencil(${1:#int stencilValue})",
                    "detail": " Clears the texture with a specified stencil value.\nparam stencilValue A specified stencil value.\n"
                },
                "getClearStencil": {
                    "type": "method",
                    "define": "getClearStencil()",
                    "detail": " Value for clear Stencil. Valid only when \"autoDraw\" is true.\nreturn Value for clear Stencil.\n"
                },
                "setClearStencil": {
                    "type": "method",
                    "define": "setClearStencil(${1:#int clearStencil})",
                    "detail": " Set Value for clear Stencil.\nparam clearStencil Value for clear Stencil.\n"
                },
                "clear": {
                    "type": "method",
                    "define": "clear(${1:#float r},${2:#float g},${3:#float b},${4:#float a})",
                    "detail": " Clears the texture with a color. \nparam r Red.\nparam g Green.\nparam b Blue.\nparam a Alpha.\n"
                },
                "isAutoDraw": {
                    "type": "method",
                    "define": "isAutoDraw()",
                    "detail": " When enabled, it will render its children into the texture automatically. Disabled by default for compatibility reasons.\nWill be enabled in the future.\nreturn Return the autoDraw value.\n"
                }
            },
            "FileUtils": {
                "1": "getDataFromFile",
                "2": "loadFilenameLookup",
                "isDirectoryExist": {
                    "type": "method",
                    "define": "isDirectoryExist(${1:#string fullPath},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "isPopupNotify": {
                    "type": "method",
                    "define": "isPopupNotify()",
                    "detail": " Checks whether to pop up a message box when failed to load an image.\nreturn True if pop up a message box when failed to load an image, false if not.\n"
                },
                "getValueMapFromFile": {
                    "type": "method",
                    "define": "getValueMapFromFile(${1:#string filename})",
                    "detail": "Converts the contents of a file to a ValueMap.\nparam filename The filename of the file to gets content.\nreturn ValueMap of the file contents.\nnote This method is used internally.\n"
                },
                "getFileSize": {
                    "type": "method",
                    "define": "getFileSize(${1:#string filepath},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "listFiles": {
                    "type": "method",
                    "define": "listFiles(${1:#string dirPath})",
                    "detail": "List all files in a directory.\nparam dirPath The path of the directory, it could be a relative or an absolute path.\nreturn File paths in a string vector\n"
                },
                "renameFile": {
                    "type": "method",
                    "define": "renameFile(${1:#string path},${2:#string oldname},${3:#string name},${4:#function callback})",
                    "detail": "@overload self, string, string, string, function         \n@overload self, string, string, string         \n@overload self, string, string         \n@overload self, string, string, function         \n"
                },
                "getDefaultResourceRootPath": {
                    "type": "method",
                    "define": "getDefaultResourceRootPath()",
                    "detail": "Get default resource root path.\n"
                },
                "removeDirectory": {
                    "type": "method",
                    "define": "removeDirectory(${1:#string dirPath},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": "Gets the instance of FileUtils.\n"
                },
                "createDirectory": {
                    "type": "method",
                    "define": "createDirectory(${1:#string dirPath},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "getSearchResolutionsOrder": {
                    "type": "method",
                    "define": "getSearchResolutionsOrder()",
                    "detail": "Gets the array that contains the search order of the resources.\nsee setSearchResolutionsOrder(const std::vector<std::string>&), fullPathForFilename(const char*).\nsince v2.1\nlua NA\n"
                },
                "getStringFromFile": {
                    "type": "method",
                    "define": "getStringFromFile(${1:#string path},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "setDefaultResourceRootPath": {
                    "type": "method",
                    "define": "setDefaultResourceRootPath(${1:#string path})",
                    "detail": "Set default resource root path.\n"
                },
                "setWritablePath": {
                    "type": "method",
                    "define": "setWritablePath(${1:#string writablePath})",
                    "detail": "Sets writable path.\n"
                },
                "getNewFilename": {
                    "type": "method",
                    "define": "getNewFilename(${1:#string filename})",
                    "detail": "Gets the new filename from the filename lookup dictionary.\nIt is possible to have a override names.\nparam filename The original filename.\nreturn The new filename after searching in the filename lookup dictionary.\nIf the original filename wasn't in the dictionary, it will return the original filename.\n"
                },
                "getValueVectorFromFile": {
                    "type": "method",
                    "define": "getValueVectorFromFile(${1:#string filename})"
                },
                "getSearchPaths": {
                    "type": "method",
                    "define": "getSearchPaths()",
                    "detail": "Gets the array of search paths.\nreturn The array of search paths which may contain the prefix of default resource root path. \nnote In best practise, getter function should return the value of setter function passes in.\nBut since we should not break the compatibility, we keep using the old logic. \nTherefore, If you want to get the original search paths, please call 'getOriginalSearchPaths()' instead.\nsee fullPathForFilename(const char*).\nlua NA\n"
                },
                "setFilenameLookupDictionary": {
                    "type": "method",
                    "define": "setFilenameLookupDictionary(${1:#map_table filenameLookupDict})",
                    "detail": "Sets the filenameLookup dictionary.\nparam filenameLookupDict The dictionary for replacing filename.\nsince v2.1\n"
                },
                "fullPathForFilename": {
                    "type": "method",
                    "define": "fullPathForFilename(${1:#string filename})",
                    "detail": " Returns the fullpath for a given filename.\nFirst it will try to get a new filename from the \"filenameLookup\" dictionary.\nIf a new filename can't be found on the dictionary, it will use the original filename.\nThen it will try to obtain the full path of the filename using the FileUtils search rules: resolutions, and search paths.\nThe file search is based on the array element order of search paths and resolution directories.\nFor instance:\nWe set two elements(\"/mnt/sdcard/\", \"internal_dir/\") to search paths vector by setSearchPaths,\nand set three elements(\"resources-ipadhd/\", \"resources-ipad/\", \"resources-iphonehd\")\nto resolutions vector by setSearchResolutionsOrder. The \"internal_dir\" is relative to \"Resources/\".\nIf we have a file named 'sprite.png', the mapping in fileLookup dictionary contains `key: sprite.png -> value: sprite.pvr.gz`.\nFirstly, it will replace 'sprite.png' with 'sprite.pvr.gz', then searching the file sprite.pvr.gz as follows:\n/mnt/sdcard/resources-ipadhd/sprite.pvr.gz      (if not found, search next)\n/mnt/sdcard/resources-ipad/sprite.pvr.gz        (if not found, search next)\n/mnt/sdcard/resources-iphonehd/sprite.pvr.gz    (if not found, search next)\n/mnt/sdcard/sprite.pvr.gz                       (if not found, search next)\ninternal_dir/resources-ipadhd/sprite.pvr.gz     (if not found, search next)\ninternal_dir/resources-ipad/sprite.pvr.gz       (if not found, search next)\ninternal_dir/resources-iphonehd/sprite.pvr.gz   (if not found, search next)\ninternal_dir/sprite.pvr.gz                      (if not found, return \"sprite.png\")\nIf the filename contains relative path like \"gamescene/uilayer/sprite.png\",\nand the mapping in fileLookup dictionary contains `key: gamescene/uilayer/sprite.png -> value: gamescene/uilayer/sprite.pvr.gz`.\nThe file search order will be:\n/mnt/sdcard/gamescene/uilayer/resources-ipadhd/sprite.pvr.gz      (if not found, search next)\n/mnt/sdcard/gamescene/uilayer/resources-ipad/sprite.pvr.gz        (if not found, search next)\n/mnt/sdcard/gamescene/uilayer/resources-iphonehd/sprite.pvr.gz    (if not found, search next)\n/mnt/sdcard/gamescene/uilayer/sprite.pvr.gz                       (if not found, search next)\ninternal_dir/gamescene/uilayer/resources-ipadhd/sprite.pvr.gz     (if not found, search next)\ninternal_dir/gamescene/uilayer/resources-ipad/sprite.pvr.gz       (if not found, search next)\ninternal_dir/gamescene/uilayer/resources-iphonehd/sprite.pvr.gz   (if not found, search next)\ninternal_dir/gamescene/uilayer/sprite.pvr.gz                      (if not found, return \"gamescene/uilayer/sprite.png\")\nIf the new file can't be found on the file system, it will return the parameter filename directly.\nThis method was added to simplify multiplatform support. Whether you are using cocos2d-js or any cross-compilation toolchain like StellaSDK or Apportable,\nyou might need to load different resources for a given file in the different platforms.\nsince v2.1\n"
                },
                "addSearchResolutionsOrder": {
                    "type": "method",
                    "define": "addSearchResolutionsOrder(${1:#string order},${2:#bool front})",
                    "detail": "Append search order of the resources.\nsee setSearchResolutionsOrder(), fullPathForFilename().\nsince v2.1\n"
                },
                "getWritablePath": {
                    "type": "method",
                    "define": "getWritablePath()",
                    "detail": "Gets the writable path.\nreturn  The path that can be write/read a file in\n"
                },
                "getFileExtension": {
                    "type": "method",
                    "define": "getFileExtension(${1:#string filePath})",
                    "detail": "Gets filename extension is a suffix (separated from the base filename by a dot) in lower case.\nExamples of filename extensions are .png, .jpeg, .exe, .dmg and .txt.\nparam filePath The path of the file, it could be a relative or absolute path.\nreturn suffix for filename in lower case or empty if a dot not found.\n"
                },
                "writeValueVectorToFile": {
                    "type": "method",
                    "define": "writeValueVectorToFile(${1:#array_table vecData},${2:#string fullPath},${3:#function callback})",
                    "detail": "@overload self, array_table, string, function         \n@overload self, array_table, string         \n"
                },
                "writeValueMapToFile": {
                    "type": "method",
                    "define": "writeValueMapToFile(${1:#map_table dict},${2:#string fullPath},${3:#function callback})",
                    "detail": "@overload self, map_table, string, function         \n@overload self, map_table, string         \n"
                },
                "setPopupNotify": {
                    "type": "method",
                    "define": "setPopupNotify(${1:#bool notify})",
                    "detail": "Sets whether to pop-up a message box when failed to load an image.\n"
                },
                "isFileExist": {
                    "type": "method",
                    "define": "isFileExist(${1:#string filename},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "purgeCachedEntries": {
                    "type": "method",
                    "define": "purgeCachedEntries()",
                    "detail": "Purges full path caches.\n"
                },
                "writeStringToFile": {
                    "type": "method",
                    "define": "writeStringToFile(${1:#string dataStr},${2:#string fullPath},${3:#function callback})",
                    "detail": "@overload self, string, string, function         \n@overload self, string, string         \n"
                },
                "writeToFile": {
                    "type": "method",
                    "define": "writeToFile(${1:#map_table dict},${2:#string fullPath})",
                    "detail": "write a ValueMap into a plist file\nparam dict the ValueMap want to save\nparam fullPath The full path to the file you want to save a string\nreturn bool\n"
                },
                "getSuitableFOpen": {
                    "type": "method",
                    "define": "getSuitableFOpen(${1:#string filenameUtf8})",
                    "detail": "Windows fopen can't support UTF-8 filename\nNeed convert all parameters fopen and other 3rd-party libs\nparam filenameUtf8 std::string name file for conversion from utf-8\nreturn std::string ansi filename in current locale\n"
                },
                "removeFile": {
                    "type": "method",
                    "define": "removeFile(${1:#string filepath},${2:#function callback})",
                    "detail": "@overload self, string, function         \n@overload self, string         \n"
                },
                "addSearchPath": {
                    "type": "method",
                    "define": "addSearchPath(${1:#string path},${2:#bool front})",
                    "detail": "Add search path.\nsince v2.1\n"
                },
                "setSearchPaths": {
                    "type": "method",
                    "define": "setSearchPaths(${1:#array_table searchPaths})",
                    "detail": "Sets the array of search paths.\nYou can use this array to modify the search path of the resources.\nIf you want to use \"themes\" or search resources in the \"cache\", you can do it easily by adding new entries in this array.\nnote This method could access relative path and absolute path.\nIf the relative path was passed to the vector, FileUtils will add the default resource directory before the relative path.\nFor instance:\nOn Android, the default resource root path is \"assets/\".\nIf \"/mnt/sdcard/\" and \"resources-large\" were set to the search paths vector,\n\"resources-large\" will be converted to \"assets/resources-large\" since it was a relative path.\nparam searchPaths The array contains search paths.\nsee fullPathForFilename(const char*)\nsince v2.1\nIn js:var setSearchPaths(var jsval);\nlua NA\n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": "Destroys the instance of FileUtils.\n"
                },
                "getOriginalSearchPaths": {
                    "type": "method",
                    "define": "getOriginalSearchPaths()",
                    "detail": "Gets the original search path array set by 'setSearchPaths' or 'addSearchPath'.\nreturn The array of the original search paths\n"
                },
                "fullPathFromRelativeFile": {
                    "type": "method",
                    "define": "fullPathFromRelativeFile(${1:#string filename},${2:#string relativeFile})",
                    "detail": "Gets full path from a file name and the path of the relative file.\nparam filename The file name.\nparam relativeFile The path of the relative file.\nreturn The full path.\ne.g. filename: hello.png, pszRelativeFile: /User/path1/path2/hello.plist\nReturn: /User/path1/path2/hello.pvr (If there a a key(hello.png)-value(hello.pvr) in FilenameLookup dictionary. )\n"
                },
                "setSearchResolutionsOrder": {
                    "type": "method",
                    "define": "setSearchResolutionsOrder(${1:#array_table searchResolutionsOrder})",
                    "detail": "Sets the array that contains the search order of the resources.\nparam searchResolutionsOrder The source array that contains the search order of the resources.\nsee getSearchResolutionsOrder(), fullPathForFilename(const char*).\nsince v2.1\nIn js:var setSearchResolutionsOrder(var jsval)\nlua NA\n"
                },
                "listFilesRecursively": {
                    "type": "method",
                    "define": "listFilesRecursively(${1:#string dirPath},${2:#array_table files})",
                    "detail": "List all files recursively in a directory.\nparam dirPath The path of the directory, it could be a relative or an absolute path.\nreturn File paths in a string vector\n"
                },
                "getValueMapFromData": {
                    "type": "method",
                    "define": "getValueMapFromData(${1:#char filedata},${2:#int filesize})",
                    "detail": " Converts the contents of a file to a ValueMap.\nThis method is used internally.\n"
                },
                "isAbsolutePath": {
                    "type": "method",
                    "define": "isAbsolutePath(${1:#string path})",
                    "detail": "Checks whether the path is an absolute path.\nnote On Android, if the parameter passed in is relative to \"assets/\", this method will treat it as an absolute path.\nAlso on Blackberry, path starts with \"app/native/Resources/\" is treated as an absolute path.\nparam path The path that needs to be checked.\nreturn True if it's an absolute path, false if not.\n"
                }
            },
            "EventDispatcher": {
                "1": "new",
                "dispatchCustomEvent": {
                    "type": "method",
                    "define": "dispatchCustomEvent(${1:#string eventName},${2:#void optionalUserData})",
                    "detail": " Dispatches a Custom Event with a event name an optional user data.\nparam eventName The name of the event which needs to be dispatched.\nparam optionalUserData The optional user data, it's a void*, the default value is nullptr.\n"
                },
                "setPriority": {
                    "type": "method",
                    "define": "setPriority(${1:#cc.EventListener listener},${2:#int fixedPriority})",
                    "detail": " Sets listener's priority with fixed value.\nparam listener A given listener.\nparam fixedPriority The fixed priority value.\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool isEnabled})",
                    "detail": " Whether to enable dispatching events.\nparam isEnabled  True if enable dispatching events.\n"
                },
                "addCustomEventListener": {
                    "type": "method",
                    "define": "addCustomEventListener(${1:#string eventName},${2:#function callback})",
                    "detail": " Adds a Custom event listener.\nIt will use a fixed priority of 1.\nparam eventName A given name of the event.\nparam callback A given callback method that associated the event name.\nreturn the generated event. Needed in order to remove the event from the dispatcher\n"
                },
                "removeEventListenersForTarget": {
                    "type": "method",
                    "define": "removeEventListenersForTarget(${1:#cc.Node target},${2:#bool recursive})",
                    "detail": " Removes all listeners which are associated with the specified target.\nparam target A given target node.\nparam recursive True if remove recursively, the default value is false.\n"
                },
                "addEventListenerWithFixedPriority": {
                    "type": "method",
                    "define": "addEventListenerWithFixedPriority(${1:#cc.EventListener listener},${2:#int fixedPriority})",
                    "detail": " Adds a event listener for a specified event with the fixed priority.\nparam listener The listener of a specified event.\nparam fixedPriority The fixed priority of the listener.\nnote A lower priority will be called before the ones that have a higher value.\n0 priority is forbidden for fixed priority since it's used for scene graph based priority.\n"
                },
                "addEventListenerWithSceneGraphPriority": {
                    "type": "method",
                    "define": "addEventListenerWithSceneGraphPriority(${1:#cc.EventListener listener},${2:#cc.Node node})",
                    "detail": " Adds a event listener for a specified event with the priority of scene graph.\nparam listener The listener of a specified event.\nparam node The priority of the listener is based on the draw order of this node.\nnote  The priority of scene graph will be fixed value 0. So the order of listener item\nin the vector will be ' <0, scene graph (0 priority), >0'.\n"
                },
                "removeCustomEventListeners": {
                    "type": "method",
                    "define": "removeCustomEventListeners(${1:#string customEventName})",
                    "detail": " Removes all custom listeners with the same event name.\nparam customEventName A given event listener name which needs to be removed.\n"
                },
                "pauseEventListenersForTarget": {
                    "type": "method",
                    "define": "pauseEventListenersForTarget(${1:#cc.Node target},${2:#bool recursive})",
                    "detail": " Pauses all listeners which are associated the specified target.\nparam target A given target node.\nparam recursive True if pause recursively, the default value is false.\n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()",
                    "detail": " Checks whether dispatching events is enabled.\nreturn True if dispatching events is enabled.\n"
                },
                "removeEventListenersForType": {
                    "type": "method",
                    "define": "removeEventListenersForType(${1:#int listenerType})",
                    "detail": " Removes all listeners with the same event listener type.\nparam listenerType A given event listener type which needs to be removed.\n"
                },
                "resumeEventListenersForTarget": {
                    "type": "method",
                    "define": "resumeEventListenersForTarget(${1:#cc.Node target},${2:#bool recursive})",
                    "detail": " Resumes all listeners which are associated the specified target.\nparam target A given target node.\nparam recursive True if resume recursively, the default value is false.\n"
                },
                "removeEventListener": {
                    "type": "method",
                    "define": "removeEventListener(${1:#cc.EventListener listener})",
                    "detail": " Remove a listener.\nparam listener The specified event listener which needs to be removed.\n"
                },
                "removeAllEventListeners": {
                    "type": "method",
                    "define": "removeAllEventListeners()",
                    "detail": " Removes all listeners.\n"
                },
                "dispatchEvent": {
                    "type": "method",
                    "define": "dispatchEvent(${1:#cc.Event event})",
                    "detail": " Dispatches the event.\nAlso removes all EventListeners marked for deletion from the\nevent dispatcher list.\nparam event The event needs to be dispatched.\n"
                },
                "hasEventListener": {
                    "type": "method",
                    "define": "hasEventListener(${1:#std::basic_string<char> listenerID})",
                    "detail": " Query whether the specified event listener id has been added.\nparam listenerID The listenerID of the event listener id.\nreturn True if dispatching events is exist\n"
                }
            },
            "305": "Z_COMPRESSION_ZLIB",
            "TransitionTurnOffTiles": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionTurnOffTiles object.\n"
                },
                "easeActionWithAction": {
                    "type": "method",
                    "define": "easeActionWithAction(${1:#cc.ActionInterval action})"
                }
            },
            "319": "pFuzzyEqual",
            "FlipY3D": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration})",
                    "detail": "brief Create the action with duration.\nparam duration Specify the duration of the FlipY3D action. It's a value in seconds.\nreturn If the creation success, return a pointer of FlipY3D action; otherwise, return nil.\n"
                },
                "1": "new"
            },
            "317": "pForAngle",
            "GLNode": [
                "collector",
                "create",
                "registerScriptDrawHandler",
                "setShaderProgram",
                "unregisterScriptDrawHandler"
            ],
            "TransitionFadeDown": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn A autoreleased TransitionFadeDown object.\n"
                },
                "1": "new"
            },
            "EaseElasticIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action},${2:#float rate})"
                },
                "1": "new"
            },
            "313": "pAdd",
            "AnimationCache": {
                "1": "addAnimations",
                "2": "new",
                "removeAnimation": {
                    "type": "method",
                    "define": "removeAnimation(${1:#string name})",
                    "detail": " Deletes a Animation from the cache.\nparam name The name of animation.\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "getInstance": {
                    "type": "method",
                    "define": "getInstance()",
                    "detail": " Returns the shared instance of the Animation cache \njs NA\n"
                },
                "addAnimation": {
                    "type": "method",
                    "define": "addAnimation(${1:#cc.Animation animation},${2:#string name})",
                    "detail": " Adds a Animation with a name.\nparam animation An animation.\nparam name The name of animation.\n"
                },
                "destroyInstance": {
                    "type": "method",
                    "define": "destroyInstance()",
                    "detail": " Purges the cache. It releases all the Animation objects and the shared instance.\njs NA\n"
                },
                "getAnimation": {
                    "type": "method",
                    "define": "getAnimation(${1:#string name})",
                    "detail": " Returns a Animation that was previously added.\nIf the name is not found it will return nil.\nYou should retain the returned copy if you are going to use it.\nreturn A Animation that was previously added. If the name is not found it will return nil.\n"
                },
                "addAnimationsWithDictionary": {
                    "type": "method",
                    "define": "addAnimationsWithDictionary(${1:#map_table dictionary},${2:#string plist})",
                    "detail": " Adds an animation from an NSDictionary.\nMake sure that the frames were previously loaded in the SpriteFrameCache.\nparam dictionary An NSDictionary.\nparam plist The path of the relative file,it use to find the plist path for load SpriteFrames.\nsince v1.1\njs NA\n"
                }
            },
            "TransitionProgressHorizontal": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene scene})",
                    "detail": " Creates a transition with duration and incoming scene.\nparam t Duration time, in seconds.\nparam scene A given scene.\nreturn An autoreleased TransitionProgressHorizontal object.\n"
                },
                "1": "new"
            },
            "Handler": [
                "ACCELEROMETER",
                "ARMATURE_EVENT",
                "ASSETSMANAGER_ERROR",
                "ASSETSMANAGER_PROGRESS",
                "ASSETSMANAGER_SUCCESS",
                "CALLFUNC",
                "CONTROL_TOUCH_DOWN",
                "CONTROL_TOUCH_DRAG_ENTER",
                "CONTROL_TOUCH_DRAG_EXIT",
                "CONTROL_TOUCH_DRAG_INSIDE",
                "CONTROL_TOUCH_DRAG_OUTSIDE",
                "CONTROL_TOUCH_UP_CANCEL",
                "CONTROL_TOUCH_UP_INSIDE",
                "CONTROL_TOUCH_UP_OUTSIDE",
                "CONTROL_VALUE_CHANGED",
                "EVENT_ACC",
                "EVENT_CONTROLLER_AXIS",
                "EVENT_CONTROLLER_CONNECTED",
                "EVENT_CONTROLLER_DISCONNECTED",
                "EVENT_CONTROLLER_KEYDOWN",
                "EVENT_CONTROLLER_KEYREPEAT",
                "EVENT_CONTROLLER_KEYUP",
                "EVENT_CUSTIOM",
                "EVENT_FOCUS",
                "EVENT_KEYBOARD_PRESSED",
                "EVENT_KEYBOARD_RELEASED",
                "EVENT_MOUSE_DOWN",
                "EVENT_MOUSE_MOVE",
                "EVENT_MOUSE_SCROLL",
                "EVENT_MOUSE_UP",
                "EVENT_PHYSICS_CONTACT_BEGIN",
                "EVENT_PHYSICS_CONTACT_POSTSOLVE",
                "EVENT_PHYSICS_CONTACT_PRESOLVE",
                "EVENT_PHYSICS_CONTACT_SEPARATE",
                "EVENT_SPINE",
                "EVENT_SPINE_ANIMATION_COMPLETE",
                "EVENT_SPINE_ANIMATION_END",
                "EVENT_SPINE_ANIMATION_EVENT",
                "EVENT_SPINE_ANIMATION_START",
                "EVENT_TOUCHES_BEGAN",
                "EVENT_TOUCHES_CANCELLED",
                "EVENT_TOUCHES_ENDED",
                "EVENT_TOUCHES_MOVED",
                "EVENT_TOUCH_BEGAN",
                "EVENT_TOUCH_CANCELLED",
                "EVENT_TOUCH_ENDED",
                "EVENT_TOUCH_MOVED",
                "GL_NODE_DRAW",
                "HTTPREQUEST_STATE_CHANGE",
                "KEYPAD",
                "MENU_CLICKED",
                "NODE",
                "SCHEDULE",
                "SCROLLVIEW_SCROLL",
                "SCROLLVIEW_ZOOM",
                "STUDIO_EVENT_LISTENER",
                "TABLECELL_AT_INDEX",
                "TABLECELL_HIGHLIGHT",
                "TABLECELL_SIZE_FOR_INDEX",
                "TABLECELL_TOUCHED",
                "TABLECELL_UNHIGHLIGHT",
                "TABLECELL_WILL_RECYCLE",
                "TABLEVIEW_NUMS_OF_CELLS",
                "TOUCHES",
                "WEBSOCKET_CLOSE",
                "WEBSOCKET_ERROR",
                "WEBSOCKET_MESSAGE",
                "WEBSOCKET_OPEN"
            ],
            "FlipY": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#bool y})",
                    "detail": " Create the action.\nparam y Flips the sprite vertically if true.\nreturn An autoreleased FlipY object.\n"
                },
                "initWithFlipY": {
                    "type": "method",
                    "define": "initWithFlipY(${1:#bool y})",
                    "detail": " init the action \n"
                }
            },
            "SpotLight": {
                "1": "new",
                "setOuterAngle": {
                    "type": "method",
                    "define": "setOuterAngle(${1:#float outerAngle})",
                    "detail": "Sets the outer angle of a spot light (in radians).\nparam outerAngle The angle of spot light (in radians).\n"
                },
                "setInnerAngle": {
                    "type": "method",
                    "define": "setInnerAngle(${1:#float angle})",
                    "detail": "Sets the inner angle of a spot light (in radians).\nparam angle The angle of spot light (in radians).\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#vec3_table direction},${2:#vec3_table position},${3:#color3b_table color},${4:#float innerAngle},${5:#float outerAngle},${6:#float range})",
                    "detail": "Creates a spot light.\nparam direction The light's direction\nparam position The light's position\nparam color The light's color.\nparam innerAngle The light's inner angle (in radians).\nparam outerAngle The light's outer angle (in radians).\nparam range The light's range.\nreturn The new spot light.\n"
                },
                "getDirectionInWorld": {
                    "type": "method",
                    "define": "getDirectionInWorld()",
                    "detail": "Returns direction in world.\n"
                },
                "getCosOuterAngle": {
                    "type": "method",
                    "define": "getCosOuterAngle()",
                    "detail": " get cos outAngle \n"
                },
                "setRange": {
                    "type": "method",
                    "define": "setRange(${1:#float range})",
                    "detail": "Sets the range of point or spot light.\nparam range The range of point or spot light.\n"
                },
                "setDirection": {
                    "type": "method",
                    "define": "setDirection(${1:#vec3_table dir})",
                    "detail": "Sets the Direction in parent.\nparam dir The Direction in parent.\n"
                },
                "getDirection": {
                    "type": "method",
                    "define": "getDirection()",
                    "detail": "Returns the Direction in parent.\n"
                },
                "getRange": {
                    "type": "method",
                    "define": "getRange()",
                    "detail": "Returns the range of point or spot light.\nreturn The range of the point or spot light.\n"
                },
                "getOuterAngle": {
                    "type": "method",
                    "define": "getOuterAngle()",
                    "detail": "Returns the outer angle of the spot light (in radians).\n"
                },
                "getInnerAngle": {
                    "type": "method",
                    "define": "getInnerAngle()",
                    "detail": "Returns the inner angle the spot light (in radians).\n"
                },
                "getCosInnerAngle": {
                    "type": "method",
                    "define": "getCosInnerAngle()",
                    "detail": " get cos innerAngle \n"
                }
            },
            "CCBProxy": [
                "create",
                "createCCBReader",
                "getNodeTypeName",
                "readCCBFromFile",
                "setCallback"
            ],
            "ActionTween": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#string key},${3:#float from},${4:#float to})",
                    "detail": "brief Create and initializes the action with the property name (key), and the from and to parameters.\nparam duration The duration of the ActionTween. It's a value in seconds.\nparam key The key of property which should be updated.\nparam from The value of the specified property when the action begin.\nparam to The value of the specified property when the action end.\nreturn If the creation success, return a pointer of ActionTween; otherwise, return nil.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#string key},${3:#float from},${4:#float to})",
                    "detail": "brief Initializes the action with the property name (key), and the from and to parameters.\nparam duration The duration of the ActionTween. It's a value in seconds.\nparam key The key of property which should be updated.\nparam from The value of the specified property when the action begin.\nparam to The value of the specified property when the action end.\nreturn If the initialization success, return true; otherwise, return false.\n"
                }
            },
            "CameraBackgroundDepthBrush": {
                "1": "new",
                "create": {
                    "type": "method",
                    "define": "create(${1:#float depth})",
                    "detail": "Create a depth brush\nparam depth Depth used to clear the depth buffer\nreturn Created brush\n"
                },
                "setDepth": {
                    "type": "method",
                    "define": "setDepth(${1:#float depth})",
                    "detail": "Set depth\nparam depth Depth used to clear depth buffer\n"
                }
            },
            "JumpTiles3D": {
                "1": "new",
                "setAmplitude": {
                    "type": "method",
                    "define": "setAmplitude(${1:#float amplitude})",
                    "detail": "brief Set the amplitude to the effect.\nparam amplitude The value of amplitude will be set.\n"
                },
                "getAmplitudeRate": {
                    "type": "method",
                    "define": "getAmplitudeRate()",
                    "detail": "brief Get the amplitude rate of the effect.\nreturn Return the amplitude rate of the effect.\n"
                },
                "setAmplitudeRate": {
                    "type": "method",
                    "define": "setAmplitudeRate(${1:#float amplitudeRate})",
                    "detail": "brief Set the amplitude rate of the effect.\nparam amplitudeRate The value of amplitude rate will be set.\n"
                },
                "getAmplitude": {
                    "type": "method",
                    "define": "getAmplitude()",
                    "detail": "brief Get the amplitude of the effect.\nreturn Return the amplitude of the effect.\n"
                },
                "initWithDuration": {
                    "type": "method",
                    "define": "initWithDuration(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int numberOfJumps},${4:#float amplitude})",
                    "detail": "brief Initializes the action with the number of jumps, the sin amplitude, the grid size and the duration.\nparam duration Specify the duration of the JumpTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam numberOfJumps Specify the jump tiles count.\nparam amplitude Specify the amplitude of the JumpTiles3D action.\nreturn If the initialization success, return true; otherwise, return false.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#float duration},${2:#size_table gridSize},${3:#unsigned int numberOfJumps},${4:#float amplitude})",
                    "detail": "brief Create the action with the number of jumps, the sin amplitude, the grid size and the duration.\nparam duration Specify the duration of the JumpTiles3D action. It's a value in seconds.\nparam gridSize Specify the size of the grid.\nparam numberOfJumps Specify the jump tiles count.\nparam amplitude Specify the amplitude of the JumpTiles3D action.\nreturn If the creation success, return a pointer of JumpTiles3D action; otherwise, return nil.\n"
                }
            },
            "RED": [
                "b",
                "g",
                "r"
            ],
            "EaseExponentialIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "EaseElastic": {
                "initWithAction": {
                    "type": "method",
                    "define": "initWithAction(${1:#cc.ActionInterval action},${2:#float period})",
                    "detail": "brief Initializes the action with the inner action and the period in radians.\nparam action The pointer of the inner action.\nparam period Period of the wave in radians. Default is 0.3.\nreturn Return true when the initialization success, otherwise return false.\n"
                },
                "setPeriod": {
                    "type": "method",
                    "define": "setPeriod(${1:#float fPeriod})",
                    "detail": "brief Set period of the wave in radians.\nparam fPeriod The value will be set.\n"
                },
                "getPeriod": {
                    "type": "method",
                    "define": "getPeriod()",
                    "detail": "brief Get period of the wave in radians. Default value is 0.3.\nreturn Return the period of the wave in radians.\n"
                }
            },
            "TextureCache": {
                "1": "addImageAsync",
                "2": "new",
                "getTextureForKey": {
                    "type": "method",
                    "define": "getTextureForKey(${1:#string key})",
                    "detail": " Returns an already created texture. Returns nil if the texture doesn't exist.\nparam key It's the related/absolute path of the file image.\nsince v0.99.5\n"
                },
                "unbindImageAsync": {
                    "type": "method",
                    "define": "unbindImageAsync(${1:#string filename})",
                    "detail": " Unbind a specified bound image asynchronous callback.\nIn the case an object who was bound to an image asynchronous callback was destroyed before the callback is invoked,\nthe object always need to unbind this callback manually.\nparam filename It's the related/absolute path of the file image.\nsince v3.1\n"
                },
                "waitForQuit": {
                    "type": "method",
                    "define": "waitForQuit()",
                    "detail": "Called by director, please do not called outside.\n"
                },
                "addImage": {
                    "type": "method",
                    "define": "addImage(${1:#cc.Image image},${2:#string key})",
                    "detail": "@overload self, cc.Image, string         \n@overload self, string         \n"
                },
                "unbindAllImageAsync": {
                    "type": "method",
                    "define": "unbindAllImageAsync()",
                    "detail": " Unbind all bound image asynchronous load callbacks.\nsince v3.1\n"
                },
                "setETC1AlphaFileSuffix": {
                    "type": "method",
                    "define": "setETC1AlphaFileSuffix(${1:#string suffix})"
                },
                "getTextureFilePath": {
                    "type": "method",
                    "define": "getTextureFilePath(${1:#cc.Texture2D texture})",
                    "detail": "Get the file path of the texture\nparam texture A Texture2D object pointer.\nreturn The full path of the file.\n"
                },
                "removeUnusedTextures": {
                    "type": "method",
                    "define": "removeUnusedTextures()",
                    "detail": " Removes unused textures.\nTextures that have a retain count of 1 will be deleted.\nIt is convenient to call this method after when starting a new Scene.\nsince v0.8\n"
                },
                "getETC1AlphaFileSuffix": {
                    "type": "method",
                    "define": "getETC1AlphaFileSuffix()"
                },
                "removeTextureForKey": {
                    "type": "method",
                    "define": "removeTextureForKey(${1:#string key})",
                    "detail": " Deletes a texture from the cache given a its key name.\nparam key It's the related/absolute path of the file image.\nsince v0.99.4\n"
                },
                "getCachedTextureInfo": {
                    "type": "method",
                    "define": "getCachedTextureInfo()",
                    "detail": " Output to CCLOG the current contents of this TextureCache.\nThis will attempt to calculate the size of each texture, and the total texture memory in use.\nsince v1.0\n"
                },
                "removeAllTextures": {
                    "type": "method",
                    "define": "removeAllTextures()",
                    "detail": " Purges the dictionary of loaded textures.\nCall this method if you receive the \"Memory Warning\".\nIn the short term: it will free some resources preventing your app from being killed.\nIn the medium term: it will allocate more resources.\nIn the long term: it will be the same.\n"
                },
                "getDescription": {
                    "type": "method",
                    "define": "getDescription()",
                    "detail": "js NA\nlua NA\n"
                },
                "removeTexture": {
                    "type": "method",
                    "define": "removeTexture(${1:#cc.Texture2D texture})",
                    "detail": " Deletes a texture from the cache given a texture.\n"
                },
                "renameTextureWithKey": {
                    "type": "method",
                    "define": "renameTextureWithKey(${1:#string srcName},${2:#string dstName})",
                    "detail": " Reload texture from a new file.\nThis function is mainly for editor, won't suggest use it in game for performance reason.\nparam srcName Original texture file name.\nparam dstName New texture file name.\nsince v3.10\n"
                },
                "reloadTexture": {
                    "type": "method",
                    "define": "reloadTexture(${1:#string fileName})",
                    "detail": " Reload texture from the image file.\nIf the file image hasn't loaded before, load it.\nOtherwise the texture will be reloaded from the file image.\nparam fileName It's the related/absolute path of the file image.\nreturn True if the reloading is succeed, otherwise return false.\n"
                }
            },
            "EaseCubicActionOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "Mesh": {
                "1": "new",
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})"
                },
                "setMaterial": {
                    "type": "method",
                    "define": "setMaterial(${1:#cc.Material material})",
                    "detail": " Sets a new Material to the Mesh \n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()"
                },
                "isVisible": {
                    "type": "method",
                    "define": "isVisible()"
                },
                "draw": {
                    "type": "method",
                    "define": "draw(${1:#cc.Renderer renderer},${2:#float globalZ},${3:#mat4_table transform},${4:#unsigned int flags},${5:#unsigned int lightMask},${6:#vec4_table color},${7:#bool forceDepthWrite})"
                },
                "getVertexSizeInBytes": {
                    "type": "method",
                    "define": "getVertexSizeInBytes()",
                    "detail": "get per vertex size in bytes\n"
                },
                "setSkin": {
                    "type": "method",
                    "define": "setSkin(${1:#cc.MeshSkin skin})",
                    "detail": "skin setter\n"
                },
                "setMeshIndexData": {
                    "type": "method",
                    "define": "setMeshIndexData(${1:#cc.MeshIndexData indexdata})",
                    "detail": "Mesh index data setter\n"
                },
                "getName": {
                    "type": "method",
                    "define": "getName()",
                    "detail": "name getter \n"
                },
                "setVisible": {
                    "type": "method",
                    "define": "setVisible(${1:#bool visible})",
                    "detail": "visible getter and setter\n"
                },
                "setName": {
                    "type": "method",
                    "define": "setName(${1:#string name})",
                    "detail": "name setter\n"
                },
                "setGLProgramState": {
                    "type": "method",
                    "define": "setGLProgramState(${1:#cc.GLProgramState glProgramState})",
                    "detail": "  Sets a new GLProgramState for the Mesh\nA new Material will be created for it\n"
                },
                "getMeshVertexAttribCount": {
                    "type": "method",
                    "define": "getMeshVertexAttribCount()",
                    "detail": "get mesh vertex attribute count\n"
                },
                "calculateAABB": {
                    "type": "method",
                    "define": "calculateAABB()",
                    "detail": "calculate the AABB of the mesh\nnote the AABB is in the local space, not the world space\n"
                },
                "getMaterial": {
                    "type": "method",
                    "define": "getMaterial()",
                    "detail": " Returns the Material being used by the Mesh \n"
                },
                "getMeshVertexAttribute": {
                    "type": "method",
                    "define": "getMeshVertexAttribute(${1:#int idx})",
                    "detail": "get MeshVertexAttribute by index\n"
                },
                "setForce2DQueue": {
                    "type": "method",
                    "define": "setForce2DQueue(${1:#bool force2D})",
                    "detail": "force set this Sprite3D to 2D render queue\n"
                }
            },
            "ActionEase": {
                "initWithAction": {
                    "type": "method",
                    "define": "initWithAction(${1:#cc.ActionInterval action})",
                    "detail": "brief Initializes the action.\nreturn Return true when the initialization success, otherwise return false.\n"
                },
                "getInnerAction": {
                    "type": "method",
                    "define": "getInnerAction()",
                    "detail": "brief Get the pointer of the inner action.\nreturn The pointer of the inner action.\n"
                }
            },
            "BaseLight": {
                "getLightType": {
                    "type": "method",
                    "define": "getLightType()",
                    "detail": "Get the light type,light type MUST be one of LightType::DIRECTIONAL ,\nLightType::POINT, LightType::SPOT, LightType::AMBIENT.\n"
                },
                "isEnabled": {
                    "type": "method",
                    "define": "isEnabled()"
                },
                "getIntensity": {
                    "type": "method",
                    "define": "getIntensity()",
                    "detail": " intensity getter and setter \n"
                },
                "setLightFlag": {
                    "type": "method",
                    "define": "setLightFlag(${1:#int flag})"
                },
                "getLightFlag": {
                    "type": "method",
                    "define": "getLightFlag()",
                    "detail": "light flag getter and setter\n"
                },
                "setEnabled": {
                    "type": "method",
                    "define": "setEnabled(${1:#bool enabled})",
                    "detail": "light enabled getter and setter.\n"
                },
                "setIntensity": {
                    "type": "method",
                    "define": "setIntensity(${1:#float intensity})"
                }
            },
            "EaseQuinticActionOut": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "ControlHuePicker": {
                "1": "new",
                "setSlider": {
                    "type": "method",
                    "define": "setSlider(${1:#cc.Sprite var})"
                },
                "getHuePercentage": {
                    "type": "method",
                    "define": "getHuePercentage()"
                },
                "initWithTargetAndPos": {
                    "type": "method",
                    "define": "initWithTargetAndPos(${1:#cc.Node target},${2:#vec2_table pos})"
                },
                "getSlider": {
                    "type": "method",
                    "define": "getSlider()"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.Node target},${2:#vec2_table pos})"
                },
                "getBackground": {
                    "type": "method",
                    "define": "getBackground()"
                },
                "getHue": {
                    "type": "method",
                    "define": "getHue()"
                },
                "setHue": {
                    "type": "method",
                    "define": "setHue(${1:#float val})"
                },
                "setHuePercentage": {
                    "type": "method",
                    "define": "setHuePercentage(${1:#float val})"
                },
                "getStartPos": {
                    "type": "method",
                    "define": "getStartPos()"
                },
                "setBackground": {
                    "type": "method",
                    "define": "setBackground(${1:#cc.Sprite var})"
                }
            },
            "ParticleSystem": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a system with a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleSystemQuad object.\njs NA\n"
                },
                "resumeEmissions": {
                    "type": "method",
                    "define": "resumeEmissions()"
                },
                "getResourceFile": {
                    "type": "method",
                    "define": "getResourceFile()"
                },
                "getRotatePerSecond": {
                    "type": "method",
                    "define": "getRotatePerSecond()",
                    "detail": " Gets the number of degrees to rotate a particle around the source pos per second.\nreturn The number of degrees to rotate a particle around the source pos per second.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "js NA\nlua NA\n"
                },
                "getEndColorVar": {
                    "type": "method",
                    "define": "getEndColorVar()",
                    "detail": " Gets the end color variance of each particle.\nreturn The end color variance of each particle.\n"
                },
                "setPosVar": {
                    "type": "method",
                    "define": "setPosVar(${1:#vec2_table pos})",
                    "detail": " Sets the position variance of the emitter.\nparam pos The position variance of the emitter.\n"
                },
                "getEmitterMode": {
                    "type": "method",
                    "define": "getEmitterMode()",
                    "detail": " Switch between different kind of emitter modes:\n- kParticleModeGravity: uses gravity, speed, radial and tangential acceleration.\n- kParticleModeRadius: uses radius movement + rotation.\nreturn The mode of the emitter.\n"
                },
                "setRotatePerSecondVar": {
                    "type": "method",
                    "define": "setRotatePerSecondVar(${1:#float degrees})",
                    "detail": " Sets the rotate per second variance.\nparam degrees The rotate per second variance.\n"
                },
                "getStartColorVar": {
                    "type": "method",
                    "define": "getStartColorVar()",
                    "detail": " Gets the start color variance of each particle.\nreturn The start color variance of each particle.\n"
                },
                "getEndSizeVar": {
                    "type": "method",
                    "define": "getEndSizeVar()",
                    "detail": " Gets the end size variance in pixels of each particle.\nreturn The end size variance in pixels of each particle.\n"
                },
                "getEndRadiusVar": {
                    "type": "method",
                    "define": "getEndRadiusVar()",
                    "detail": " Gets the end radius variance.\nreturn The end radius variance.\n"
                },
                "setRotatePerSecond": {
                    "type": "method",
                    "define": "setRotatePerSecond(${1:#float degrees})",
                    "detail": " Sets the number of degrees to rotate a particle around the source pos per second.\nparam degrees The number of degrees to rotate a particle around the source pos per second.\n"
                },
                "initWithDictionary": {
                    "type": "method",
                    "define": "initWithDictionary(${1:#map_table dictionary},${2:#string dirname})",
                    "detail": "@overload self, map_table, string         \n@overload self, map_table         \n"
                },
                "getStartRadiusVar": {
                    "type": "method",
                    "define": "getStartRadiusVar()",
                    "detail": " Gets the start radius variance.\nreturn The start radius variance.\n"
                },
                "getSourcePosition": {
                    "type": "method",
                    "define": "getSourcePosition()",
                    "detail": " Gets the source position of the emitter.\nreturn The source position of the emitter.\n"
                },
                "isFull": {
                    "type": "method",
                    "define": "isFull()",
                    "detail": " Whether or not the system is full.\nreturn True if the system is full.\n"
                },
                "setEmitterMode": {
                    "type": "method",
                    "define": "setEmitterMode(${1:#int mode})",
                    "detail": " Sets the mode of the emitter.\nparam mode The mode of the emitter.\n"
                },
                "setEmissionRate": {
                    "type": "method",
                    "define": "setEmissionRate(${1:#float rate})",
                    "detail": " Sets the emission rate of the particles.\nparam rate The emission rate of the particles.\n"
                },
                "updateParticleQuads": {
                    "type": "method",
                    "define": "updateParticleQuads()",
                    "detail": " Update the verts position data of particle,\nshould be overridden by subclasses. \n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})"
                },
                "getRadialAccelVar": {
                    "type": "method",
                    "define": "getRadialAccelVar()",
                    "detail": " Gets the radial acceleration variance.\nreturn The radial acceleration variance.\n"
                },
                "getEndColor": {
                    "type": "method",
                    "define": "getEndColor()",
                    "detail": " Gets the end color and end color variation of each particle.\nreturn The end color and end color variation of each particle.\n"
                },
                "setPositionType": {
                    "type": "method",
                    "define": "setPositionType(${1:#int type})",
                    "detail": " Sets the particles movement type: Free or Grouped.\nsince v0.8\nparam type The particles movement type.\n"
                },
                "getRotatePerSecondVar": {
                    "type": "method",
                    "define": "getRotatePerSecondVar()",
                    "detail": " Gets the rotate per second variance.\nreturn The rotate per second variance.\n"
                },
                "setAutoRemoveOnFinish": {
                    "type": "method",
                    "define": "setAutoRemoveOnFinish(${1:#bool var})",
                    "detail": " Set the particle system auto removed it self on finish.\nparam var True if the particle system removed self on finish.\n"
                },
                "getEmissionRate": {
                    "type": "method",
                    "define": "getEmissionRate()",
                    "detail": " Gets the emission rate of the particles.\nreturn The emission rate of the particles.\n"
                },
                "getAtlasIndex": {
                    "type": "method",
                    "define": "getAtlasIndex()",
                    "detail": " Gets the index of system in batch node array.\nreturn The index of system in batch node array.\n"
                },
                "getParticleCount": {
                    "type": "method",
                    "define": "getParticleCount()",
                    "detail": " Gets the Quantity of particles that are being simulated at the moment.\nreturn The Quantity of particles that are being simulated at the moment.\n"
                },
                "setSourcePosition": {
                    "type": "method",
                    "define": "setSourcePosition(${1:#vec2_table pos})",
                    "detail": " Sets the source position of the emitter.\nparam pos The source position of the emitter.\n"
                },
                "updateWithNoTime": {
                    "type": "method",
                    "define": "updateWithNoTime()",
                    "detail": " Call the update method with no time..\n"
                },
                "setBatchNode": {
                    "type": "method",
                    "define": "setBatchNode(${1:#cc.ParticleBatchNode batchNode})",
                    "detail": " Sets the batch node.\nparam batchNode The batch node.\n"
                },
                "setEndColor": {
                    "type": "method",
                    "define": "setEndColor(${1:#color4f_table color})",
                    "detail": " Sets the end color and end color variation of each particle.\nparam color The end color and end color variation of each particle.\n"
                },
                "setTotalParticles": {
                    "type": "method",
                    "define": "setTotalParticles(${1:#int totalParticles})",
                    "detail": " Sets the maximum particles of the system.\nparam totalParticles The maximum particles of the system.\n"
                },
                "stop": {
                    "type": "method",
                    "define": "stop()"
                },
                "start": {
                    "type": "method",
                    "define": "start()",
                    "detail": "/ @{/ @name implement Playable Protocol\n"
                },
                "setDuration": {
                    "type": "method",
                    "define": "setDuration(${1:#float duration})",
                    "detail": " Sets how many seconds the emitter will run. -1 means 'forever'.\nparam duration The seconds that the emitter will run. -1 means 'forever'.\n"
                },
                "stopSystem": {
                    "type": "method",
                    "define": "stopSystem()"
                },
                "getTangentialAccelVar": {
                    "type": "method",
                    "define": "getTangentialAccelVar()",
                    "detail": " Gets the tangential acceleration variance.\nreturn The tangential acceleration variance.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Initializes a system with a fixed number of particles\n"
                },
                "setAngle": {
                    "type": "method",
                    "define": "setAngle(${1:#float angle})",
                    "detail": " Sets the angle of each particle.\nparam angle The angle of each particle.\n"
                },
                "getTotalParticles": {
                    "type": "method",
                    "define": "getTotalParticles()",
                    "detail": " Gets the maximum particles of the system.\nreturn The maximum particles of the system.\n"
                },
                "getStartRadius": {
                    "type": "method",
                    "define": "getStartRadius()",
                    "detail": " Gets the start radius.\nreturn The start radius.\n"
                },
                "getBatchNode": {
                    "type": "method",
                    "define": "getBatchNode()",
                    "detail": " Gets the batch node.\nreturn The batch node.\n"
                },
                "setBlendAdditive": {
                    "type": "method",
                    "define": "setBlendAdditive(${1:#bool value})",
                    "detail": " Sets the particle system blend additive.\nparam value True if the particle system is blend additive.\n"
                },
                "setTangentialAccel": {
                    "type": "method",
                    "define": "setTangentialAccel(${1:#float t})",
                    "detail": " Sets the tangential acceleration.\nparam t The tangential acceleration.\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "code\nWhen this function bound into js or lua,the parameter will be changed\nIn js: var setBlendFunc(var src, var dst)\nIn lua: local setBlendFunc(local src, local dst)\nendcode\n"
                },
                "setEndRadiusVar": {
                    "type": "method",
                    "define": "setEndRadiusVar(${1:#float endRadiusVar})",
                    "detail": " Sets the end radius variance.\nparam endRadiusVar The end radius variance.\n"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string plistFile})",
                    "detail": " Creates an initializes a ParticleSystem from a plist file.\nThis plist files can be created manually or with Particle Designer:\nhttp:particledesigner.71squared.com/\nsince v2.0\nparam plistFile Particle plist file name.\nreturn An autoreleased ParticleSystem object.\n"
                },
                "setStartSpinVar": {
                    "type": "method",
                    "define": "setStartSpinVar(${1:#float pinVar})",
                    "detail": " Sets the start spin variance of each particle.\nparam pinVar The start spin variance of each particle.\n"
                },
                "setStartSizeVar": {
                    "type": "method",
                    "define": "setStartSizeVar(${1:#float sizeVar})",
                    "detail": " Sets the start size variance in pixels of each particle.\nparam sizeVar The start size variance in pixels of each particle.\n"
                },
                "setStartSpin": {
                    "type": "method",
                    "define": "setStartSpin(${1:#float spin})",
                    "detail": " Sets the start spin of each particle.\nparam spin The start spin of each particle.\n"
                },
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()"
                },
                "getStartSizeVar": {
                    "type": "method",
                    "define": "getStartSizeVar()",
                    "detail": " Gets the start size variance in pixels of each particle.\nreturn The start size variance in pixels of each particle.\n"
                },
                "isAutoRemoveOnFinish": {
                    "type": "method",
                    "define": "isAutoRemoveOnFinish()",
                    "detail": " Whether or not the particle system removed self on finish.\nreturn True if the particle system removed self on finish.\n"
                },
                "initWithFile": {
                    "type": "method",
                    "define": "initWithFile(${1:#string plistFile})",
                    "detail": " initializes a ParticleSystem from a plist file.\nThis plist files can be created manually or with Particle Designer:\nhttp:particledesigner.71squared.com/\nsince v0.99.3\n"
                },
                "setStartColor": {
                    "type": "method",
                    "define": "setStartColor(${1:#color4f_table color})",
                    "detail": " Sets the start color of each particle.\nparam color The start color of each particle.\n"
                },
                "setGravity": {
                    "type": "method",
                    "define": "setGravity(${1:#vec2_table g})",
                    "detail": " Sets the gravity.\nparam g The gravity.\n"
                },
                "setTangentialAccelVar": {
                    "type": "method",
                    "define": "setTangentialAccelVar(${1:#float t})",
                    "detail": " Sets the tangential acceleration variance.\nparam t The tangential acceleration variance.\n"
                },
                "getLife": {
                    "type": "method",
                    "define": "getLife()",
                    "detail": " Gets the life of each particle.\nreturn The life of each particle.\n"
                },
                "setStartRadiusVar": {
                    "type": "method",
                    "define": "setStartRadiusVar(${1:#float startRadiusVar})",
                    "detail": " Sets the start radius variance.\nparam startRadiusVar The start radius variance.\n"
                },
                "getSpeed": {
                    "type": "method",
                    "define": "getSpeed()",
                    "detail": " Gets the speed.\nreturn The speed.\n"
                },
                "getRotationIsDir": {
                    "type": "method",
                    "define": "getRotationIsDir()",
                    "detail": " Whether or not the rotation of each particle to its direction.\nreturn True if the rotation is the direction.\n"
                },
                "setStartRadius": {
                    "type": "method",
                    "define": "setStartRadius(${1:#float startRadius})",
                    "detail": " Sets the start radius.\nparam startRadius The start radius.\n"
                },
                "setStartColorVar": {
                    "type": "method",
                    "define": "setStartColorVar(${1:#color4f_table color})",
                    "detail": " Sets the start color variance of each particle.\nparam color The start color variance of each particle.\n"
                },
                "setSpeedVar": {
                    "type": "method",
                    "define": "setSpeedVar(${1:#float speed})",
                    "detail": " Sets the speed variance.\nparam speed The speed variance.\n"
                },
                "setSpeed": {
                    "type": "method",
                    "define": "setSpeed(${1:#float speed})",
                    "detail": " Sets the speed.\nparam speed The speed.\n"
                },
                "getAngle": {
                    "type": "method",
                    "define": "getAngle()",
                    "detail": " Gets the angle of each particle. \nreturn The angle of each particle.\n"
                },
                "setRotationIsDir": {
                    "type": "method",
                    "define": "setRotationIsDir(${1:#bool t})",
                    "detail": " Sets the rotation of each particle to its direction.\nparam t True if the rotation is the direction.\n"
                },
                "isActive": {
                    "type": "method",
                    "define": "isActive()",
                    "detail": " Whether or not the particle system is active.\nreturn True if the particle system is active.\n"
                },
                "setRadialAccelVar": {
                    "type": "method",
                    "define": "setRadialAccelVar(${1:#float t})",
                    "detail": " Sets the radial acceleration variance.\nparam t The radial acceleration variance.\n"
                },
                "setRadialAccel": {
                    "type": "method",
                    "define": "setRadialAccel(${1:#float t})",
                    "detail": " Sets the radial acceleration.\nparam t The radial acceleration.\n"
                },
                "setLifeVar": {
                    "type": "method",
                    "define": "setLifeVar(${1:#float lifeVar})",
                    "detail": " Sets the life variance of each particle.\nparam lifeVar The life variance of each particle.\n"
                },
                "setEndSize": {
                    "type": "method",
                    "define": "setEndSize(${1:#float endSize})",
                    "detail": " Sets the end size in pixels of each particle.\nparam endSize The end size in pixels of each particle.\n"
                },
                "pauseEmissions": {
                    "type": "method",
                    "define": "pauseEmissions()"
                },
                "getRadialAccel": {
                    "type": "method",
                    "define": "getRadialAccel()",
                    "detail": " Gets the radial acceleration.\nreturn The radial acceleration.\n"
                },
                "getStartColor": {
                    "type": "method",
                    "define": "getStartColor()",
                    "detail": " Gets the start color of each particle.\nreturn The start color of each particle.\n"
                },
                "getEndSize": {
                    "type": "method",
                    "define": "getEndSize()",
                    "detail": " Gets the end size in pixels of each particle.\nreturn The end size in pixels of each particle.\n"
                },
                "addParticles": {
                    "type": "method",
                    "define": "addParticles(${1:#int count})"
                },
                "setLife": {
                    "type": "method",
                    "define": "setLife(${1:#float life})",
                    "detail": " Sets the life of each particle.\nparam life The life of each particle.\n"
                },
                "getLifeVar": {
                    "type": "method",
                    "define": "getLifeVar()",
                    "detail": " Gets the life variance of each particle.\nreturn The life variance of each particle.\n"
                },
                "getPositionType": {
                    "type": "method",
                    "define": "getPositionType()",
                    "detail": " Gets the particles movement type: Free or Grouped.\nsince v0.8\nreturn The particles movement type.\n"
                },
                "setEndSpinVar": {
                    "type": "method",
                    "define": "setEndSpinVar(${1:#float endSpinVar})",
                    "detail": " Sets the end spin variance of each particle.\nparam endSpinVar The end spin variance of each particle.\n"
                },
                "getEndRadius": {
                    "type": "method",
                    "define": "getEndRadius()",
                    "detail": " Gets the end radius.\nreturn The end radius.\n"
                },
                "setEndSpin": {
                    "type": "method",
                    "define": "setEndSpin(${1:#float endSpin})",
                    "detail": " Sets the end spin of each particle.\nparam endSpin The end spin of each particle.\n"
                },
                "postStep": {
                    "type": "method",
                    "define": "postStep()",
                    "detail": " Update the VBO verts buffer which does not use batch node,\nshould be overridden by subclasses. \n"
                },
                "setEndSizeVar": {
                    "type": "method",
                    "define": "setEndSizeVar(${1:#float sizeVar})",
                    "detail": " Sets the end size variance in pixels of each particle.\nparam sizeVar The end size variance in pixels of each particle.\n"
                },
                "getStartSpinVar": {
                    "type": "method",
                    "define": "getStartSpinVar()",
                    "detail": " Gets the start spin variance of each particle.\nreturn The start spin variance of each particle.\n"
                },
                "getEndSpin": {
                    "type": "method",
                    "define": "getEndSpin()",
                    "detail": " Gets the end spin of each particle.\nreturn The end spin of each particle.\n"
                },
                "getSpeedVar": {
                    "type": "method",
                    "define": "getSpeedVar()",
                    "detail": " Gets the speed variance.\nreturn The speed variance.\n"
                },
                "setEndRadius": {
                    "type": "method",
                    "define": "setEndRadius(${1:#float endRadius})",
                    "detail": " Sets the end radius.\nparam endRadius The end radius.\n"
                },
                "getAngleVar": {
                    "type": "method",
                    "define": "getAngleVar()",
                    "detail": " Gets the angle variance of each particle.\nreturn The angle variance of each particle.\n"
                },
                "getStartSize": {
                    "type": "method",
                    "define": "getStartSize()",
                    "detail": " Gets the start size in pixels of each particle.\nreturn The start size in pixels of each particle.\n"
                },
                "getGravity": {
                    "type": "method",
                    "define": "getGravity()",
                    "detail": " Gets the gravity.\nreturn The gravity.\n"
                },
                "getTangentialAccel": {
                    "type": "method",
                    "define": "getTangentialAccel()",
                    "detail": " Gets the tangential acceleration.\nreturn The tangential acceleration.\n"
                },
                "setAngleVar": {
                    "type": "method",
                    "define": "setAngleVar(${1:#float angleVar})",
                    "detail": " Sets the angle variance of each particle.\nparam angleVar The angle variance of each particle.\n"
                },
                "setAtlasIndex": {
                    "type": "method",
                    "define": "setAtlasIndex(${1:#int index})",
                    "detail": " Sets the index of system in batch node array.\nparam index The index of system in batch node array.\n"
                },
                "isPaused": {
                    "type": "method",
                    "define": "isPaused()",
                    "detail": " Are the emissions paused\nreturn True if the emissions are paused, else false\n"
                },
                "setEndColorVar": {
                    "type": "method",
                    "define": "setEndColorVar(${1:#color4f_table color})",
                    "detail": " Sets the end color variance of each particle.\nparam color The end color variance of each particle.\n"
                },
                "getEndSpinVar": {
                    "type": "method",
                    "define": "getEndSpinVar()",
                    "detail": " Gets the end spin variance of each particle.\nreturn The end spin variance of each particle.\n"
                },
                "isBlendAdditive": {
                    "type": "method",
                    "define": "isBlendAdditive()",
                    "detail": " Whether or not the particle system is blend additive.\nreturn True if the particle system is blend additive.\n"
                },
                "getDuration": {
                    "type": "method",
                    "define": "getDuration()",
                    "detail": " Gets how many seconds the emitter will run. -1 means 'forever'.\nreturn The seconds that the emitter will run. -1 means 'forever'.\n"
                },
                "getPosVar": {
                    "type": "method",
                    "define": "getPosVar()",
                    "detail": " Gets the position variance of the emitter.\nreturn The position variance of the emitter.\n"
                },
                "getStartSpin": {
                    "type": "method",
                    "define": "getStartSpin()",
                    "detail": " Gets the start spin of each particle.\nreturn The start spin of each particle.\n"
                },
                "setStartSize": {
                    "type": "method",
                    "define": "setStartSize(${1:#float startSize})",
                    "detail": " Sets the start size in pixels of each particle.\nparam startSize The start size in pixels of each particle.\n"
                },
                "resetSystem": {
                    "type": "method",
                    "define": "resetSystem()",
                    "detail": " Kill all living particles.\n"
                }
            },
            "CardinalSplineBy": [
                "create",
                "new"
            ],
            "EventAssetsManagerEx": {
                "EventCode": [
                    "ALREADY_UP_TO_DATE",
                    "ASSET_UPDATED",
                    "ERROR_DECOMPRESS",
                    "ERROR_DOWNLOAD_MANIFEST",
                    "ERROR_NO_LOCAL_MANIFEST",
                    "ERROR_PARSE_MANIFEST",
                    "ERROR_UPDATING",
                    "NEW_VERSION_FOUND",
                    "UPDATE_FAILED",
                    "UPDATE_FINISHED",
                    "UPDATE_PROGRESSION"
                ]
            },
            "TransitionZoomFlipAngular": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#float t},${2:#cc.Scene s},${3:#int o})",
                    "detail": "@overload self, float, cc.Scene         \n@overload self, float, cc.Scene, int         \n"
                },
                "1": "new"
            },
            "ParticleFlower": {
                "1": "new",
                "createWithTotalParticles": {
                    "type": "method",
                    "define": "createWithTotalParticles(${1:#int numberOfParticles})",
                    "detail": " Create a flower particle system withe a fixed number of particles.\nparam numberOfParticles A given number of particles.\nreturn An autoreleased ParticleFlower object.\njs NA\n"
                },
                "init": {
                    "type": "method",
                    "define": "init()"
                },
                "create": {
                    "type": "method",
                    "define": "create()",
                    "detail": " Create a flower particle system.\nreturn An autoreleased ParticleFlower object.\n"
                },
                "initWithTotalParticles": {
                    "type": "method",
                    "define": "initWithTotalParticles(${1:#int numberOfParticles})"
                }
            },
            "MenuItemLabel": {
                "1": "create",
                "2": "new",
                "setDisabledColor": {
                    "type": "method",
                    "define": "setDisabledColor(${1:#color3b_table color})",
                    "detail": " Sets the color that will be used when the item is disabled. \n"
                },
                "initWithLabel": {
                    "type": "method",
                    "define": "initWithLabel(${1:#cc.Node label},${2:#function callback})",
                    "detail": " Initializes a MenuItemLabel with a Label, target and selector. \n"
                },
                "getLabel": {
                    "type": "method",
                    "define": "getLabel()",
                    "detail": " Gets the label that is rendered. \n"
                },
                "getDisabledColor": {
                    "type": "method",
                    "define": "getDisabledColor()",
                    "detail": " Gets the color that will be used when the item is disabled. \n"
                },
                "getString": {
                    "type": "method",
                    "define": "getString()",
                    "detail": " Get the inner string of the inner label. \n"
                },
                "setString": {
                    "type": "method",
                    "define": "setString(${1:#string label})",
                    "detail": " Sets a new string to the inner label. \n"
                },
                "setLabel": {
                    "type": "method",
                    "define": "setLabel(${1:#cc.Node node})",
                    "detail": " Sets the label that is rendered. \n"
                }
            },
            "EventFocus": [
                "new"
            ],
            "EaseQuarticActionIn": {
                "create": {
                    "type": "method",
                    "define": "create(${1:#cc.ActionInterval action})"
                },
                "1": "new"
            },
            "CCBReader": {
                "1": "getActionManager",
                "2": "load",
                "3": "new",
                "4": "setActionManager",
                "addOwnerOutletNode": {
                    "type": "method",
                    "define": "addOwnerOutletNode(${1:#cc.Node node})"
                },
                "getOwnerCallbackNodes": {
                    "type": "method",
                    "define": "getOwnerCallbackNodes()"
                },
                "addDocumentCallbackControlEvents": {
                    "type": "method",
                    "define": "addDocumentCallbackControlEvents(${1:#int eventType})"
                },
                "getAnimationManagersForNodes": {
                    "type": "method",
                    "define": "getAnimationManagersForNodes()"
                },
                "getOwnerCallbackControlEvents": {
                    "type": "method",
                    "define": "getOwnerCallbackControlEvents()"
                },
                "readUTF8": {
                    "type": "method",
                    "define": "readUTF8()"
                },
                "addOwnerCallbackControlEvents": {
                    "type": "method",
                    "define": "addOwnerCallbackControlEvents(${1:#int type})"
                },
                "readCallbackKeyframesForSeq": {
                    "type": "method",
                    "define": "readCallbackKeyframesForSeq(${1:#cc.CCBSequence seq})"
                },
                "getCCBRootPath": {
                    "type": "method",
                    "define": "getCCBRootPath()"
                },
                "setResolutionScale": {
                    "type": "method",
                    "define": "setResolutionScale(${1:#float scale})"
                },
                "getOwnerOutletNames": {
                    "type": "method",
                    "define": "getOwnerOutletNames()"
                },
                "getNodesWithAnimationManagers": {
                    "type": "method",
                    "define": "getNodesWithAnimationManagers()"
                },
                "setCCBRootPath": {
                    "type": "method",
                    "define": "setCCBRootPath(${1:#char ccbRootPath})"
                },
                "getOwnerCallbackNames": {
                    "type": "method",
                    "define": "getOwnerCallbackNames()"
                },
                "getOwnerOutletNodes": {
                    "type": "method",
                    "define": "getOwnerOutletNodes()"
                },
                "addOwnerOutletName": {
                    "type": "method",
                    "define": "addOwnerOutletName(${1:#string name})"
                },
                "readSoundKeyframesForSeq": {
                    "type": "method",
                    "define": "readSoundKeyframesForSeq(${1:#cc.CCBSequence seq})"
                }
            },
            "ParticleBatchNode": {
                "removeChildAtIndex": {
                    "type": "method",
                    "define": "removeChildAtIndex(${1:#int index},${2:#bool doCleanup})",
                    "detail": " Remove a child of the ParticleBatchNode.\nparam index The index of the child.\nparam doCleanup True if all actions and callbacks on this node should be removed, false otherwise.\n"
                },
                "setTextureAtlas": {
                    "type": "method",
                    "define": "setTextureAtlas(${1:#cc.TextureAtlas atlas})",
                    "detail": " Sets the texture atlas used for drawing the quads.\nparam atlas The texture atlas used for drawing the quads.\n"
                },
                "removeAllChildrenWithCleanup": {
                    "type": "method",
                    "define": "removeAllChildrenWithCleanup(${1:#bool doCleanup})"
                },
                "createWithTexture": {
                    "type": "method",
                    "define": "createWithTexture(${1:#cc.Texture2D tex},${2:#int capacity})",
                    "detail": " Create the particle system with Texture2D, a capacity of particles, which particle system to use.\nparam tex A given texture.\nparam capacity A capacity of particles.\nreturn An autoreleased ParticleBatchNode object.\njs NA\n"
                },
                "setTexture": {
                    "type": "method",
                    "define": "setTexture(${1:#cc.Texture2D texture})"
                },
                "create": {
                    "type": "method",
                    "define": "create(${1:#string fileImage},${2:#int capacity})",
                    "detail": " Create the particle system with the name of a file on disk (for a list of supported formats look at the Texture2D class), a capacity of particles.\nparam fileImage A given file name.\nparam capacity A capacity of particles.\nreturn An autoreleased ParticleBatchNode object.\n"
                },
                "getBlendFunc": {
                    "type": "method",
                    "define": "getBlendFunc()",
                    "detail": "js NA\nlua NA\n"
                },
                "setBlendFunc": {
                    "type": "method",
                    "define": "setBlendFunc(${1:#cc.BlendFunc blendFunc})",
                    "detail": "code\nWhen this function bound into js or lua,the parameter will be changed\nIn js: var setBlendFunc(var src, var dst)\nendcode\nlua NA\n"
                },
                "1": "new",
                "getTexture": {
                    "type": "method",
                    "define": "getTexture()"
                },
                "initWithTexture": {
                    "type": "method",
                    "define": "initWithTexture(${1:#cc.Texture2D tex},${2:#int capacity})",
                    "detail": " initializes the particle system with Texture2D, a capacity of particles \n"
                },
                "insertChild": {
                    "type": "method",
                    "define": "insertChild(${1:#cc.ParticleSystem system},${2:#int index})",
                    "detail": " Inserts a child into the ParticleBatchNode.\nparam system A given particle system.\nparam index The insert index.\n"
                },
                "initWithFile": {
                    "type": "method",
                    "define": "initWithFile(${1:#string fileImage},${2:#int capacity})",
                    "detail": " initializes the particle system with the name of a file on disk (for a list of supported formats look at the Texture2D class), a capacity of particles \n"
                },
                "getTextureAtlas": {
                    "type": "method",
                    "define": "getTextureAtlas()",
                    "detail": " Gets the texture atlas used for drawing the quads.\nreturn The texture atlas used for drawing the quads.\n"
                },
                "disableParticle": {
                    "type": "method",
                    "define": "disableParticle(${1:#int particleIndex})",
                    "detail": " Disables a particle by inserting a 0'd quad into the texture atlas.\nparam particleIndex The index of the particle.\n"
                }
            }
        },
        "tolua": [
            "cast",
            "getcfunction",
            "getpeer",
            "inherit",
            "iskindof",
            "isnull",
            "releaseownership",
            "setpeer",
            "takeownership",
            "type"
        ],
        "math": [
            "abs",
            "acos",
            "angle2radian",
            "asin",
            "atan",
            "atan2",
            "ceil",
            "cos",
            "cosh",
            "deg",
            "exp",
            "floor",
            "fmod",
            "frexp",
            "huge",
            "ldexp",
            "log",
            "log10",
            "max",
            "min",
            "mod",
            "modf",
            "newrandomseed",
            "pi",
            "pow",
            "rad",
            "radian2angle",
            "random",
            "randomseed",
            "round",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh"
        ],
        "json": [
            "_NAME",
            "_PACKAGE",
            "decode",
            "encode",
            "null"
        ],
        "os": [
            "clock",
            "date",
            "difftime",
            "execute",
            "exit",
            "getenv",
            "remove",
            "rename",
            "setlocale",
            "time",
            "tmpname"
        ],
        "AudioEngine": [
            "destroyInstance",
            "getEffectsVolume",
            "getInstance",
            "getMusicVolume",
            "isMusicPlaying",
            "pauseAllEffects",
            "pauseEffect",
            "pauseMusic",
            "playEffect",
            "playMusic",
            "preloadEffect",
            "preloadMusic",
            "resumeAllEffects",
            "resumeEffect",
            "resumeMusic",
            "rewindMusic",
            "setEffectsVolume",
            "setMusicVolume",
            "stopAllEffects",
            "stopEffect",
            "stopMusic",
            "unloadEffect",
            "willPlayMusic"
        ],
        "bit": [
            "_and",
            "_b2d",
            "_d2b",
            "_not",
            "_or",
            "_rshift",
            "arshift",
            "band",
            "bnot",
            "bor",
            "bswap",
            "bxor",
            "lshift",
            "rol",
            "ror",
            "rshift",
            "tobit",
            "tohex"
        ],
        "string": {
            "1": "byte",
            "2": "char",
            "3": "dump",
            "4": "find",
            "5": "format",
            "6": "formatnumberthousands",
            "7": "gfind",
            "8": "gmatch",
            "9": "gsub",
            "10": "htmlspecialchars",
            "11": "len",
            "12": "lower",
            "13": "ltrim",
            "14": "match",
            "15": "nl2br",
            "16": "rep",
            "17": "restorehtmlspecialchars",
            "18": "reverse",
            "19": "rtrim",
            "20": "split",
            "21": "sub",
            "22": "text2html",
            "23": "trim",
            "24": "ucfirst",
            "25": "upper",
            "26": "urldecode",
            "27": "urlencode",
            "28": "utf8len",
            "29": "utf8sub",
            "_htmlspecialchars_set": [
                "\"",
                "&",
                "'",
                "<",
                ">"
            ]
        },
        "debug": [
            "debug",
            "getfenv",
            "gethook",
            "getinfo",
            "getlocal",
            "getmetatable",
            "getregistry",
            "getupvalue",
            "setfenv",
            "sethook",
            "setlocal",
            "setmetatable",
            "setupvalue",
            "traceback",
            "upvalueid",
            "upvaluejoin"
        ],
        "CCPoint": [
            "call",
            "collector",
            "new",
            "new_local"
        ],
        "CCRect": [
            "call",
            "new",
            "new_local"
        ],
        "Socket": [
            "call",
            "collector",
            "close",
            "connect",
            "delete",
            "isConnected",
            "new",
            "new_local",
            "send",
            "setLuaHandler"
        ]
    }
}
